<!doctype html>
<html lang="en">
<head><!-- hexo injector head_begin start -->
<script src="/config.d36401bfb1e03c6a7a7f.js"></script>
<!-- hexo injector head_begin end -->
<meta charset="utf-8">
<title>数字图像处理期末 - JNbuck Blog</title>
<base href="/">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
<link rel="canonical" href="https://jnbuck.top/2021/06/08/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E6%9C%9F%E6%9C%AB/">
<link rel="icon" type="image/x-icon" href="/favicon.ico">

<meta name="description" content="本笔记主要是服务于广东工业大学（GDUT）数字图像处理期末考试，内涵全部考试范围内的程序  [TOC] 01位图处理程序的最小系统 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071">
<meta property="og:type" content="website">
<meta property="og:title" content="数字图像处理期末">
<meta property="og:url" content="https://jnbuck.top/2021/06/08/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E6%9C%9F%E6%9C%AB/index.html">
<meta property="og:site_name" content="JNbuck Blog">
<meta property="og:description" content="本笔记主要是服务于广东工业大学（GDUT）数字图像处理期末考试，内涵全部考试范围内的程序  [TOC] 01位图处理程序的最小系统 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://jnbuck.top/css/1.png">
<meta property="article:published_time" content="2021-06-09T01:47:16.000Z">
<meta property="article:modified_time" content="2021-06-09T09:49:52.261Z">
<meta property="article:author" content="JNbuck">
<meta property="article:tag" content="数字图像处理 C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jnbuck.top/css/1.png">
<script type="application/ld+json">[{"@context":"http://schema.org","@type":"WebSite","publisher":{"@type":"Person","name":"JNbuck","description":"稳稳的做自己,慢慢的一路走下去便是了","image":"https://jnbuck.top/css/1.png"},"url":"https://jnbuck.top","image":"https://jnbuck.top/css/1.png","description":"一个自学Javaweb的光学工程boy的记录网站","author":{"@type":"Person","name":"JNbuck","description":"稳稳的做自己,慢慢的一路走下去便是了","image":"https://jnbuck.top/css/1.png"},"inLanguage":{"@type":"Language","alternateName":"en"}},{"@context":"http://schema.org","@type":"Article","articleSection":"课内学习","url":"https://jnbuck.top/2021/06/08/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E6%9C%9F%E6%9C%AB/","headline":"数字图像处理期末","image":"https://jnbuck.top/css/1.png","datePublished":"2021-06-09T01:47:16.000Z","dateModified":"2021-06-09T09:49:52.261Z","keywords":"数字图像处理 C++","description":"\n本笔记主要是服务于广东工业大学（GDUT）数字图像处理期末考试，内涵全部考试范围内的程序\n\n[TOC]\n01位图处理程序的最小系统\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;afxwin.h&gt; #include &lt;afxext.h&gt; #include &lt;afxdisp.h&gt;   #include &lt;afxdtctl.h&gt;#include &quot;resource.h&quot;/*文档类*/class CDoc: public CDocument&#123;\t\tDECLARE_DYNCREATE(CDoc)&#125;;IMPLEMENT_DYNCREATE(CDoc, CDocument)/*主帧窗口类*/class CMainFrame : public CFrameWnd&#123;\t\tDECLARE_DYNCREATE(CMainFrame)&#125;;IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)/*视图类*/class CMyView : public CView&#123;public:\t//区域一：↓↓↓↓↓↓↓以下区域可自由写代码，其它区域请勿作任何修改↓↓↓↓↓\t//↑↑↑↑↑↑↑↑↑↑↑自由写代码区域截止线，其它区域请勿作任何修改↑↑↑↑↑\tDECLARE_MESSAGE_MAP()\tDECLARE_DYNCREATE(CMyView)public:\tCMyView()\t&#123;\t//区域二：↓↓↓↓↓↓↓以下区域可自由写代码，其它区域请勿作任何修改↓↓↓↓↓\t//↑↑↑↑↑↑↑↑↑↑↑自由写代码区域截止线，其它区域请勿作任何修改↑↑↑↑↑\t&#125;\tvirtual ~CMyView()&#123;&#125;\tpublic:\tvirtual void OnDraw(CDC* pDC)&#123;&#125; \tprotected:                                                          \tafx_msg void On01();                                            &#125;;                                                                  IMPLEMENT_DYNCREATE(CMyView, CView)                       BEGIN_MESSAGE_MAP(CMyView, CView)                       \t\tON_COMMAND(ID01, On01)                                           \tEND_MESSAGE_MAP()                                                                                                                        /*应用程序类*/                                                      class CApp : public CWinApp&#123;\tvirtual BOOL InitInstance(); &#125;;BOOL CApp::InitInstance ()                             &#123;\t\tCSingleDocTemplate* pDocTemplate= new CSingleDocTemplate(IDR_MENU1,RUNTIME_CLASS(CDoc),\t\t\t\t\t\t\t\t\t\t\t\t\tRUNTIME_CLASS(CMainFrame),RUNTIME_CLASS(CMyView));\t\tAddDocTemplate(pDocTemplate);CCommandLineInfo cmdInfo;ParseCommandLine(cmdInfo);\t\tif (!ProcessShellCommand(cmdInfo))\treturn FALSE;            \t\tm_pMainWnd-&gt;ShowWindow(SW_SHOW);m_pMainWnd-&gt;UpdateWindow();  \t\tm_pMainWnd-&gt;SetWindowPos(NULL,0,0,800,600,0);                \t\tm_pMainWnd-&gt;SetWindowText(&quot;版本1.01.&quot;);\t\treturn TRUE;                                                 &#125;                                                                    CApp theApp;                                             //区域三：↓↓↓↓↓↓↓以下区域可自由写代码，其它区域请勿作任何修改↓↓↓↓↓void CMyView::On01() &#123;\tCBitmap hbitmap;         //利用&quot;位图类&quot;声明一个标识符为&quot;hbitmap&quot;的变量\tBITMAP bm;               //利用&quot;位图文件头结构体&quot;声明一个标识符为&quot;bm&quot;的变量    unsigned char *buffer;            //声明了一个8位整型数&quot;buffer&quot;指针\tint Hang,Lie,WidthBytes;       //声明行总数目，列总数目，一行象素占据的字节个数    \t\t\t\t\t\t\t//对于RGB图像而言，一个像素三字节\thbitmap.DeleteObject();                                  //位图类的清空位图函数\thbitmap.LoadBitmap (IDB_BITMAP2);                        //加载位图文件\thbitmap.GetBitmap (&amp;bm);     //将所加载的位图文件的头文件信息装载到标识符为&quot;bm&quot;的变量中\tHang=bm.bmHeight,Lie=bm.bmWidth,WidthBytes=bm.bmWidthBytes;    //值得注意的是unsigned char是一个无符号位的char，可以将其容量看为一个字节（1Byte）或者8bit\tbuffer= new unsigned char[Hang*WidthBytes];    //buffer指向一个数组，这个数组的大小可以装下该图像的所有字节！！！！！    \t\t\t\t\t\t\t\t\t\t\t//注意是字节！！！\t//新开辟一段由上述三个变量决定个数的8位整形数组然后被buffer指针所指向\thbitmap.GetBitmapBits (Hang*WidthBytes, buffer);   //录入buffer数组的位图数据    //buffer[j*WidthBytes+i*4+k];\tint i,j;\t//定义像素坐标变量\tint tempR,tempG,tempB;\t//定义红绿蓝像素数据变量    CDC *pDC;\t//定义CDC类的指针变量\tpDC=GetDC();\t//获得当前窗口描述设备对象的指针     for(j=0;j&lt;Hang;j++)\t&#123;\t\tfor(i=0;i&lt;Lie;i++)\t\t&#123;\t             //WidthBytes/Lie = 每一个像素的字节数             //i*(WidthBytes/Lie) = 每个像素字节数的起始索引，由于i在循环中退一位了，所以此时不用-1\t\t\ttempR=buffer[j*WidthBytes+i*WidthBytes/Lie+2];\t\t\ttempG=buffer[j*WidthBytes+i*WidthBytes/Lie+1];\t\t\ttempB=buffer[j*WidthBytes+i*WidthBytes/Lie+0];             //一次循环读取一次RGB数据送入SetPixel方法生成像素点数据    \t    pDC-&gt;SetPixel(i,j,RGB(tempR,tempG,tempB));\t\t&#125;\t&#125;&#125;\n02 直方图\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include &lt;afxwin.h&gt; #include &lt;afxext.h&gt; #include &lt;afxdisp.h&gt;   #include &lt;afxdtctl.h&gt;#include &quot;resource.h&quot;/*文档类*/class CDoc: public CDocument&#123;\t\tDECLARE_DYNCREATE(CDoc)&#125;;IMPLEMENT_DYNCREATE(CDoc, CDocument)/*主帧窗口类*/class CMainFrame : public CFrameWnd&#123;\t\tDECLARE_DYNCREATE(CMainFrame)&#125;;IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)/*视图类*/class CMyView : public CView&#123;public:\t//区域一：↓↓↓↓↓↓↓以下区域可自由写代码，其它区域请勿作任何修改↓↓↓↓↓\t//↑↑↑↑↑↑↑↑↑↑↑自由写代码区域截止线，其它区域请勿作任何修改↑↑↑↑↑\tDECLARE_MESSAGE_MAP()\tDECLARE_DYNCREATE(CMyView)public:\tCMyView()\t&#123;\t//区域二：↓↓↓↓↓↓↓以下区域可自由写代码，其它区域请勿作任何修改↓↓↓↓↓\t//↑↑↑↑↑↑↑↑↑↑↑自由写代码区域截止线，其它区域请勿作任何修改↑↑↑↑↑\t&#125;\tvirtual ~CMyView()&#123;&#125;\tpublic:\tvirtual void OnDraw(CDC* pDC)&#123;&#125; \tprotected:                                                          \tafx_msg void On01();                                            &#125;;                                                                  IMPLEMENT_DYNCREATE(CMyView, CView)                       BEGIN_MESSAGE_MAP(CMyView, CView)                                                  \tON_COMMAND(ID01, On01)                                           END_MESSAGE_MAP()                                                                                                                        /*应用程序类*/                                                      class CApp : public CWinApp&#123;\tvirtual BOOL InitInstance(); &#125;;BOOL CApp::InitInstance ()                             &#123;\t\tCSingleDocTemplate* pDocTemplate= new CSingleDocTemplate(IDR_MENU1,RUNTIME_CLASS(CDoc),\t\t\t\t\t\t\t\t\t\t\t\t\tRUNTIME_CLASS(CMainFrame),RUNTIME_CLASS(CMyView));\t\tAddDocTemplate(pDocTemplate);CCommandLineInfo cmdInfo;ParseCommandLine(cmdInfo);\t\tif (!ProcessShellCommand(cmdInfo))\treturn FALSE;            \t\tm_pMainWnd-&gt;ShowWindow(SW_SHOW);m_pMainWnd-&gt;UpdateWindow();  \t\tm_pMainWnd-&gt;SetWindowPos(NULL,0,0,800,600,0);                \t\tm_pMainWnd-&gt;SetWindowText(&quot;版本1.01.&quot;);\t\treturn TRUE;                                                 &#125;                                                                    CApp theApp;                                             //区域三：↓↓↓↓↓↓↓以下区域可自由写代码，其它区域请勿作任何修改↓↓↓↓↓void CMyView::On01() &#123;\tCBitmap hbitmap;         //利用&quot;位图类&quot;声明一个标识符为&quot;hbitmap&quot;的变量\tBITMAP bm;               //利用&quot;位图文件头结构体&quot;声明一个标识符为&quot;bm&quot;的变量    unsigned char *buffer;            //声明了一个8位整型数&quot;buffer&quot;指针\tint Hang,Lie,WidthBytes;       //声明行总数目，列总数目，一行象素占据的字节个数\thbitmap.DeleteObject();                                  //位图类的清空位图函数\thbitmap.LoadBitmap (IDB_BITMAP2);                        //加载位图文件\thbitmap.GetBitmap (&amp;bm);     //将所加载的位图文件的头文件信息装载到标识符为&quot;bm&quot;的变量中\tHang=bm.bmHeight,Lie=bm.bmWidth,WidthBytes=bm.bmWidthBytes;\tbuffer= new unsigned char[Hang*WidthBytes]; \t//buffer指向一个数组，这个数组的大小可以装下该图像的所有字节！！！！！    \t\t\t\t\t\t\t\t\t\t\t//注意是字节！！！\t//新开辟一段由上述三个变量决定个数的8位整形数组然后被buffer指针所指向\thbitmap.GetBitmapBits (Hang*WidthBytes, buffer);   //录入buffer数组的位图数据    //buffer[j*WidthBytes+i*4+k];\tint i,j;\t\\\\定义像素坐标变量\tint tempR,tempG,tempB;\t\\\\定义红绿蓝像素数据变量    CDC *pDC;\t\\\\定义CDC类的指针变量\tpDC=GetDC();\t\\\\获得当前窗口描述设备对象的指针    for(j=0;j&lt;Hang;j++)\t&#123;\t\tfor(i=0;i&lt;Lie;i++)\t\t&#123;\t\t\ttempR=buffer[j*WidthBytes+i*WidthBytes/Lie+2];\t\t\ttempG=buffer[j*WidthBytes+i*WidthBytes/Lie+1];\t\t\ttempB=buffer[j*WidthBytes+i*WidthBytes/Lie+0];    \t    pDC-&gt;SetPixel(i,j,RGB(tempR,tempG,tempB));\t\t&#125;\t&#125;\tMessageBox(&quot;以下将RGB图转灰度图&quot;);\tint temp;\t\t\t\t\t\t//定义整型变量，当前循环到的像素的灰度值会暂时赋值给这个变量    unsigned char *buffer2;            //声明了一个8位整型数&quot;buffer&quot;指针，灰度图像的像素灰度数据将会存储在该指针指向的空间\tbuffer2= new unsigned char[Hang*Lie];\t//因为我们知道这个数组存储的数据是灰度值，灰度值是[0~255],只需要一个字节，因此该    \t\t\t\t\t\t\t\t\t //数组存储的数据量大小为Hang*Lie*1    for(j=0;j&lt;Hang;j++)\t&#123;\t\tfor(i=0;i&lt;Lie;i++)\t\t&#123;\t\t\ttempR=buffer[j*WidthBytes+i*WidthBytes/Lie+2];\t//红[0~255]\t\t\ttempG=buffer[j*WidthBytes+i*WidthBytes/Lie+1];\t//绿[0~255]\t\t\ttempB=buffer[j*WidthBytes+i*WidthBytes/Lie+0];\t//蓝[0~255]\t\t\ttemp=(tempR+tempG+tempB)/3;\t\t//将RGB值相加除以3取平均值    \t    pDC-&gt;SetPixel(i,j,RGB(temp,temp,temp));\t//将灰度值作为原来数组的RGB数据传入，因为RGB都是一个值，显示出来的颜色是一个灰色            \t\t\t\t\t\t\t\t\t //原理参照RGB颜色模型说明\t\t\tbuffer2[j*Lie+i]=temp;\t// 向buffer这个装灰度图所有数据的数组装入计算好的灰度值\t\t&#125;\t&#125;\tint Zhifangtu[256];\t//众所周知，直方图描述图像中具有该灰度级的像素的个数    for(int k=0;k&lt;256;k++)\t\tZhifangtu[k]=0;\t//先将这个直方图进行初始化，所有的元素赋0，防止数组未赋值的随机数干扰程序\tMessageBox(&quot;以下灰度图的直方图输出&quot;);\tfor(j=0;j&lt;Hang;j++)\t&#123;\t\tfor(i=0;i&lt;Lie;i++)\t\t&#123;\t\t\ttemp=buffer2[j*Lie+i];\t//存储循环到的像素的灰度值\t\t\tZhifangtu[temp]++;\t//为相应的灰度级+1\t\t&#125;\t&#125;\t    //\t以下是简单的图像存储和位图移动\tFILE* fp=fopen(&quot;F://abc.txt&quot;,&quot;w&quot;);\tfor(k=0;k&lt;256;k++)\t\tfprintf(fp,&quot;灰阶＝%d 次数=%d\\n&quot;,k,Zhifangtu[k]);\tfclose(fp);\tfor(k=0;k&lt;256;k++)\t&#123;\t\tpDC-&gt;MoveTo(Lie+20+k,Hang);\t\tpDC-&gt;LineTo(Lie+20+k,Hang-Zhifangtu[k]*0.1);\t&#125;&#125;\n03 点运算\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169#include &lt;afxwin.h&gt; #include &lt;afxext.h&gt; #include &lt;afxdisp.h&gt;   #include &lt;afxdtctl.h&gt;#include &quot;resource.h&quot;/*文档类*/class CDoc: public CDocument&#123;\t\tDECLARE_DYNCREATE(CDoc)&#125;;IMPLEMENT_DYNCREATE(CDoc, CDocument)/*主帧窗口类*/class CMainFrame : public CFrameWnd&#123;\t\tDECLARE_DYNCREATE(CMainFrame)&#125;;IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)/*视图类*/class CMyView : public CView&#123;public:\t//区域一：↓↓↓↓↓↓↓以下区域可自由写代码，其它区域请勿作任何修改↓↓↓↓↓\t//↑↑↑↑↑↑↑↑↑↑↑自由写代码区域截止线，其它区域请勿作任何修改↑↑↑↑↑\tDECLARE_MESSAGE_MAP()\tDECLARE_DYNCREATE(CMyView)public:\tCMyView()\t&#123;\t//区域二：↓↓↓↓↓↓↓以下区域可自由写代码，其它区域请勿作任何修改↓↓↓↓↓\t//↑↑↑↑↑↑↑↑↑↑↑自由写代码区域截止线，其它区域请勿作任何修改↑↑↑↑↑\t&#125;\tvirtual ~CMyView()&#123;&#125;\tpublic:\tvirtual void OnDraw(CDC* pDC)&#123;&#125; \tprotected:                                                          \tafx_msg void On01();                                            &#125;;                                                                  IMPLEMENT_DYNCREATE(CMyView, CView)                       BEGIN_MESSAGE_MAP(CMyView, CView)                                                     \tON_COMMAND(ID01, On01)                                           END_MESSAGE_MAP()                                                                                                                        /*应用程序类*/                                                      class CApp : public CWinApp&#123;\tvirtual BOOL InitInstance(); &#125;;BOOL CApp::InitInstance ()                             &#123;\t\tCSingleDocTemplate* pDocTemplate= new CSingleDocTemplate(IDR_MENU1,RUNTIME_CLASS(CDoc),\t\t\t\t\t\t\t\t\t\t\t\t\tRUNTIME_CLASS(CMainFrame),RUNTIME_CLASS(CMyView));\t\tAddDocTemplate(pDocTemplate);CCommandLineInfo cmdInfo;ParseCommandLine(cmdInfo);\t\tif (!ProcessShellCommand(cmdInfo))\treturn FALSE;            \t\tm_pMainWnd-&gt;ShowWindow(SW_SHOW);m_pMainWnd-&gt;UpdateWindow();  \t\tm_pMainWnd-&gt;SetWindowPos(NULL,0,0,800,600,0);                \t\tm_pMainWnd-&gt;SetWindowText(&quot;版本1.01.&quot;);\t\treturn TRUE;                                                 &#125;                                                                    CApp theApp;                                             //区域三：↓↓↓↓↓↓↓以下区域可自由写代码，其它区域请勿作任何修改↓↓↓↓↓void CMyView::On01() &#123;\tCBitmap hbitmap;         //利用&quot;位图类&quot;声明一个标识符为&quot;hbitmap&quot;的变量\tBITMAP bm;               //利用&quot;位图文件头结构体&quot;声明一个标识符为&quot;bm&quot;的变量    unsigned char *buffer;            //声明了一个8位整型数&quot;buffer&quot;指针\tint Hang,Lie,WidthBytes;       //声明行总数目，列总数目，单个象素占据的字节个数\thbitmap.DeleteObject();                                  //位图类的清空位图函数\thbitmap.LoadBitmap (IDB_BITMAP2);                        //加载位图文件\thbitmap.GetBitmap (&amp;bm);     //将所加载的位图文件的头文件信息装载到标识符为&quot;bm&quot;的变量中\tHang=bm.bmHeight,Lie=bm.bmWidth,WidthBytes=bm.bmWidthBytes;\tbuffer= new unsigned char[Hang*WidthBytes];    \t//新开辟一段由上述三个变量决定个数的8位整形数组然后被buffer指针所指向\thbitmap.GetBitmapBits (Hang*WidthBytes, buffer);   //录入buffer数组的位图数据    //buffer[j*WidthBytes+i*4+k];\tint i,j;\tint tempR,tempG,tempB;    CDC *pDC;\tpDC=GetDC();    for(j=0;j&lt;Hang;j++)\t&#123;\t\tfor(i=0;i&lt;Lie;i++)\t\t&#123;\t\t\ttempR=buffer[j*WidthBytes+i*WidthBytes/Lie+2];\t\t\ttempG=buffer[j*WidthBytes+i*WidthBytes/Lie+1];\t\t\ttempB=buffer[j*WidthBytes+i*WidthBytes/Lie+0];    \t    pDC-&gt;SetPixel(i,j,RGB(tempR,tempG,tempB));\t\t&#125;\t&#125;\tMessageBox(&quot;以下将RGB图转灰度图&quot;);\tint temp;    unsigned char *buffer2,*buffer3;            //声明了一个8位整型数&quot;buffer&quot;指针\tbuffer2= new unsigned char[Hang*Lie];\t   //存储灰度图字节数据\tbuffer3= new unsigned char[Hang*Lie];\t   //存储线性点运算处理后的灰度级数据    for(j=0;j&lt;Hang;j++)\t&#123;\t\tfor(i=0;i&lt;Lie;i++)\t\t&#123;\t\t\ttempR=buffer[j*WidthBytes+i*WidthBytes/Lie+2];\t\t\ttempG=buffer[j*WidthBytes+i*WidthBytes/Lie+1];\t\t\ttempB=buffer[j*WidthBytes+i*WidthBytes/Lie+0];\t\t\ttemp=(tempR+tempG+tempB)/3;    \t    pDC-&gt;SetPixel(i,j,RGB(temp,temp,temp));\t\t\tbuffer2[j*Lie+i]=temp;\t\t&#125;\t&#125;        //结束以上流程后，我们最终得到了存储灰度图数据的buffer2\tMessageBox(&quot;以下灰度图的点运算输出&quot;);\t    //以下为线性点运算    float a=1.5,b=0;\t//解释一下这个点运算的作用，b=0对整体的图像没有任何影响    \t\t\t\t   //a&gt;1，即整体图像的对比度增加，亮的地方越亮，暗的地方越暗\tint DA,DB;\t\t   //DA临时存储的是灰度值，DB存储的是计算之后的结果    for(j=0;j&lt;Hang;j++)\t&#123;\t\tfor(i=0;i&lt;Lie;i++)\t\t&#123;\t\t\tDA=buffer2[j*Lie+i];\t//将循环到的像素的灰度值存入DA\t\t\tDB=a*DA+b;\t\t\t   //进行简单的计算工作，对读取到的灰度值进行点运算\t\t\tif(DB&gt;255) DB=255;\t    //一般是不可能大于255的，因为这个灰度值是从前面的RGB图像求平均转化而来的，            \t\t\t\t\t   //不过为了程序的严谨还是设定将超过255的灰度值设定为255\t\t\tif(DB&lt;0) DB=0;\t\t   //同上面所述也是为了严谨，将小于0的灰度值转化为\t\t\tbuffer3[j*Lie+i]=DB;    //存储处理后的灰度级\t\t\t\t\t\ttemp=buffer3[j*Lie+i];\t//这一步太太冗余了，没必要，使用DB直接代替temp它不香吗            \t\t\t\t\t   //上面的判断失误了：            \t\t\t\t\t\t\t//失误在于没有理解buffer是unsigned char类型            \t\t\t\t\t\t\t//SetPixel是要求输入的RGB数据为整数型\t\t\tpDC-&gt;SetPixel(i,j,RGB(temp,temp,temp));\t//将数据加载到位图\t\t&#125;\t&#125;/*\t //以下为非线性点运算----轮廓线\tint DA,DB;    for(j=0;j&lt;Hang;j++)\t&#123;\t\tfor(i=0;i&lt;Lie;i++)\t\t&#123;\t\t\tDA=buffer2[j*Lie+i];\t\t\t\t\t\tif(DA&lt;128)  DB=0;\t\t\tif(DA&gt;=128&amp;&amp;DA&lt;=128+5) DB=255;\t\t\tif(DA&gt;128+5) DB=0;\t\t\tif(DB&gt;255) DB=255;\t\t\tif(DB&lt;0) DB=0;\t\t\tbuffer3[j*Lie+i]=DB;\t\t\t\t\t\ttemp=buffer3[j*Lie+i];\t\t\tpDC-&gt;SetPixel(i,j,RGB(temp,temp,temp));\t\t&#125;\t&#125;*/&#125;\n04 代数运算–加法（生成叠加图像）\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include &lt;afxwin.h&gt; #include &lt;afxext.h&gt; #include &lt;afxdisp.h&gt;   #include &lt;afxdtctl.h&gt;#include &quot;resource.h&quot;/*文档类*/class CDoc: public CDocument&#123;\t\tDECLARE_DYNCREATE(CDoc)&#125;;IMPLEMENT_DYNCREATE(CDoc, CDocument)/*主帧窗口类*/class CMainFrame : public CFrameWnd&#123;\t\tDECLARE_DYNCREATE(CMainFrame)&#125;;IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)/*视图类*/class CMyView : public CView&#123;public:\t//区域一：↓↓↓↓↓↓↓以下区域可自由写代码，其它区域请勿作任何修改↓↓↓↓↓\t//↑↑↑↑↑↑↑↑↑↑↑自由写代码区域截止线，其它区域请勿作任何修改↑↑↑↑↑\tDECLARE_MESSAGE_MAP()\tDECLARE_DYNCREATE(CMyView)public:\tCMyView()\t&#123;\t//区域二：↓↓↓↓↓↓↓以下区域可自由写代码，其它区域请勿作任何修改↓↓↓↓↓\t//↑↑↑↑↑↑↑↑↑↑↑自由写代码区域截止线，其它区域请勿作任何修改↑↑↑↑↑\t&#125;\tvirtual ~CMyView()&#123;&#125;\tpublic:\tvirtual void OnDraw(CDC* pDC)&#123;&#125; \tprotected:                                                          \tafx_msg void On01();                                            &#125;;                                                                  IMPLEMENT_DYNCREATE(CMyView, CView)                       BEGIN_MESSAGE_MAP(CMyView, CView)                                                    \tON_COMMAND(ID01, On01)                                           END_MESSAGE_MAP()                                                                                                                        /*应用程序类*/                                                      class CApp : public CWinApp&#123;\tvirtual BOOL InitInstance(); &#125;;BOOL CApp::InitInstance ()                             &#123;\t\tCSingleDocTemplate* pDocTemplate= new CSingleDocTemplate(IDR_MENU1,RUNTIME_CLASS(CDoc),\t\t\t\t\t\t\t\t\t\t\t\t\tRUNTIME_CLASS(CMainFrame),RUNTIME_CLASS(CMyView));\t\tAddDocTemplate(pDocTemplate);CCommandLineInfo cmdInfo;ParseCommandLine(cmdInfo);\t\tif (!ProcessShellCommand(cmdInfo))\treturn FALSE;            \t\tm_pMainWnd-&gt;ShowWindow(SW_SHOW);m_pMainWnd-&gt;UpdateWindow();  \t\tm_pMainWnd-&gt;SetWindowPos(NULL,0,0,800,600,0);                \t\tm_pMainWnd-&gt;SetWindowText(&quot;版本1.01.&quot;);\t\treturn TRUE;                                                 &#125;                                                                    CApp theApp;             #include &quot;math.h&quot;                                //区域三：↓↓↓↓↓↓↓以下区域可自由写代码，其它区域请勿作任何修改↓↓↓↓↓void CMyView::On01() &#123;\tCBitmap hbitmap;         //利用&quot;位图类&quot;声明一个标识符为&quot;hbitmap&quot;的变量\tBITMAP bm;               //利用&quot;位图文件头结构体&quot;声明一个标识符为&quot;bm&quot;的变量    unsigned char *buffer;            //声明了一个8位整型数&quot;buffer&quot;指针\tint Hang,Lie,WidthBytes;       //声明行总数目，列总数目，单个象素占据的字节个数\thbitmap.DeleteObject();                                  //位图类的清空位图函数\thbitmap.LoadBitmap (IDB_BITMAP2);                        //加载位图文件\thbitmap.GetBitmap (&amp;bm);     //将所加载的位图文件的头文件信息装载到标识符为&quot;bm&quot;的变量中\tHang=bm.bmHeight,Lie=bm.bmWidth,WidthBytes=bm.bmWidthBytes;\tbuffer= new unsigned char[Hang*WidthBytes];    \t//新开辟一段由上述三个变量决定个数的8位整形数组然后被buffer指针所指向\thbitmap.GetBitmapBits (Hang*WidthBytes, buffer);   //录入buffer数组的位图数据\tCBitmap hbitmap2;         //利用&quot;位图类&quot;声明一个标识符为&quot;hbitmap&quot;的变量\tBITMAP bm2;               //利用&quot;位图文件头结构体&quot;声明一个标识符为&quot;bm&quot;的变量    unsigned char *buffer2,*buffer3;            //声明了一个8位整型数&quot;buffer&quot;指针\thbitmap2.DeleteObject();                                  //位图类的清空位图函数\thbitmap2.LoadBitmap (IDB_BITMAP3);                        //加载位图文件\thbitmap2.GetBitmap (&amp;bm2);     //将所加载的位图文件的头文件信息装载到标识符为&quot;bm&quot;的变量中\tbuffer2= new unsigned char[Hang*WidthBytes];    \t//新开辟一段由上述三个变量决定个数的8位整形数组然后被buffer指针所指向\thbitmap2.GetBitmapBits (Hang*WidthBytes, buffer2);   //录入buffer数组的位图数据\tbuffer3= new unsigned char[Hang*WidthBytes];    \tint i,j;\tint tempR,tempG,tempB;\tint tempR1,tempG1,tempB1;\tint tempR2,tempG2,tempB2;\tint tempR3,tempG3,tempB3;    CDC *pDC;\tpDC=GetDC();    for(j=0;j&lt;Hang;j++)\t&#123;\t\tfor(i=0;i&lt;Lie;i++)\t\t&#123;\t\t\ttempR=buffer[j*WidthBytes+i*WidthBytes/Lie+2];\t\t\ttempG=buffer[j*WidthBytes+i*WidthBytes/Lie+1];\t\t\ttempB=buffer[j*WidthBytes+i*WidthBytes/Lie+0];    \t    pDC-&gt;SetPixel(i,j,RGB(tempR,tempG,tempB));\t\t&#125;\t&#125;    for(j=0;j&lt;Hang;j++)\t&#123;\t\tfor(i=0;i&lt;Lie;i++)\t\t&#123;\t\t\ttempR=buffer2[j*WidthBytes+i*WidthBytes/Lie+2];\t\t\ttempG=buffer2[j*WidthBytes+i*WidthBytes/Lie+1];\t\t\ttempB=buffer2[j*WidthBytes+i*WidthBytes/Lie+0];    \t    pDC-&gt;SetPixel(i,j,RGB(tempR,tempG,tempB));\t\t&#125;\t&#125;\t    //以上代码只是完成了一个功能    /*    \t将图像的RGB数据读出来，按顺序放在两个数组中（buffer和buffer2）    \t其他的就是转化位图操作而已    */\t//以下进行代数运算--加法(生成叠加图像)\tMessageBox(&quot;以下进行代数运算--加法(生成叠加图像)&quot;);\t    for(j=0;j&lt;Hang;j++)\t&#123;\t\tfor(i=0;i&lt;Lie;i++)\t\t&#123;\t            /**            *\t以下代码只是分别将两个数据数组的对应相同位置的像素读取出来，然后求平均            *\t最后再将数据按顺序存储到buffer3指定的数组中            */            \t\t\ttempR1=buffer[j*WidthBytes+i*WidthBytes/Lie+2];\t\t\ttempG1=buffer[j*WidthBytes+i*WidthBytes/Lie+1];\t\t\ttempB1=buffer[j*WidthBytes+i*WidthBytes/Lie+0];\t\t\ttempR2=buffer2[j*WidthBytes+i*WidthBytes/Lie+2];\t\t\ttempG2=buffer2[j*WidthBytes+i*WidthBytes/Lie+1];\t\t\ttempB2=buffer2[j*WidthBytes+i*WidthBytes/Lie+0];\t\t\ttempR3=(tempR1+tempR2)/2;\t\t\ttempG3=(tempG1+tempG2)/2;\t\t\ttempB3=(tempB1+tempB2)/2;\t\t\tbuffer3[j*WidthBytes+i*WidthBytes/Lie+2]=tempR3;\t\t\tbuffer3[j*WidthBytes+i*WidthBytes/Lie+1]=tempG3;\t\t\tbuffer3[j*WidthBytes+i*WidthBytes/Lie+0]=tempB3;\t\t\tpDC-&gt;SetPixel(i,j,RGB(tempR3,tempG3,tempB3));\t\t&#125;\t&#125;\t//至此，原图的灰度图生成，放在buffer2内存条中   &#125;","publisher":{"@type":"Organization","name":"JNbuck Blog","logo":{"@type":"ImageObject","url":"https://jnbuck.top/css/1.png"}},"author":{"@type":"Person","name":"JNbuck","description":"稳稳的做自己,慢慢的一路走下去便是了","image":"https://jnbuck.top/css/1.png"},"inLanguage":{"@type":"Language","alternateName":"en"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jnbuck.top/2021/06/08/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E6%9C%9F%E6%9C%AB/"}}]</script>
<script async src="//www.googletagmanager.com/gtag/js?id=UA-00000000-0"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)};gtag('js',new Date());gtag('config','UA-00000000-0');</script>
<!-- hexo injector head_end start --><style is="theme">html{--inside-accent-color:#2a2b33;--inside-foreground-color:#363636;--inside-border-color:#e0e0e0;--inside-background:#f3f6f7;--inside-sidebar-background:#2a2b33;--inside-card-background:#fff;--inside-font-base:'Josefin Sans','PingFang SC',Microsoft YaHei;--inside-font-logo:-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;--inside-font-menu:Baloo Bhaijaan,'Josefin Sans','PingFang SC',Microsoft YaHei;--inside-font-heading:-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;--inside-font-label:Montserrat,'Josefin Sans','PingFang SC',Microsoft YaHei;--inside-font-code:Inconsolata,monospace;--inside-font-print:-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;--inside-content-width:820px;--inside-highlight-00:#ffffff;--inside-highlight-01:#e0e0e0;--inside-highlight-02:#d6d6d6;--inside-highlight-03:#8e908c;--inside-highlight-04:#969896;--inside-highlight-05:#4d4d4c;--inside-highlight-06:#282a2e;--inside-highlight-07:#1d1f21;--inside-highlight-08:#c82829;--inside-highlight-09:#f5871f;--inside-highlight-0a:#eab700;--inside-highlight-0b:#718c00;--inside-highlight-0c:#3e999f;--inside-highlight-0d:#4271ae;--inside-highlight-0e:#8959a8;--inside-highlight-0f:#a3685a;--inside-card-color:#fff;--inside-accent-color-005:rgba(42,43,51,.05);--inside-accent-color-01:rgba(42,43,51,.1);--inside-accent-color-02:rgba(42,43,51,.2);--inside-accent-color-04:rgba(42,43,51,.4);--inside-accent-color-08:rgba(42,43,51,.8)}</style><link href="//fonts.googleapis.com/css?family=Baloo+Bhaijaan|Inconsolata|Josefin+Sans|Montserrat" rel="stylesheet"></link><link href="/styles.0d44a7054d712e5df0b5.css" rel="stylesheet"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head>
<body lang="en"><!-- hexo injector body_begin start --><is-a></is-a><!-- hexo injector body_begin end --><!-- hexo injector body_end start --><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script src="/runtime.91a02d1be9f8a4fe75ea.js"></script><script src="/polyfills.9aa2dadd7ec0b15063ad.js"></script><script src="/main.eb06322b117f59a88792.js"></script><!-- hexo injector body_end end --></body>
</html>

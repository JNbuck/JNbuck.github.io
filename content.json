{"meta":{"title":"JNbuck Blog","subtitle":"记录成长的路","description":"一个自学Javaweb的光学工程boy的记录网站","author":"JNbuck","url":"https://47.115.211.244/blog","root":"/blog/"},"pages":[{"title":"about","date":"2021-06-09T00:39:31.000Z","updated":"2021-06-09T09:42:03.496Z","comments":true,"path":"about/index.html","link":"about","permalink":"https://47.115.211.244/blog/about/index.html","excerpt":"","text":"Hello! 这里是作者的自我介绍 我是一名准备转行javaweb半程序员，由于身体不能熬夜从此把javaweb当成是自己的爱好， 作为爱好之后，学习也便不再枯燥。 能在此处遇到你，我很荣幸！"},{"title":"future","date":"2021-06-13T23:41:04.000Z","updated":"2021-06-14T07:42:07.063Z","comments":true,"path":"future/index.html","link":"future","permalink":"https://47.115.211.244/blog/future/index.html","excerpt":"","text":"编写搭建hexo博客到阿里云的教程 结合nginx一起解释"}],"posts":[{"title":"马克思主义基本原理概论","slug":"马克思主义基本原理概论","date":"2021-06-16T23:55:43.000Z","updated":"2021-06-19T16:02:58.706Z","comments":true,"path":"2021/06/16/马克思主义基本原理概论/","link":"2021/06/16/马克思主义基本原理概论","permalink":"https://47.115.211.244/blog/2021/06/16/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%A6%82%E8%AE%BA/","excerpt":"卷面分占60％ 题型分布： 单选题：20×1分=20分 多选题：15×2分=30分 简答题：3×10分=30分 九道简答题范围：（A卷×3，B卷×3） 论述题（课外）：开放性题目，要求书写端正，20分 以下没有标记论述题的都是选择题 导论 1、马克思主义的创立背景： 理论来源：德国的古典哲学，英国的古典政治经济学，英法两国的空想社会主义 工业革命和科技进步 自然科学前提（三大科学发现）：细胞学说，能量守恒与转换定律，生物进化论 还有古希腊罗马哲学，文艺复兴运动的思想成果，法国复辟时期历史学家的进步思想等。","text":"卷面分占60％ 题型分布： 单选题：20×1分=20分 多选题：15×2分=30分 简答题：3×10分=30分 九道简答题范围：（A卷×3，B卷×3） 论述题（课外）：开放性题目，要求书写端正，20分 以下没有标记论述题的都是选择题 导论 1、马克思主义的创立背景： 理论来源：德国的古典哲学，英国的古典政治经济学，英法两国的空想社会主义 工业革命和科技进步 自然科学前提（三大科学发现）：细胞学说，能量守恒与转换定律，生物进化论 还有古希腊罗马哲学，文艺复兴运动的思想成果，法国复辟时期历史学家的进步思想等。 2、马克思主义的三大部分 哲学 政治经济学 科学社会主义 3、马克思主义的鲜明特征：（P10-13）各个要点的解释，能理解即可 鲜明的科学性 革命性 实践性 人民性 发展性 第一章：世界的物质性及发展规律 1、第一节：世界多样性与物质统一性 近代以来哲学的基本问题： (1) 其一，存在和思维究竟谁是世界的本原，即物质和精神何者是第一性、何者是第二性的问题，对这一问题的不同回答，构成了划分唯物主义和唯心主义的标准。 (2) 其二，存在和思维有没有同一性，即思维是否正确认识存在的问题。对这一问题的不同回答，构成了划分可知论和不可知论的标准。 物质的定义： 万事万物的共同特征——客观实在性。所谓物质，就是不依赖于人类的意识而存在，并能为人类的意识所反映的客观存在；所谓物质范畴，就是标志客观实在的哲学范畴。 物质是怎么样的？ (1) 物质的唯一特性：客观实在性。 (2) 物质的根本属性：运动。 (3) 物质世界的运动是绝对的，而物质在运动过程中又有某种相对的静止。无条件的绝对运动和有条件的相对静止构成了对立统一的关系。 (4) 时间和空间是物质运动的存在形式。 什么是意识？意识从何而来？ 定义：意识是人脑的机能和属性，是客观世界的主观映象。 (1) 意识是自然界长期发展的产物。 (2) 意识不仅是自然界长期发展的产物，而且是社会历史发展的产物。 意识的本质： 从意识的本质来看，意识是人脑这样一种特殊物质的技能和属性，是客观世界的主观映像。因此，意识在内容上是客观的，在形式上是主观的，是客观内容和主观形式的统一，意识是物质的产物，但又不是物质本身。 意识的特点： 意识的能动作用主要表现在： (1) 第一，意识活动具有目的性和计划性 (2) 第二，意识活动具有创造性 (3) 第三，意识具有指导实践改造客观世界的作用 (4) 第四，意识具有调控人的行为和生理活动的作用 为什么说世界具有物质统一性：【论述题】 世界的物质统一性问题，是回答世界上的万事万物有没有统一性，即有没有共同的本质或本原的问题。 (1) 世界的物质统一性首先体现在，意识统一于物质。 ①从意识的起源上看，意识是物质世界长期发展的产物，是物质世界中的一种特殊存在。 ②从意识的本质上看，意识是人脑这种特殊的物质器官的机能，是客观存在的主观映像； ③从意识的作用上看，意识能动性的发挥必须以尊重物质世界的客观规律为前提 (2) 世界的物质统一性还体现在，人类社会也统一于物质 ①第一，人类社会是物质世界的组成部分 ②第二，人类获取生活资料的活动是物质性的活动 ③第三，人类社会存在和发展的基础是物质资料的生产方式 第二节 事物的联系和发展 联系是什么？ 联系是指事物内部各元素之间和事物之间相互影响、 相互制约、相互作用的关系。 联系有什么样的特点： ①客观性：事务的联系是事物本身所固有的 ②普遍性：任何事物都具有内在的结构性；任何事物都不能孤立存在；整个世界是互相联系的统一整体 ③多样性：事物之间的联系是多样的 ④条件性：条件对事物发展和人的活动具有支持或制约作用；条件是可以改变的；改变和创造条件不是任意的，必须尊重事物发展的客观规律 发展是什么？ 发展：发展是前进的、上升的运动，发展的实质是新事物的产生和旧事物的灭亡。事物的发展是一个曲折向上过程，只有经过一定的过程，事物才能实现自身的发展。 为什么新事物是不可战胜的： 第一，就新事物与环境的关系而言，新事物之所以新，是因为有新的要素、结构和功能，它适应已经变化了的环境和条件；旧事物之所以旧，是因为它的各种要素和功能已经不适应环境和客观条件的变化，走向灭亡就成为不可避免的。 第二，就新事物与旧事物的关系而言，新事物是在旧事物的“母体”中孕育成熟的，它级否定了旧事物中消极腐朽的东西，又保留了旧事物中合理的、适应新条件的因素，并添加了旧事物所不能容纳的新内容。这也正是新事物在本质上优越于旧事物、具有强大生命力的所在。 矛盾是什么？ 矛盾：矛盾是反映事物内部和事物之间对立统一关系的哲学范畴。对立和统一分别体现了矛盾的两种基本属性：对立属性——斗争性，统一属性——同一性。 主要矛盾和次要矛盾分别是什么？ 主要矛盾：主要矛盾是矛盾体系中处于支配地位、对事物发展起决定作用的矛盾。 次要矛盾：次要矛盾是矛盾体系中处于从属地位、对事物发展起次要作用的矛盾。 如何一分为二的看问题： 坚持“两点论”和“重点论”的统一： “两点论”：是指在分析事物的矛盾时，不仅要看到矛盾双方的对立，而且要看到矛盾双方的统一；不仅要看到矛盾体系中存在着的主要矛盾、矛盾的主要方面，而且要看到次要矛盾、矛盾的次要方面 “重点论”是指要着重把我主要矛盾、矛盾的主要方面，并以此作为解决问题的出发点。 否定之否定规律： 三个环节：事物的辩证发展过程经过肯定-否定-否定之否定三个阶段 两个否定：第一次否定使矛盾得到初步解决，而处于否定阶段的事物仍然具有片面性，还要经过再次否定，即否定之否定，实现对立面的统一，使矛盾得到根本解决。 事物的辩证发展就是经过两次否定、三个阶段，形成一个周期。 第二章 实践与认识及其发展规律 第一节：实践和认识 实践和认识的关系：【论述题】 1、实践在认识活动中具有决定作用 辩证唯物主义认为，在实践和认识之间，实践是认识的基础，实践在认识活动中起着决定性的作用。 （1）实践是认识的来源。认识的内容是在实践活动的基础上产生和发展的。人们只有通过实践实际地改造和变革对象，才能准确把握对象的属性、本质和规律，形成正确的认识，并以这种认识指导人的实践活动。 （2）实践是认识发展的动力。实践的需要推动认识的产生和发展，推动人类的科学发现和技术发明，推动人类的思想进步和理论创新。 （3）实践是认识的目的。人们通过实践而获得认识，其最终目的是为实践服务，指导实践，以满足人们生活和生产的需要。 （4）实践是检验真理性的唯一标准。认识是否具有真理性，既不能从认识本身得到证实，也不能从认识对象中得到回答，只有在实践中才能得到验证。 2、认识的本质是主体在实践基础上对客体的能动反映 这种能动反映不但具有反映客体内容的反映性特征，而且具有实践所要求的主体能动的、创造性的特征。 （1）从实践到认识 认识的过程首先是从实践到认识的过程。这个过程主要表现为在实践基础上认识活动由感性认识能动地飞跃到理性认识。 （2）从认识到实践 ①认识世界的目的是为了改造世界。理性认识回到实践的过程，既是理论指导实践的过程，又是理论实现自身的过程。 ②认识的真理性只有在实践中才能得到检验和发展。只有将已经获得的的理论运用到实践中去，通过实践的检验，正确的理论才得到证实，错误的理论才能被发现，并在指导实践、实现自身的过程中得到完善和发展。 总结： 人的认识过程是一个在实践基础上不断深化的发展过程，及表现为在实践基础上由感性认识到理性认识，再有理性认识到实践的具体认识过程；又表现为从实践到认识，再从认识到实践的循环往复和无限发展的总过程。 第一次飞跃和第二次飞跃： 第一次飞跃： 这个过程主要表现为在实践基础上认识活动有感性认识能动地飞跃到理性认识，也就是“从生动的直观到抽象的思维”，这是认识运动的第一次飞跃。 第二次飞跃： 从认识到实践，是“认识过程的第二个阶段，即由精神到物质的阶段，由思想到存在的阶段”。这是认识过程的第二次能动的飞跃。 感性认识和理性认识的定义： 感性认识：感性认识是人们在实践的基础上，由感觉器官直接感受到的关于事物的现象，事物的外部联系、事物的各个方面的认识。它包括感觉、知觉和表象三种形式。 理性认识：理性认识是指人们借助抽象思维，在概括整理大量感性材料的基础上，达到关于事物本质、全体、内部联系和事物本身规律性的认识。理性认识包括概念、判断、推理三种形式。 感性认识和理性认识的辩证统一关系是在实践的基础上形成的，也需要在实践中发展。 第二节：真理和价值 真理的三个特点： ①客观性：真理的内容是对客观事物及其规律的正确反映，真理中包含着不依赖于人和人的意识的客观内容。某一认识成为真理的决定性条件，在于它能正确的反映对象的本质和规律。 ②绝对性：真理主客观统一的确定性和发展的无限性。 指任何真理都标志着主观与客观之间的符合，都包含着不依赖于人和人的意识的客观内容；人类认识按其本性来说，认识每前进一步，都是对无限发展着的物质世界的接近 ③相对性：人们在一定条件下对客观事物及其本质和发展规律的正确认识总是有限度的、不完善的 价值的定义和特性： 价值的定义：价值是指在实践基础上形成的主体和客体之间的意义关系，是客体对个人、群体乃至整个社会的生活和活动所具有的积极意义。 价值的三个特点： ①主体性：价值直接同主题相联系，始终以主体为中心 价值关系的形成依赖于主体的存在；价值关系的形成依赖于主体的创造，使客体潜在的价值转化为现实的存在 ②客观性：一定条件下客体对于主体的意义不依赖于主体的主观意识而存在 ③多维性：每个主体的价值关系具有多样性，同一客体相对于主体的不同需要会产生不同的价值 ④社会历史性：主体和客体的不断变化决定了价值的社会历史性特点 第三章：人类社会及其发展规律 第一节：社会基础矛盾及其运动规律 社会存在的三大因素： 社会存在也称社会物质生活条件、是社会生活的物质方面，主要包括 自然地理环境 人口因素 物质生产方式。 生产方式是社会历史发展的决定力量的原因： 物质生产活动及生产方式是人类社会赖以生存和发展的基础，是人类其他一切活动的首要前提。 物质生产活动及生产方式决定着社会的结构、性质和面貌 最后，物质生产活动及生产方式的变化发展决定整个社会历史的变化发展，决定社会形态从低级向高级的更替和发展 社会意识是什么？ 社会意识是社会生活的精神方面，是社会存在的反映。 根据不同的主体，社会意识分为主体意识和群体意识。 根据不同的层次，社会意识分为社会心理和社会意识形式。社会心理是低层次的社会意识。社会意识形式是高层次的社会意识。社会意识形式以社会心理为基础，并对社会心理起指导和影响作用。 在社会意识形式中，又存在意识形态和非意识形态之分。 社会存在和社会意识的辩证关系：【论述题】 1、社会存在决定社会意识 （1）社会意识根源于社会存在，是对以实践为基础的不断变化发展的现实世界的反映 社会存在是社会意识内容的客观来源，社会意识是社会物质生活过程及其条件的主观反映。 （2）社会意识是人们进行社会物质交往的产物 社会意识同语言一样，是在生产中由于交往活动的需要而产生的。不是意识决定生活，而是生活决定意识。 （3）随着社会存在的发展，社会意识也相应或早或晚地发生变化和发展 社会意识是具体的、历史的。每一时代的社会意识都有其独特的内容和特点，具有不断进步的历史趋势，但不管怎样变化、发展，其根源总是深深地埋藏于经济的事实之中。 2、社会意识是社会存在的反映，并反作用于社会存在 （1）社会意识对社会存在具有依赖性，但社会意识并非消极被动的受制于社会存在，它有其相对独立性。 社会意识具有相对独立性，是指社会意识在从根本上受到社会存在决定的同时，还具有自己特有的发展形式和规律 （2）社会意识与社会存在发展的不完全同步性和不平衡性 （3）社会意识内部各种形式之间的互相影响及各自具有的历史继承性 社会生活的内在联系及其统一性，决定了社会意识诸形式之间也必然是相互影响、相互作用的。 （4）社会意识对社会存在能动的反作用 任何社会意识都不会凭空出现，只能是适应一定社会物质生活发展的要求而产生的，因而它必然具有满足这些需求的功能和价值，在一定条件下会转化为物质力量并作用于社会存在，影响历史的发展。 生产力和生产关系的定义： 生产力的定义： 生产力是人类在生产实践中形成的改造和影响自然以使其适合社会需要的物质力量 生产关系的定义： 生产关系是人们在物质生产过程中形成的不以人的意志为转移的经济关系 生产力和生产关系的相互关系： 生产力决定生产关系。在两者的关系中，生产力是居支配地位、起决定作用的方面。 1.生产力状况决定生产关系的性质 历史上的各种生产关系都是适应一定的生产力发展需要而产生的。有什么样的生产力，就会产生什么样的生产关系。 2.生产力的发展决定生产关系的变化。 生产关系是生产力发展需要的产物，只有当它为生产力提供足够的发展空间时才能够存在。 生产关系对生产力具有能动的反作用 主要表现为两种情形：当生产关系适合生产力发展的客观要求时，对生产力的发展起推动作用；当生产关系不适合生产力发展的客观要求时，就会阻碍生产力的发展。 经济基础与上层建筑的定义： 经济基础：经济基础是指由社会一定发展阶段的生产力所决定的生产关系的总和。 上层建筑：上层建筑是建立在一定经济基础之上的意识形态以及与之相应的制度、组织和设施。 经济基础和上层建筑之间的关系： 首先，经济基础决定上层建筑 其次，上层建筑对经济基础具有反作用 再次，经济基础与上层建筑的相互作用构成二者的矛盾运动 最后，经济基础和上层建筑之间的内在联系构成了上层建筑一定适合经济基础状况的规律 第二节：社会历史发展的动力 基本矛盾的定义： 社会基本矛盾就是指贯穿社会发展过程始终，规定社会发展过程的基本性质和基本趋势，并对社会历史发展起根本推动作用的矛盾。 社会基本矛盾的定义： 生产力和生产关系、经济基础和上层建筑的矛盾时社会基本矛盾 为什么说社会的基本矛盾在历史发展中起到如此重要的作用？ 生产力和生产关系、经济基础和上层建筑的矛盾时社会基本矛盾 这两对矛盾贯穿于人类社会发展过程的始终，并规定了社会发展过程中的各种社会形态，社会制度的基本性质； 这两对矛盾制约着社会其他矛盾的存在和发展，决定社会历史的一般进程，推动社会向前发展 这两队矛盾规定并反映了社会的基本结构（经济结构，政治结构，观念结构）和基本面貌 阶级斗争和社会革命之间有什么差别（简单看）： 阶级斗争：阶级斗争时社会基本矛盾在阶级社会中的表现，是阶级社会发展的直接动力 社会革命：社会革命是阶级斗争发展到一定阶段的产物，是推动社会发展的重要动力。 阶级和阶级斗争是人类社会发展到一定阶段才出现的社会现象 阶级斗争是阶级社会发展的直接动力 科技革命在社会发展中的作用：【论述题】 科技革命是推动经济和社会发展的强大杠杆 科学技术是社会发展的重要动力。科学是历史的有力的杠杆，是最高意义上的革命力量，每一次科技革命都引起了社会的深刻变化和巨大进步。 1、对生产方式产生了深刻影响 （1）改变了社会生产力的构成要素 科技发展使生产自动化程度提高，大大的改变了脑力劳动与体力劳动的比例，使劳动力结构向着智能化趋势发展。 （2）改变了人们的劳动形式 微电子技术的出现和广泛应用，使智能机器代替了人的部分脑力劳动，使人们的劳动方式经历了由机械自动化走向智能自动化、由局部自动化走向大系统管理和控制自动化的根本性变革。 （3）改变了社会经济结构，特别是产业结构 科技革命推动了生产规模的扩大，进而推动了生产的分工和协作的广泛发展，并使生产社会化的程度进一步提高，最终必然导致生产关系的变革。 2、对生活方式产生了巨大影响 现代科技革命把人们带入了信息时代，要求人们不断更新和充实知识，以适应时代发展的需要，学习已日益成为生活中的一项重要内容。 3、促进了思维方式的变革 现代科技革命对人的思维方式产生了重要影响，主要表现为新的科学理论和技术手段通过影响思维主体、思维客体的思维工具，引起了思维方式的变革。 第四章：资本主义的本质及规律 第一节：商品经济和价值规律 商品经济的定义： （1）能满足人的某种需要，具有使用价值和价值 （2）用于交换的劳动产品 价值： 价值的二重属性：交换价值和实用价值 决定商品价值量的只能是社会必要劳动时间 抽象劳动和具体劳动的定义 具体劳动是指生产一定实用价值的具体形式的劳动。 抽象劳动是指撇开一切具体形式的、无差别的一般人类劳动，即人的脑力和体力的耗费。 生产商品的具体劳动创造商品的使用价值，抽象劳动形成商品的价值。具体劳动和抽象劳动是同一劳动的两种规定。 二者也是对立统一的关系： ①二者不是各自独立存在的两种劳动或两次劳动，它们在时间和空间上是统一的，是商品生产者的同一劳动过程不可分割的两方面 ②而这又分别反映劳动的不同属性，具体劳动反映的是人与自然的关系，是劳动的自然属性；而抽象劳动所反映的是商品生产者的社会关系，是劳动的社会属性 价值规律及其作用：【论述题】 1、价值规律： 价值规律是商品生产和商品交换的基本规律。这一规律的主要内容和客观要求是：商品的价值量由生产商品的社会必要劳动时间决定，商品交换以价值量为基础，按照等价交换的原则进行。在商品经济中，价值规律的表现形式是，商品的价格围绕商品的价值自发波动。由于供求关系变动的影响，商品价格时而低于价值，时而高于价值，不停地围绕价值这个中心上下波动。 2、价值规律的作用： （1）自发地调节生产资料和劳动力在社会各生产部门之间的分配比例 不论社会制度如何，为了进行生产和再生产，生产资料和劳动力在各个生产部门之间的分配都应该遵循一定的比例，否则就会造成部门发展不均衡，浪费社会资源，不能满足社会生产和消费的需求。 （2）自发地刺激社会生产力的发展 在商品经济条件下，商品是按照由社会必要劳动时间所决定的社会价值进行交换的。商品生产者为了获得较多的利益，并在竞争中获胜，必然要不断改进技术，提高劳动生产率，从而推动社会生产力的发展。 （3）自发地调节社会收入的分配 在实际生产活动中，生产同种商品的各个生产者，由于生产条件和技术水平不同，生产中实际耗费的劳动时间也不一样，所获得的社会收入也不一样 （4）可能导致社会资源的浪费 （5）一定程度上阻碍技术的进步 （6）导致收入两极分化 第二节：资本主义经济制度的本质 剩余价值是什么？ 剩余价值是在资本主义的生产过程中生产出来的。 雇佣工人的劳动分为两部分：一部分是必要劳动，用于再生产劳动力的价值；另一部分是剩余劳动，用于无偿地为资本家生产剩余价值。因此，剩余价值是雇佣工人所创造的并被资本家无偿占有的超过劳动力价值的那部分价值。他是雇佣工人剩余劳动的凝结，体现了资本家与雇佣工人之间剥削与被剥削的关系。剩余价值既不是由全部资本创造的，也不是由不变资本创造的，而是由可变资本雇佣的劳动者创造的。雇佣劳动者的剩余劳动是剩余价值的唯一源泉。 剩余价值生产的两种基本方法： （1）绝对剩余价值的生产。绝对剩余价值是指在必要劳动时间不变的条件下，由于延长工作日的长度和提高劳动强度而生产的剩余价值。 （2）相对剩余价值的生产。相对剩余价值是指在工作日长度不变的条件下，通过缩短必要劳动时间而相对延长剩余劳动时间所生产的剩余价值。 第五章：资本主义的发展及其趋势 第二节：正确认识当代资本主义的新变化 第二次世界大战后资本主义变化的新特点：【论述题】 1、生产资料所有制的变化 国家资本所有制形成并发挥重要作用，法人资本所有制崛起并成为居主导地位的资本所有制形式。 国家资本所有制指生产资料由国家占有并服务于垄断资本的所有制形式。法人资本所有制是资本主义生产资料所有制发展的新形式，是法人股东化的产物。 2、劳资关系和分配关系的变化 劳资关系：由一开始的劳动只是形式上隶属于资本，发展到成为实质上的隶属。 分配关系：建立并实施了普及化、全民化的社会福利制度，在一定程度上满足劳动者的安全和保障需求，保证他们维持最低生活水平，改善其生活状况，劳动者工资水平也有所提高。 3、社会阶层和阶级结构的变化 （1）资本家的地位和作用已发生很大变化 （2）高级职业经理成为大公司经营活动的实际控制者 （3）知识型和服务型劳动者的数量不断增加，劳动方式发生了新变化 4、经济调节机制和经济危机形态的变化 国家开始对经济进行全面干预，承担起了实现经济增长和充分就业、保持经济稳定、提高社会福利水平以及维持市场秩序等重要职能。它与市场机制相辅相成，共同推动资本主义经济的运行和发展。 5、政治制度的变化 出现多元化的趋势，公民权力有所扩大，重视并加强法制建设，改良主义政党在政治舞台上的影响日益扩大。 第六章：社会主义的发展及其规律 第一节：社会主义五百年的历史进程 空想社会主义的三个代表人物及其代表著作： （1）圣西门（法）：提出了“实业制度” （2）傅立叶：提出以“和谐社会”代替资本主义，并在一个农场里进行组建和谐社会基本单位的试验 （3）欧文（英）：建立了“新和谐公社”，实行财产公有，试验最终失败 第一本关于社会主义空想代表著作： 托马斯-莫尔（英）《乌托邦》 第三节：在实践中探索现实社会主义的发展规律 经济文化相对落后国家建设社会主义的长期性：【论述题】 社会主义制度的出现只有一百年的时间，在人类历史的长河中不过是短暂的一瞬间。人类历史上其他社会制度的更替，都经历了曲折漫长的过程。对于经济文化相对落后的国家建设社会主义的长期性，必须有充分的心理准备。 1、生产力发展状况的制约 在一个相当长的历史时期内，社会主义国家在经济上落后于发达资本主义国家，有的甚至落后很远，这决定了赶上和超过发达资本主义国家，无疑需要很长时间的努力，进行艰苦的探索和奋斗。 2、经济基础和上层建筑发展状况的制约 社会主义民主政治建设受到政治、经济、文化条件的严重制约，面临许多现实问题和困难，将是一个长期艰苦的努力奋斗过程。 3、国际环境的严峻挑战 社会主义国家尚处于强大的资本主义世界的包围之中，受到资本主义列强的遏制和扼杀，面临异常严峻的国际环境。 4、马克思主义执政党对社会主义发展道路的探索和对社会主义建设规律的认识，需要一个长期的过程 第七章：共产主义崇高理想及其最终实现 第一节：展望未来共产主义新社会 共产主义社会的基本特征：【论述题】 1、物质财富极大丰富，消费资料按需分配 社会生产力高度发展，产品极大丰富，在集体财富的一切源泉都充分涌流之后，就能实行“各尽所能，按需分配”的分配原则，才能最终实现人类在分配上的真正平等。 2、社会关系高度和谐，人们精神境界极大提高 （1）阶级将会消亡，社会已不再会因为经济利益的不同而划分为不同的社会集团并进行相互间的斗争。 （2）作为政治国家、作为阶级压迫工具的军队、警察、监狱等将失去作用。 （3）战争将不复存在。 （4）“三大差别”必将消失。（工业与农业，城市与农村，脑力劳动与体力劳动的分离） （5）社会与自然之间也将达到和谐。 （6）人们的精神境界得到极大提高，人们不仅具有多方面的才能，而且具有高度的觉悟和高尚的道德品质。 3、实现每个人自由而全面的发展，人类从必然王国走向自由王国飞跃 在共产主义社会，人的发展是全面的发展，不仅体力和智力得到发展，各方面的才能和工作能力得到发展，而且人的社会联系和社会交往也得到发展。实现人的自由而全面的发展，是建立在个体高度自由自觉基础上的全面发展，是马克思主义追求的根本价值目标，也是共产主义社会的根本特征。 第二节：实现共产主义是历史发展的必然趋势 实现共产主义是长期的历史过程：【论述题】 共产主义一定要实现，也一定能够实现，但共产主义的实现是一个十分漫长而且充满艰难曲折的历史过程。每一个社会形态的产生发展，都会经历一个很长的历史时期，而旧的社会形态走向没落并为新的社会形态所代替，也是一个长期的历史过程。 1、资本主义的灭亡和向社会主义的转变是一个长期的过程 资本主义作为一个社会形态，其走向灭亡是一个长期的历史过程。现存的资本主义国家将来不论发达到何种程度，当其实现根本性制度变革的时候，也只能是首先进入共产主义社会的初级阶段，即社会主义社会，而不可能直接达到共产主义社会的高级阶段。 2、社会主义社会的充分发展和最终向共产主义过渡需要很长的历史时期 社会主义是共产主义的低级阶段，也是实现共产主义的必由之路。高级阶段是建立在低级阶段基础上的，没有低级阶段的发展，也不会有高级阶段的到来。为了最终实现共产主义，必须坚定不移地走社会主义道路。","categories":[{"name":"课内","slug":"课内","permalink":"https://47.115.211.244/blog/categories/%E8%AF%BE%E5%86%85/"}],"tags":[{"name":"通识课程","slug":"通识课程","permalink":"https://47.115.211.244/blog/tags/%E9%80%9A%E8%AF%86%E8%AF%BE%E7%A8%8B/"}]},{"title":"JAVA-JUC-JVM","slug":"JAVA-JUC-JVM","date":"2021-06-14T17:35:44.000Z","updated":"2021-06-15T01:42:30.923Z","comments":true,"path":"2021/06/14/JAVA-JUC-JVM/","link":"2021/06/14/JAVA-JUC-JVM","permalink":"https://47.115.211.244/blog/2021/06/14/JAVA-JUC-JVM/","excerpt":"","text":"","categories":[{"name":"java进阶","slug":"java进阶","permalink":"https://47.115.211.244/blog/categories/java%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"java","slug":"java","permalink":"https://47.115.211.244/blog/tags/java/"}]},{"title":"JDBC基础知识","slug":"JDBC基础知识","date":"2021-06-09T02:27:13.000Z","updated":"2021-06-09T10:46:01.913Z","comments":true,"path":"2021/06/08/JDBC基础知识/","link":"2021/06/08/JDBC基础知识","permalink":"https://47.115.211.244/blog/2021/06/08/JDBC%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"JDBC链接数据库，是深入底层进行学习的基础 下面将使用代码从如何构建数据库链接等一个个方面，带大家深入走入JDBC的世界 1. JDBC使用方法六步 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.bjpowernode.jdbc;import java.sql.*;/** * Create By JD * Created by JBuck on 2020/11/24 *//* JDBC编程六步 */public class JDBCTest01 &#123; public static void main(String[] args) &#123; Connection conn = null; Statement stmt = null; try &#123; //1.注册驱动 Driver driver = new com.mysql.jdbc.Driver(); //多态，父类性引用指向子类型对象 DriverManager.registerDriver(driver); // Driver driver = new oracle.jdbc.driver.OracleDriver(); // oracle驱动 //2.获取连接 /* URL：统一资源定位符（网络中某个资源的绝对路径） http://www.baidu.com/ 这就是URL URL包括几部分？ 协议 IP PORT 资源名 http://182.61.200.7:80/index.html http:// 通信协议 182.61.200.7 服务器IP地址 80 服务器上软件的端口号 index.html 是服务器上某个资源名 jdbc:mysql://127.0.0.1:3306/bjpowernode jdbc:mysql:// 协议 127.0.0.1 IP地址 3306 mysql数据库端口号 bjpowernode 具体的数据库实例名 什么是通信协议，有什么用？ 通信协议实在通信之前就提前定好的数据传送格式。 数据包具体怎么传数据，格式提前定好的。 oracle的URL： jdbc:oracle:thin:@localhost:1521:orcl */ String url = &quot;jdbc:mysql://127.0.0.1:3306/bjpowernode&quot;; String user = &quot;root&quot;; String password = &quot;991229&quot;; conn = DriverManager.getConnection(url,user,password); System.out.println(&quot;数据库连接对象 = &quot; + conn); //3.获取数据库操作对象 stmt = conn.createStatement(); //4.执行sql String sql = &quot;insert into dept(deptno,dname,loc) values(50,&#x27;人事部&#x27;,&#x27;北京&#x27;)&quot;; //专门执行DML语句的(insert delete update) //返回值是“影响数据库中的记录条数” int count = stmt.executeUpdate(sql); System.out.println(count == 1 ? &quot;保存成功&quot; : &quot;保存失败&quot;); //5.处理查询结果集 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; //6.释放资源 // 为了保证资源一定释放，在finally语句块中关闭资源 // 并且要遵循从小到大依次关闭 // 分别对其try,catch try&#123; if(stmt != null)&#123; stmt.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try&#123; if(conn != null)&#123; conn.close(); &#125; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125;","text":"JDBC链接数据库，是深入底层进行学习的基础 下面将使用代码从如何构建数据库链接等一个个方面，带大家深入走入JDBC的世界 1. JDBC使用方法六步 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.bjpowernode.jdbc;import java.sql.*;/** * Create By JD * Created by JBuck on 2020/11/24 *//* JDBC编程六步 */public class JDBCTest01 &#123; public static void main(String[] args) &#123; Connection conn = null; Statement stmt = null; try &#123; //1.注册驱动 Driver driver = new com.mysql.jdbc.Driver(); //多态，父类性引用指向子类型对象 DriverManager.registerDriver(driver); // Driver driver = new oracle.jdbc.driver.OracleDriver(); // oracle驱动 //2.获取连接 /* URL：统一资源定位符（网络中某个资源的绝对路径） http://www.baidu.com/ 这就是URL URL包括几部分？ 协议 IP PORT 资源名 http://182.61.200.7:80/index.html http:// 通信协议 182.61.200.7 服务器IP地址 80 服务器上软件的端口号 index.html 是服务器上某个资源名 jdbc:mysql://127.0.0.1:3306/bjpowernode jdbc:mysql:// 协议 127.0.0.1 IP地址 3306 mysql数据库端口号 bjpowernode 具体的数据库实例名 什么是通信协议，有什么用？ 通信协议实在通信之前就提前定好的数据传送格式。 数据包具体怎么传数据，格式提前定好的。 oracle的URL： jdbc:oracle:thin:@localhost:1521:orcl */ String url = &quot;jdbc:mysql://127.0.0.1:3306/bjpowernode&quot;; String user = &quot;root&quot;; String password = &quot;991229&quot;; conn = DriverManager.getConnection(url,user,password); System.out.println(&quot;数据库连接对象 = &quot; + conn); //3.获取数据库操作对象 stmt = conn.createStatement(); //4.执行sql String sql = &quot;insert into dept(deptno,dname,loc) values(50,&#x27;人事部&#x27;,&#x27;北京&#x27;)&quot;; //专门执行DML语句的(insert delete update) //返回值是“影响数据库中的记录条数” int count = stmt.executeUpdate(sql); System.out.println(count == 1 ? &quot;保存成功&quot; : &quot;保存失败&quot;); //5.处理查询结果集 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; //6.释放资源 // 为了保证资源一定释放，在finally语句块中关闭资源 // 并且要遵循从小到大依次关闭 // 分别对其try,catch try&#123; if(stmt != null)&#123; stmt.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try&#123; if(conn != null)&#123; conn.close(); &#125; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.bjpowernode.jdbc;import com.mysql.jdbc.Driver;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;/** * Create By JD * Created by JBuck on 2020/11/24 */public class JDBCTest02 &#123; public static void main(String[] args)&#123; Connection conn = null; Statement stmt = null; try&#123; //1.注册驱动 DriverManager.registerDriver(new com.mysql.jdbc.Driver()); //2.获取链接 conn = DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/bjpowernode&quot;, &quot;root&quot;, &quot;991229&quot;); //3.获取数据库操作对象 stmt = conn.createStatement(); //4.执行SQL语句 // JDBC的sql语句不用写分号 String sql = &quot;delete from dept where deptno = 40&quot;; int count = stmt.executeUpdate(sql); System.out.println(count == 1 ? &quot;删除成功&quot; : &quot;删除失败&quot;); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; //6.释放资源 try&#123; if(stmt != null)&#123; stmt.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try&#123; if(conn != null)&#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 2.实现注册的另一个方法 123456789101112131415161718192021222324252627282930313233343536package com.bjpowernode.jdbc;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;/** * Create By JD * Created by JBuck on 2020/11/24 *//* 注册驱动的另一种方式（这种方式常用） */public class JDBCTest03 &#123; public static void main(String[] args) &#123; Connection conn = null; Statement stmt = null; try &#123; //1.注册驱动 // 这个是注册驱动的第一种写法 //DriverManager.registerDriver(new com.mysql.jdbc.Driver()); //注册驱动的第二种方式：常用的 //为什么这种方式常用：因为参数是字符串，字符串可以写到xxx.properties文件中。 //以下方法不需要接收返回值，因为只想要他的类加载功能 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //2.获取链接 conn = DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/bjpowernode&quot;, &quot;root&quot;, &quot;991229&quot;); System.out.println(conn); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 为何使用反射机制可以实现注册呢？ 因为反射机制可以实现类加载 而static{}代码块会在类加载的时候运行，Driver的源代码为 12345678910111213141516171819202122//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package com.mysql.jdbc;import java.sql.DriverManager;import java.sql.SQLException;public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123; public Driver() throws SQLException &#123; &#125; static &#123; try &#123; DriverManager.registerDriver(new Driver()); &#125; catch (SQLException var1) &#123; throw new RuntimeException(&quot;Can&#x27;t register driver!&quot;); &#125; &#125;&#125; 说明可以使用反射机制实现类加载 3.将连接数据库的所有信息都配置到配置文件中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.bjpowernode.jdbc;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;import java.util.ResourceBundle;/** * Create By JD * Created by JBuck on 2020/11/24 *///将连接数据库的所有信息都配置到配置文件中/* 实际开发中不建议把连接数据库的信息写死到java程序中 */public class JDBCTest04 &#123; public static void main(String[] args) &#123; //使用资源绑定器绑定属性配置文件 ResourceBundle bundle = ResourceBundle.getBundle(&quot;com.bjpowernode.jdbc.jdbc&quot;); String driver = bundle.getString(&quot;driver&quot;); String url = bundle.getString(&quot;url&quot;); String user = bundle.getString(&quot;user&quot;); String password = bundle.getString(&quot;password&quot;); Connection conn = null; Statement stmt = null; try&#123; //1.注册驱动 Class.forName(driver); //2.获取链接 conn = DriverManager.getConnection(url, user, password); //3.获取数据库操作对象 stmt = conn.createStatement(); //4.执行SQL语句 // JDBC的sql语句不用写分号 String sql = &quot;update dept set dname = &#x27;销售部&#x27;,loc = &#x27;天津&#x27; where deptno = 20&quot;; int count = stmt.executeUpdate(sql); System.out.println(count == 1 ? &quot;添加成功&quot; : &quot;添加失败&quot;); &#125; catch (SQLException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125;finally &#123; //6.释放资源 try&#123; if(stmt != null)&#123; stmt.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try&#123; if(conn != null)&#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; jdbc.properties 1234driver=com.mysql.jdbc.Driverurl=jdbc:mysql://127.0.0.1:3306/bjpowernodeuser=rootpassword=991229 4. 查询数据库数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.bjpowernode.jdbc;import java.sql.*;import java.util.ResourceBundle;/** * Create By JD * Created by JBuck on 2020/11/25 */public class JDBCTest05 &#123; public static void main(String[] args) &#123; ResourceBundle rb = ResourceBundle.getBundle(&quot;com.bjpowernode.jdbc.jdbc&quot;); String driver = rb.getString(&quot;driver&quot;); String url = rb.getString(&quot;url&quot;); String user = rb.getString(&quot;user&quot;); String password = rb.getString(&quot;password&quot;); Connection conn = null; Statement stmt = null; ResultSet rs = null; try&#123; // 1.注册驱动 Class.forName(driver); // 2. 建立连接 conn = DriverManager.getConnection(url,user,password); // 3.获取数据库操作对象 stmt = conn.createStatement(); // 4.执行sql语句 String sql = &quot;select empno,ename,sal from emp&quot;; rs = stmt.executeQuery(sql); // 5.处理查询结果集 while(rs.next())&#123; //光标指向的行有数据 //取数据 //getString : 不管数据库中的数据类型是什么，都以String的形式取出 /* String empno = rs.getString(1); //JDBC中所有的下标从1开始，不是从0开始 String ename = rs.getString(2); String sal = rs.getString(3); */ /* //这个不是以列的下标获取，以列的名字获取 String empno = rs.getString(&quot;empno&quot;); //重点注意：列名称不是表中的列名称，是查询结果集的列名称 String ename = rs.getString(&quot;ename&quot;); String sal = rs.getString(&quot;sal&quot;); System.out.printf(empno + &quot;\\t| &quot; + ename + &quot; \\t| &quot; + sal + &quot;\\n&quot;); */ //除了可以以String类型取出之外，还可以以特定的类型取出 int empno = rs.getInt(1); String ename = rs.getString(2); double sal = rs.getDouble(3); System.out.println(empno + &quot;\\t| &quot; + ename + &quot; \\t| &quot; + (sal+100) + &quot;\\n&quot;); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try&#123; if(rs != null)&#123; rs.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try&#123; if(stmt != null)&#123; stmt.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try&#123; if(conn != null)&#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 5.Mysql注入问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123package com.bjpowernode.jdbc;import java.sql.*;import java.util.HashMap;import java.util.Map;import java.util.Scanner;/** * Create By JD * Created by JBuck on 2020/11/24 *//* 实现功能： 1.需求：模拟用户登录功能的实现 2.业务逻辑： 程序运行的时候，提供一个输入的入口，可以让用户输入用户的账户密码 用户输入用户名和密码之后，提交信息，java程序收集到用户信息 java程序连接数据库验证用户名和密码是否合适 合法：显示登陆成功 不合法：显示登陆失败 3.数据的准备 在实际的开发中，表的设计会使用专业的建模工具，我们这里安装一个建模工具：PowerDesigner 使用PD工具来进行数据库表的设计（参见login-user.sql） 4.当前程序存在的问题： 用户名： fdsa 密码： fdsa&#x27; or &#x27;1&#x27;=&#x27;1 登陆成功 这种现象被称为SQL注入（安全隐患）。（黑客经常使用） 5.导致SQL注入的根本原因是什么？ 用户输入的信息中含有sql语句的关键字，并且这些关键字参与了sql语句的编译过程， 导致了sql语句的原意被扭曲，从而导致sql注入。 */public class JDBCTest06 &#123; public static void main(String[] args) &#123; // 初始化一个界面 Map&lt;String,String&gt; userLoginInfo = initUI(); // 验证用户名和密码 boolean loginSuccess = login(userLoginInfo); // 最后输出结果 System.out.print(loginSuccess ? &quot;登陆成功&quot; : &quot;登录失败&quot;); &#125; /** * 用户登录 * @param userLoginInfo 用户登录信息 * @return false表示失败 ， true表示成功 */ private static boolean login(Map&lt;String, String&gt; userLoginInfo) &#123; String loginName = userLoginInfo.get(&quot;loginName&quot;) ; String loginPwd = userLoginInfo.get(&quot;loginPwd&quot;); boolean loginSuccess = false; // JDBC代码 Connection conn = null; Statement stmt = null; ResultSet rs = null; try &#123; // 1.注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); // 2.获取连接 conn = DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/bjpowernode&quot;,&quot;root&quot;,&quot;991229&quot;); // 3.获取数据库操作对象 stmt = conn.createStatement(); // 4.执行sql String sql = &quot;select * from t_user where loginName =&#x27;&quot; + loginName + &quot;&#x27; and loginPwd = &quot; + &quot;&#x27;&quot; + loginPwd + &quot;&#x27;&quot;; //以上正好完成了sql语句的拼接，以下代码的含义是，发送sql语句给DBMS，DBMS进行sql编译 //正好将用户提供的“非法信息”编译进去，导致原sql语句的含义被扭曲了 rs = stmt.executeQuery(sql); // 5.处理查询结果集 if(rs.next())&#123; loginSuccess = true; &#125; // 6.释放资源 &#125; catch (ClassNotFoundException | SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try&#123; if(rs != null)&#123; rs.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try&#123; if(stmt != null)&#123; stmt.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try&#123; if(conn != null)&#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return loginSuccess; &#125; /** * 初始化用户界面 * @return 用户输入的用户名和密码等登录信息 */ private static Map&lt;String, String&gt; initUI() &#123; Scanner s = new Scanner(System.in); System.out.print(&quot;用户名： &quot;); String loginName = s.nextLine(); System.out.print(&quot;密码： &quot;); String loginPwd = s.nextLine(); Map&lt;String,String&gt; userLoginInfo = new HashMap&lt;&gt;(); userLoginInfo.put(&quot;loginName&quot;,loginName); userLoginInfo.put(&quot;loginPwd&quot;,loginPwd); return userLoginInfo; &#125;&#125; 6. 解决mysql注入问题,prepareStatement 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129package com.bjpowernode.jdbc;import java.sql.*;import java.util.HashMap;import java.util.Map;import java.util.Scanner;/** * Create By JD * Created by JBuck on 2020/11/27 * 1.解决SQL注入问题 * 只要用户提供的信息不参与SQL语句的编译过程，问题就解决了 * 即使用户提供的信息中含有SQL语句的关键字，但是没有参与编译，不起作用。 * 要想用户信息不参与SQL语句的编译，那么必须使用java.sql.PreparedStatement * PreparedStatement接口继承了java.sql.Statement * PreparedStatement是属于预编译的数据库操作对象 * PreparedStatement的原理是：预先对SQL语句的框架进行编译，然后再给SQL语句传“值” * 2.测试结果： * 用户名：fads * 密码：fdas&#x27; or &#x27;1&#x27;=&#x27;1 * 登陆失败 * 3.解决SQL注入的关键是什么？ * 用户的信息中含有sql语句的关键字，但是这些关键字并没有参与编译不起作用 * 4.对比：Statement和PreparedStatement? * -Statement存在sql注入问题，PreparedStatement解决了sql注入问题 * -Statement是编译一次执行一次，PreparedStatement是编译一次执行N次，PreparedStatement效率高一些 * -PreparedStatement会在编译阶段，做类型的安全检查 * * 综上所述，PreparedStatement使用比较多，只有极少数的情况下需要使用Statement * * 5.什么情况下必须使用Statement呢？ * 业务方面需要使用sql注入机制 * Statement支持SQL注入，凡是业务方面需要使用sql注入的都需要使用Statement * */public class JDBCTest07 &#123; public static void main(String[] args) &#123; // 初始化一个界面 Map&lt;String,String&gt; userLoginInfo = initUI(); // 验证用户名和密码 boolean loginSuccess = login(userLoginInfo); // 最后输出结果 System.out.print(loginSuccess ? &quot;登陆成功&quot; : &quot;登录失败&quot;); &#125; /** * 用户登录 * @param userLoginInfo 用户登录信息 * @return false表示失败 ， true表示成功 */ private static boolean login(Map&lt;String, String&gt; userLoginInfo) &#123; String loginName = userLoginInfo.get(&quot;loginName&quot;) ; String loginPwd = userLoginInfo.get(&quot;loginPwd&quot;); boolean loginSuccess = false; // JDBC代码 Connection conn = null; PreparedStatement ps = null; //这里使用PreparedStatement（预编译的数据库操作对象） ResultSet rs = null; try &#123; // 1.注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); // 2.获取连接 conn = DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/bjpowernode&quot;,&quot;root&quot;,&quot;991229&quot;); // 3.获取预编译的数据库操作对象 // SQL语句的框子。其中一个?,表示一个占位符，一个？将来接收一个“值”，注意：占位符不能使用单引号括起来 String sql = &quot;select * from t_user where loginName = ? and loginPwd = ? &quot;; // 程序执行到此处，会发送sql语句框子给DBMS，然后DBMS进行sql语句的预先编译。 ps = conn.prepareStatement(sql); // 给占位符?传值（第一个?下标是1，第二个?下标是2,JDBC中所有下标从1开始。） ps.setString(1,loginName); ps.setString(2,loginPwd); // 4.执行sql rs = ps.executeQuery(); // 5.处理查询结果集 if(rs.next())&#123; loginSuccess = true; &#125; // 6.释放资源 &#125; catch (ClassNotFoundException | SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try&#123; if(rs != null)&#123; rs.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try&#123; if(ps != null)&#123; ps.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try&#123; if(conn != null)&#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return loginSuccess; &#125; /** * 初始化用户界面 * @return 用户输入的用户名和密码等登录信息 */ private static Map&lt;String, String&gt; initUI() &#123; Scanner s = new Scanner(System.in); System.out.print(&quot;用户名： &quot;); String loginName = s.nextLine(); System.out.print(&quot;密码： &quot;); String loginPwd = s.nextLine(); Map&lt;String,String&gt; userLoginInfo = new HashMap&lt;&gt;(); userLoginInfo.put(&quot;loginName&quot;,loginName); userLoginInfo.put(&quot;loginPwd&quot;,loginPwd); return userLoginInfo; &#125;&#125; 7.控制查询结果的升降序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.bjpowernode.jdbc;import java.sql.*;import java.util.Scanner;/** * Create By JD * Created by JBuck on 2020/11/30 */public class JDBCTest08 &#123; public static void main(String[] args) &#123; // 用户在控制台输入desc就是降序，输入asc就是升序 Scanner s = new Scanner(System.in); System.out.println(&quot;输入desc或asc,desc表示降序，asc表示升序&quot;); System.out.print(&quot;请输入： &quot;); String keyWorld = s.nextLine(); // 执行SQL Connection conn = null; Statement stmt = null; ResultSet rs = null; try &#123; // 注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); // 建立连接 conn = DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/bjpowernode&quot;,&quot;root&quot;,&quot;991229&quot;); // 获取操作对象 stmt = conn.createStatement(); // 执行操作 String sql = &quot;select ename from emp order by ename &quot; + keyWorld; rs = stmt.executeQuery(sql); // 遍历结果集 while(rs.next())&#123; System.out.println(rs.getString(&quot;ename&quot;)); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try&#123; if(rs != null)&#123; rs.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try&#123; if(stmt != null)&#123; stmt.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try&#123; if(conn != null)&#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 8. PreparedStatement 完成 INSERT DELETE UPDATE，模糊查询 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.bjpowernode.jdbc;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.SQLException;/** * Create By JD * Created by JBuck on 2020/11/30 * PreparedStatement 完成 INSERT DELETE UPDATE */public class JDBCTest09 &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement ps = null; try&#123; Class.forName(&quot;com.mysql.jdbc.Driver&quot;); conn = DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/bjpowernode&quot;,&quot;root&quot;,&quot;991229&quot;); /* String sql = &quot;insert into dept(deptno,dname,loc) value (?,?,?)&quot;; ps = conn.prepareStatement(sql); ps.setInt(1,60); ps.setString(2,&quot;销售部&quot;); ps.setString(3,&quot;上海&quot;); */ /* String sql = &quot;UPDATE dept set dname = ? ,loc = ? where deptno = ?&quot;; ps = conn.prepareStatement(sql); ps.setString(1,&quot;研发一部&quot;); ps.setString(2,&quot;北京&quot;); ps.setInt(3,60); */ String sql = &quot;DELETE from dept where deptno = ?&quot;; ps = conn.prepareStatement(sql); ps.setInt(1,60); int count = ps.executeUpdate(); System.out.print(count); &#125; catch (ClassNotFoundException | SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try&#123; if(ps != null)&#123; ps.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try&#123; if(conn != null)&#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536package com.bjpowernode.jdbc;import com.bjpowernode.jdbc.utils.DBUtil;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;/** * Create By JD * Created by JBuck on 2020/12/1 */public class JDBCTest12 &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; conn = DBUtil.getConnection(); String sql = &quot;select ename from emp where ename like ?&quot;; ps = conn.prepareStatement(sql); ps.setString(1,&quot;_A%&quot;); rs = ps.executeQuery(); while(rs.next())&#123; System.out.println(rs.getString(&quot;ename&quot;)); &#125; &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125;&#125; 9.mysql的事务机制 9.1 默认自动提交 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.bjpowernode.jdbc;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.SQLException;/** * Create By JD * Created by JBuck on 2020/11/30 * JDBC事物机制： * 1.JDBC中的事物是自动提交的，什么是自动提交？ * 只要执行任意一条DML语句，则自动提交一次。这是JDBC默认的事物行为 * 但是在实际事物中，通常都是N条DML语句共同联合才能完成，必须保证他们这些DML语句在同一个事物中， * 同时成功或者同时失败。 * 2.以下程序先来验证一下JDBC事物是否是自动提交机制 * 测试结果，只要自动执行一条DML语句，就执行一次 */public class JDBCTest10 &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement ps = null; try&#123; Class.forName(&quot;com.mysql.jdbc.Driver&quot;); conn = DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/bjpowernode&quot;,&quot;root&quot;,&quot;991229&quot;); String sql = &quot;update dept set dname = ? where deptno = ?&quot;; ps = conn.prepareStatement(sql); ps.setString(1,&quot;X部门&quot;); ps.setInt(2,30); int count = ps.executeUpdate(); //执行第一条sql语句 System.out.println(count); // 重新给占位符传值 ps.setString(1,&quot;y部门&quot;); ps.setInt(2,20); count = ps.executeUpdate(); //执行第二条sql语句 System.out.println(count); &#125; catch (ClassNotFoundException | SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try&#123; if(ps != null)&#123; ps.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try&#123; if(conn != null)&#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 9.2 实现事务的三行重要代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.bjpowernode.jdbc;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.SQLException;/** * Create By JD * Created by JBuck on 2020/12/1 * sql脚本： * drop table if exists t_act; * create table t_act( * actno bigint, * balance double(7,2) //注意： 7表示有效数字的个数，2表示小数位的个数 * ); * insert into t_act(actno,balance) values(111,20000); * insert into t_act(actno,balance) values(222,0); * commit; * select * from t_act; * * 重点三行代码？ * conn.setAutoCommit(false); * conn.commit(); * conn.rollback(); */public class JDBCTest11 &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement ps = null; try &#123; // 注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); // 获取连接 conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mydatabase&quot;,&quot;root&quot;,&quot;146&quot;); // 将自动提交改为手动提交 conn.setAutoCommit(false); // 获取预编译的数据库操作对象 String sql = &quot;update t_act set balance = ? where actno = ? &quot;; ps = conn.prepareStatement(sql); ps.setInt(1,10000); ps.setDouble(2,111); // 执行sql语句 int count = ps.executeUpdate(); /*String s = null; s.toString();*/ ps.setInt(1,10000); ps.setDouble(2,222); count += ps.executeUpdate(); System.out.println(count == 2 ? &quot;转账成功&quot; : &quot;转账失败&quot;); // 程序能执行到此处，说明没有异常，事务结束，手动提交数据 conn.commit(); &#125; catch (Exception e) &#123; // 遇到异常，回滚 if (conn != null) &#123; try &#123; conn.rollback(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; e.printStackTrace(); &#125; finally &#123; // 释放资源 if (ps != null) &#123; try &#123; ps.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 9.3 事务实战 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.bjpowernode.jdbc;import com.bjpowernode.jdbc.utils.DBUtil;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;/** * Create By JD * Created by JBuck on 2020/12/1 */public class JDBCTest13 &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; conn = DBUtil.getConnection(); // 开启事务 conn.setAutoCommit(false); ps = conn.prepareStatement(&quot;select ename,job,sal from emp where job = ? for update &quot;); ps.setString(1,&quot;MANAGER&quot;); rs = ps.executeQuery(); while(rs.next()) &#123; System.out.println(rs.getString(&quot;ename&quot;) + &quot;,&quot; + rs.getString(&quot;job&quot;) + &quot;,&quot; + rs.getString(&quot;sal&quot;)); &#125; // 提交事务（事务结束） conn.commit(); &#125; catch (SQLException throwables) &#123; // 回滚事务（事务结束） try &#123; conn.rollback(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; throwables.printStackTrace(); &#125; finally &#123; DBUtil.close(conn,ps,rs); &#125; &#125;&#125; 10.设计数据库工具类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.bjpowernode.jdbc.utils;import java.sql.*;/** * Create By JD * Created by JBuck on 2020/12/1 * * JDBC工具类，简化JDBC编程 *//* JDBC工具类，简化JDBC编程*/public class DBUtil &#123; /** * 工具类中的构造方法是私有的 * 因为工具类中的方法都是静态的，直接通过类名去调即可。 */ private DBUtil()&#123;&#125; /** * 静态代码块，类加载的时候执行 * 把注册驱动程序的代码放在静态代码块中，避免多次获取连接对象时重复调用 */ static &#123; try &#123; Class.forName(&quot;com.mysql.jdbc.Driver&quot;); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() throws SQLException &#123; return DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mydatabase&quot;,&quot;root&quot;,&quot;146&quot;); &#125; public static void close(Connection conn, Statement ps, ResultSet rs)&#123; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; if (ps != null) &#123; try &#123; ps.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; &#125;&#125; 11. 数据库连接池 数据库连接 – 执行完毕 —释放 连接 – 释放 十分浪费系统资源 池化技术：准备一些预先的资源，过来就连接预先准备好的 最小链接数：10 最大连接数：100 业务最高承载上限 等待超时：100ms 编写连接池，实现一个接口，DataSource 开源数据源实现 DBCP C3P0 Druid：阿里巴巴 使用这些数据库连接池之后，我们在项目开发中就不需要编写连接数据库的代码了！ 下面编写测试使用的数据库 12345678910111213141516CREATE DATABASE jdbcStudy CHARACTER SET utf8 COLLATE utf8_general_ci;USE jdbcStudy;CREATE TABLE `users`( id INT PRIMARY KEY, NAME VARCHAR(40), PASSWORD VARCHAR(40), email VARCHAR(60), birthday DATE);INSERT INTO `users`(id,NAME,PASSWORD,email,birthday)VALUES(1,&#x27;zhansan&#x27;,&#x27;123456&#x27;,&#x27;zs@sina.com&#x27;,&#x27;1980-12-04&#x27;),(2,&#x27;lisi&#x27;,&#x27;123456&#x27;,&#x27;lisi@sina.com&#x27;,&#x27;1981-12-04&#x27;),(3,&#x27;wangwu&#x27;,&#x27;123456&#x27;,&#x27;wangwu@sina.com&#x27;,&#x27;1979-12-04&#x27;) DBCP 需要用到的jar包 123456789101112&lt;!-- https://mvnrepository.com/artifact/commons-dbcp/commons-dbcp --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/commons-pool/commons-pool --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-pool&lt;/groupId&gt; &lt;artifactId&gt;commons-pool&lt;/artifactId&gt; &lt;version&gt;1.6&lt;/version&gt;&lt;/dependency&gt; 实现JdbcUtil_DBCP.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.bjpowernode.jdbc.utils;import org.apache.commons.dbcp.BasicDataSourceFactory;import javax.sql.DataSource;import java.io.IOException;import java.io.InputStream;import java.sql.*;import java.util.Properties;/** * Create By JD * Created by JBuck on 2021/4/10 */public class JdbcUtil_DBCP &#123; private JdbcUtil_DBCP()&#123;&#125; private static DataSource dataSource = null; static &#123; try &#123; InputStream in = JdbcUtil_DBCP.class.getClassLoader().getResourceAsStream(&quot;dbcpconfig.properties&quot;); Properties properties = new Properties(); properties.load(in); //创建数据源:工厂模式 --&gt; 创建 dataSource = BasicDataSourceFactory.createDataSource(properties); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() throws SQLException &#123; return dataSource.getConnection(); //从数据源中获取连接 &#125; public static void close(Connection conn, Statement ps, ResultSet rs)&#123; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; if (ps != null) &#123; try &#123; ps.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; &#125;&#125; 配置文件dbcpconfig.properties 12345678910111213141516171819202122232425262728293031323334#连接设置driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/jdbcStudy?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=trueusername=rootpassword=991229#&lt;!-- 初始化连接 --&gt;initialSize=10#最大连接数量maxActive=50#&lt;!-- 最大空闲连接 --&gt;maxIdle=20#&lt;!-- 最小空闲连接 --&gt;minIdle=5#&lt;!-- 超时等待时间以毫秒为单位 6000毫秒/1000等于60秒 --&gt;maxWait=60000#JDBC驱动建立连接时附带的连接属性属性的格式必须为这样：【属性名=property;】#注意：&quot;user&quot; 与 &quot;password&quot; 两个属性会被明确地传递，因此这里不需要包含他们。connectionProperties=useUnicode=true;characterEncoding=UTF8#指定由连接池所创建的连接的自动提交（auto-commit）状态。defaultAutoCommit=true#driver default 指定由连接池所创建的连接的只读（read-only）状态。#如果没有设置该值，则“setReadOnly”方法将不被调用。（某些驱动并不支持只读模式，如：Informix）defaultReadOnly=#driver default 指定由连接池所创建的连接的事务级别（TransactionIsolation）。#可用值为下列之一：（详情可见javadoc。）NONE,READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLEdefaultTransactionIsolation=READ_UNCOMMITTED 测试程序 12345678910111213141516171819202122232425262728293031323334353637383940package com.bjpowernode.jdbc;import com.bjpowernode.jdbc.utils.JdbcUtil_DBCP;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.SQLException;import java.util.Date;/** * Create By JD * Created by JBuck on 2021/4/10 */public class TestDBCP &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement st = null; try &#123; conn = JdbcUtil_DBCP.getConnection(); String sql = &quot;insert into users(id,NAME,PASSWORD,email,birthday)values(?,?,?,?,?)&quot;; st = conn.prepareStatement(sql); st.setInt(1,6); st.setString(2,&quot;qinjiang&quot;); st.setString(3,&quot;1232112&quot;); st.setString(4,&quot;24@qq.com&quot;); st.setDate(5, new java.sql.Date(new Date().getTime())); int i = st.executeUpdate(); if(i&gt;0)&#123; System.out.println(&quot;插入成功！&quot;); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JdbcUtil_DBCP.close(conn,st,null); &#125; &#125;&#125; C3P0 需要用到的jar包 12345678910111213&lt;!-- https://mvnrepository.com/artifact/com.mchange/c3p0 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.5&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.mchange/mchange-commons-java --&gt;&lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;mchange-commons-java&lt;/artifactId&gt; &lt;version&gt;0.2.19&lt;/version&gt;&lt;/dependency&gt; 实现JdbcUtil_C3P0.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.bjpowernode.jdbc.utils;import com.mchange.v2.c3p0.ComboPooledDataSource;import org.apache.commons.dbcp.BasicDataSourceFactory;import javax.sql.DataSource;import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.Properties;/** * Create By JD * Created by JBuck on 2021/4/11 */public class JdbcUtil_C3P0 &#123; private JdbcUtil_C3P0()&#123;&#125; private static ComboPooledDataSource dataSource = null; static &#123; try &#123; // 代码版配置// dataSource = new ComboPooledDataSource();// dataSource.setDriverClass();// dataSource.setUser(); //创建数据源:工厂模式 --&gt; 创建 dataSource = new ComboPooledDataSource(&quot;MySQL&quot;); //配置文件写法 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() throws SQLException &#123; return dataSource.getConnection(); //从数据源中获取连接 &#125; public static void close(Connection conn, Statement ps, ResultSet rs)&#123; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; if (ps != null) &#123; try &#123; ps.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; &#125;&#125; 配置文件 c3p0-config.xml 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;c3p0-config&gt; &lt;!-- c3p0的缺省（默认）配置 如果在代码中&quot;ComboPooledDataSource ds=new ComboPooledDataSource();&quot;这样写就表示使用的是c3p0的缺省（默认） --&gt; &lt;default-config&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://localhost:3306/jdbcStudy&lt;/property&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt; &lt;property name=&quot;acquiredIncrement&quot;&gt;5&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;10&lt;/property&gt; &lt;property name=&quot;minPoolSize&quot;&gt;5&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;20&lt;/property&gt; &lt;/default-config&gt; &lt;!-- C3P0的命名配置， 如果在代码中&quot;ComboPooledDataSource ds = new ComboPooledDataSource(&quot;MySQL&quot;);&quot;这样写就表示使用的是name是MySQL的配置 --&gt; &lt;named-config name=&quot;MySQL&quot;&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://localhost:3306/jdbcStudy&lt;/property&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;991229&lt;/property&gt; &lt;property name=&quot;acquiredIncrement&quot;&gt;5&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;10&lt;/property&gt; &lt;property name=&quot;minPoolSize&quot;&gt;5&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;20&lt;/property&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; 测试程序： 1234567891011121314151617181920212223242526272829303132333435363738394041package com.bjpowernode.jdbc;import com.bjpowernode.jdbc.utils.JdbcUtil_C3P0;import com.bjpowernode.jdbc.utils.JdbcUtil_DBCP;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.SQLException;import java.util.Date;/** * Create By JD * Created by JBuck on 2021/4/11 */public class TestC3P0 &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement st = null; try &#123; conn = JdbcUtil_C3P0.getConnection(); String sql = &quot;insert into users(id,NAME,PASSWORD,email,birthday)values(?,?,?,?,?)&quot;; st = conn.prepareStatement(sql); st.setInt(1,5); st.setString(2,&quot;qinjiang&quot;); st.setString(3,&quot;1232112&quot;); st.setString(4,&quot;24@qq.com&quot;); st.setDate(5, new java.sql.Date(new Date().getTime())); int i = st.executeUpdate(); if(i&gt;0)&#123; System.out.println(&quot;插入成功！&quot;); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JdbcUtil_DBCP.close(conn,st,null); &#125; &#125;&#125; 结论：无论使用什么数据源，本质还是一样的,DataSource接口不会变，方法就不会变","categories":[{"name":"数据库","slug":"数据库","permalink":"https://47.115.211.244/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"https://47.115.211.244/blog/tags/JDBC/"}]},{"title":"MySQL笔记","slug":"MySQL笔记","date":"2021-06-09T01:47:00.000Z","updated":"2021-06-09T10:10:24.681Z","comments":true,"path":"2021/06/08/MySQL笔记/","link":"2021/06/08/MySQL笔记","permalink":"https://47.115.211.244/blog/2021/06/08/MySQL%E7%AC%94%E8%AE%B0/","excerpt":"本教程为mysql初步笔记，可以简单粗略的将mysql学习一遍 第一个部分 1、sql、DB、DBMS分别是什么，他们之间的关系？ DB: DataBase（数据库，数据库实际上在硬盘上以文件的形式存在） DBMS: DataBase Management System（数据库管理系统，常见的有：MySQL Oracle DB2 Sybase SqlServer...） SQL: 结构化查询语言，是一门标准通用的语言。标准的sql适合于所有的数据库产品。 SQL属于高级语言。只要能看懂英语单词的，写出来的sql语句，可以读懂什么意思。 SQL语句在执行的时候，实际上内部也会先进行编译，然后再执行sql。（sql语句的编译由DBMS完成。） DBMS负责执行sql语句，通过执行sql语句来操作DB当中的数据。 DBMS -(执行)-&gt; SQL -(操作)-&gt; DB","text":"本教程为mysql初步笔记，可以简单粗略的将mysql学习一遍 第一个部分 1、sql、DB、DBMS分别是什么，他们之间的关系？ DB: DataBase（数据库，数据库实际上在硬盘上以文件的形式存在） DBMS: DataBase Management System（数据库管理系统，常见的有：MySQL Oracle DB2 Sybase SqlServer...） SQL: 结构化查询语言，是一门标准通用的语言。标准的sql适合于所有的数据库产品。 SQL属于高级语言。只要能看懂英语单词的，写出来的sql语句，可以读懂什么意思。 SQL语句在执行的时候，实际上内部也会先进行编译，然后再执行sql。（sql语句的编译由DBMS完成。） DBMS负责执行sql语句，通过执行sql语句来操作DB当中的数据。 DBMS -(执行)-&gt; SQL -(操作)-&gt; DB 2、什么是表？ 表：table 表：table是数据库的基本组成单元，所有的数据都以表格的形式组织，目的是可读性强。 一个表包括行和列： 行：被称为数据/记录(data) 列：被称为字段(column) 学号(int) 姓名(varchar) 年龄(int) ------------------------------------ 110 张三 20 120 李四 21 每一个字段应该包括哪些属性？ 字段名、数据类型、相关的约束。 3、学习MySQL主要还是学习通用的SQL语句，那么SQL语句包括增删改查，SQL语句怎么分类呢？ 12345DQL（数据查询语言）: 查询语句，凡是select语句都是DQL。DML（数据操作语言）：insert delete update，对表当中的数据进行增删改。DDL（数据定义语言）：create drop alter，对表结构的增删改。TCL（事务控制语言）：commit提交事务，rollback回滚事务。(TCL中的T是Transaction)DCL（数据控制语言）: grant授权、revoke撤销权限等。 4、导入数据（后期大家练习的时候使用这个演示的数据） 12345678910111213 第一步：登录mysql数据库管理系统 dos命令窗口： mysql -uroot -p333 第二步：查看有哪些数据库 show databases; (这个不是SQL语句，属于MySQL的命令。)+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || test |+-------------------+ 第三步：创建属于我们自己的数据库 create database bjpowernode; (这个不是SQL语句，属于MySQL的命令。) 第四步：使用bjpowernode数据 use bjpowernode; (这个不是SQL语句，属于MySQL的命令。) 第五步：查看当前使用的数据库中有哪些表？ show tables; (这个不是SQL语句，属于MySQL的命令。) 第六步：初始化数据 mysql&gt; source D:\\course\\05-MySQL\\resources\\bjpowernode.sql 注意：数据初始化完成之后，有三张表： +-----------------------+ | Tables_in_bjpowernode | +-----------------------+ | dept | | emp | | salgrade | +-----------------------+ 5、bjpowernode.sql 1234这个文件以sql结尾，这样的文件被称为“sql脚本”。什么是sql脚本呢？当一个文件的扩展名是.sql，并且该文件中编写了大量的sql语句，我们称这样的文件为sql脚本。注意：直接使用source命令可以执行sql脚本。sql脚本中的数据量太大的时候，无法打开，请使用source命令完成初始化。 6、删除数据库： 1drop database bjpowernode; 7、查看表结构： +-----------------------+ | Tables_in_bjpowernode | +-----------------------+ | dept | (部门表) | emp | (员工表) | salgrade | (工资等级表) +-----------------------+ mysql&gt; desc dept; +--------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +--------+-------------+------+-----+---------+-------+ | DEPTNO | int(2) | NO | PRI | NULL | | 部门编号 | DNAME | varchar(14) | YES | | NULL | | 部门名称 | LOC | varchar(13) | YES | | NULL | | 部门位置 +--------+-------------+------+-----+---------+-------+ mysql&gt; desc emp; +----------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +----------+-------------+------+-----+---------+-------+ | EMPNO | int(4) | NO | PRI | NULL | | 员工编号 | ENAME | varchar(10) | YES | | NULL | | 员工姓名 | JOB | varchar(9) | YES | | NULL | | 工作岗位 | MGR | int(4) | YES | | NULL | | 上级领导编号 | HIREDATE | date | YES | | NULL | | 入职日期 | SAL | double(7,2) | YES | | NULL | | 月薪 | COMM | double(7,2) | YES | | NULL | | 补助/津贴 | DEPTNO | int(2) | YES | | NULL | | 部门编号 +----------+-------------+------+-----+---------+-------+ mysql&gt; desc salgrade; +-------+---------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+---------+------+-----+---------+-------+ | GRADE | int(11) | YES | | NULL | | 等级 | LOSAL | int(11) | YES | | NULL | | 最低薪资 | HISAL | int(11) | YES | | NULL | | 最高薪资 +-------+---------+------+-----+---------+-------+ 8、表中的数据？ mysql&gt; select * from emp; 123456789101112131415161718+-------+--------+-----------+------+------------+---------+---------+--------+| EMPNO | ENAME | JOB | MGR | HIREDATE | SAL | COMM | DEPTNO |+-------+--------+-----------+------+------------+---------+---------+--------+| 7369 | SMITH | CLERK | 7902 | 1980-12-17 | 800.00 | NULL | 20 || 7499 | ALLEN | SALESMAN | 7698 | 1981-02-20 | 1600.00 | 300.00 | 30 || 7521 | WARD | SALESMAN | 7698 | 1981-02-22 | 1250.00 | 500.00 | 30 || 7566 | JONES | MANAGER | 7839 | 1981-04-02 | 2975.00 | NULL | 20 || 7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 | 1250.00 | 1400.00 | 30 || 7698 | BLAKE | MANAGER | 7839 | 1981-05-01 | 2850.00 | NULL | 30 || 7782 | CLARK | MANAGER | 7839 | 1981-06-09 | 2450.00 | NULL | 10 || 7788 | SCOTT | ANALYST | 7566 | 1987-04-19 | 3000.00 | NULL | 20 || 7839 | KING | PRESIDENT | NULL | 1981-11-17 | 5000.00 | NULL | 10 || 7844 | TURNER | SALESMAN | 7698 | 1981-09-08 | 1500.00 | 0.00 | 30 || 7876 | ADAMS | CLERK | 7788 | 1987-05-23 | 1100.00 | NULL | 20 || 7900 | JAMES | CLERK | 7698 | 1981-12-03 | 950.00 | NULL | 30 || 7902 | FORD | ANALYST | 7566 | 1981-12-03 | 3000.00 | NULL | 20 || 7934 | MILLER | CLERK | 7782 | 1982-01-23 | 1300.00 | NULL | 10 |+-------+--------+-----------+------+------------+---------+---------+--------+ 123456789mysql&gt; select * from dept;+--------+------------+----------+| DEPTNO | DNAME | LOC |+--------+------------+----------+| 10 | ACCOUNTING | NEW YORK || 20 | RESEARCH | DALLAS || 30 | SALES | CHICAGO || 40 | OPERATIONS | BOSTON |+--------+------------+----------+ 12345678910mysql&gt; select * from salgrade;+-------+-------+-------+| GRADE | LOSAL | HISAL |+-------+-------+-------+| 1 | 700 | 1200 || 2 | 1201 | 1400 || 3 | 1401 | 2000 || 4 | 2001 | 3000 || 5 | 3001 | 9999 |+-------+-------+-------+ 9、常用命令？ 123456mysql&gt; select database(); 查看当前使用的是哪个数据库+-------------+| database() |+-------------+| bjpowernode |+-------------+ 12345678mysql&gt; select version(); 查看mysql的版本号。+-----------+| version() |+-----------+| 5.5.36 |+-----------+\\c 命令，结束一条语句。exit 命令，退出mysql。 10、查看创建表的语句： 1show create table emp; 11、简单的查询语句（DQL） 语法格式： select 字段名1,字段名2,字段名3,.... from 表名; 提示： 1、任何一条sql语句以“;”结尾。 2、sql语句不区分大小写。 查询员工的年薪？（字段可以参与数学运算。） select ename,sal * 12 from emp; +--------+----------+ | ename | sal * 12 | +--------+----------+ | SMITH | 9600.00 | | ALLEN | 19200.00 | | WARD | 15000.00 | | JONES | 35700.00 | | MARTIN | 15000.00 | | BLAKE | 34200.00 | | CLARK | 29400.00 | | SCOTT | 36000.00 | | KING | 60000.00 | | TURNER | 18000.00 | | ADAMS | 13200.00 | | JAMES | 11400.00 | | FORD | 36000.00 | | MILLER | 15600.00 | +--------+----------+ 给查询结果的列重命名？ select ename,sal * 12 as yearsal from emp; 别名中有中文？ select ename,sal * 12 as 年薪 from emp; // 错误 select ename,sal * 12 as '年薪' from emp; +--------+----------+ | ename | 年薪 | +--------+----------+ | SMITH | 9600.00 | | ALLEN | 19200.00 | | WARD | 15000.00 | | JONES | 35700.00 | | MARTIN | 15000.00 | | BLAKE | 34200.00 | | CLARK | 29400.00 | | SCOTT | 36000.00 | | KING | 60000.00 | | TURNER | 18000.00 | | ADAMS | 13200.00 | | JAMES | 11400.00 | | FORD | 36000.00 | | MILLER | 15600.00 | +--------+----------+ 注意：标准sql语句中要求字符串使用单引号括起来。虽然mysql支持双引号，尽量别用。 as关键字可以省略？ mysql&gt; select empno,ename,sal * 12 yearsal from emp; +-------+--------+----------+ | empno | ename | yearsal | +-------+--------+----------+ | 7369 | SMITH | 9600.00 | | 7499 | ALLEN | 19200.00 | | 7521 | WARD | 15000.00 | | 7566 | JONES | 35700.00 | | 7654 | MARTIN | 15000.00 | | 7698 | BLAKE | 34200.00 | | 7782 | CLARK | 29400.00 | | 7788 | SCOTT | 36000.00 | | 7839 | KING | 60000.00 | | 7844 | TURNER | 18000.00 | | 7876 | ADAMS | 13200.00 | | 7900 | JAMES | 11400.00 | | 7902 | FORD | 36000.00 | | 7934 | MILLER | 15600.00 | +-------+--------+----------+ 查询所有字段？ select * from emp; // 实际开发中不建议使用*，效率较低。 12、条件查询。 语法格式： select 字段,字段... from 表名 where 条件; 执行顺序：先from，然后where，最后select 查询工资等于5000的员工姓名？ select ename from emp where sal = 5000; +-------+ | ename | +-------+ | KING | +-------+ 查询SMITH的工资？ select sal from emp where ename = 'SMITH'; // 字符串使用单引号括起来。 +--------+ | sal | +--------+ | 800.00 | +--------+ 找出工资高于3000的员工？ select ename,sal from emp where sal &gt; 3000; select ename,sal from emp where sal &gt;= 3000; select ename,sal from emp where sal &lt; 3000; select ename,sal from emp where sal &lt;= 3000; 找出工资不等于3000的？ select ename,sal from emp where sal &lt;&gt; 3000; select ename,sal from emp where sal != 3000; 找出工资在1100和3000之间的员工，包括1100和3000？ select ename,sal from emp where sal &gt;= 1100 and sal &lt;= 3000; select ename,sal from emp where sal between 1100 and 3000; // between...and...是闭区间 [1100 ~ 3000] select ename,sal from emp where sal between 3000 and 1100; // 查询不到任何数据 between and在使用的时候必须左小右大。 between and除了可以使用在数字方面之外，还可以使用在字符串方面。 select ename from emp where ename between 'A' and 'C'; +-------+ | ename | +-------+ | ALLEN | | BLAKE | | ADAMS | +-------+ select ename from emp where ename between 'A' and 'D'; // 左闭右开。 找出哪些人津贴为NULL？ 在数据库当中NULL不是一个值，代表什么也没有，为空。 空不是一个值，不能用等号衡量。 必须使用 is null或者is not null select ename,sal,comm from emp where comm is null; +--------+---------+------+ | ename | sal | comm | +--------+---------+------+ | SMITH | 800.00 | NULL | | JONES | 2975.00 | NULL | | BLAKE | 2850.00 | NULL | | CLARK | 2450.00 | NULL | | SCOTT | 3000.00 | NULL | | KING | 5000.00 | NULL | | ADAMS | 1100.00 | NULL | | JAMES | 950.00 | NULL | | FORD | 3000.00 | NULL | | MILLER | 1300.00 | NULL | +--------+---------+------+ select ename,sal,comm from emp where comm = null; Empty set (0.00 sec) 找出哪些人津贴不为NULL？ select ename,sal,comm from emp where comm is not null; +--------+---------+---------+ | ename | sal | comm | +--------+---------+---------+ | ALLEN | 1600.00 | 300.00 | | WARD | 1250.00 | 500.00 | | MARTIN | 1250.00 | 1400.00 | | TURNER | 1500.00 | 0.00 | +--------+---------+---------+ 找出哪些人没有津贴？ select ename,sal,comm from emp where comm is null or comm = 0; +--------+---------+------+ | ename | sal | comm | +--------+---------+------+ | SMITH | 800.00 | NULL | | JONES | 2975.00 | NULL | | BLAKE | 2850.00 | NULL | | CLARK | 2450.00 | NULL | | SCOTT | 3000.00 | NULL | | KING | 5000.00 | NULL | | TURNER | 1500.00 | 0.00 | | ADAMS | 1100.00 | NULL | | JAMES | 950.00 | NULL | | FORD | 3000.00 | NULL | | MILLER | 1300.00 | NULL | +--------+---------+------+ 找出工作岗位是MANAGER和SALESMAN的员工？ select ename,job from emp where job = 'MANAGER' or job = 'SALESMAN'; +--------+----------+ | ename | job | +--------+----------+ | ALLEN | SALESMAN | | WARD | SALESMAN | | JONES | MANAGER | | MARTIN | SALESMAN | | BLAKE | MANAGER | | CLARK | MANAGER | | TURNER | SALESMAN | +--------+----------+ and和or联合起来用：找出薪资大于1000的并且部门编号是20或30部门的员工。 select ename,sal,deptno from emp where sal &gt; 1000 and deptno = 20 or deptno = 30; // 错误的 select ename,sal,deptno from emp where sal &gt; 1000 and (deptno = 20 or deptno = 30); // 正确的。 注意：当运算符的优先级不确定的时候加小括号。 in等同于or：找出工作岗位是MANAGER和SALESMAN的员工？ select ename,job from emp where job = 'SALESMAN' or job = 'MANAGER'; select ename,job from emp where job in('SALESMAN', 'MANAGER'); select ename,job from emp where sal in(800, 5000); // in后面的值不是区间，是具体的值。 +-------+-----------+ | ename | job | +-------+-----------+ | SMITH | CLERK | | KING | PRESIDENT | +-------+-----------+ not in: 不在这几个值当中。 select ename,job from emp where sal not in(800, 5000); 模糊查询like ? 找出名字当中含有O的？ （在模糊查询当中，必须掌握两个特殊的符号，一个是%，一个是_） %代表任意多个字符，_代表任意1个字符。 select ename from emp where ename like '%O%'; +-------+ | ename | +-------+ | JONES | | SCOTT | | FORD | +-------+ 找出名字中第二个字母是A的？ select ename from emp where ename like '_A%'; +--------+ | ename | +--------+ | WARD | | MARTIN | | JAMES | +--------+ 找出名字中有下划线的？ mysql&gt; select * from t_user; +------+----------+ | id | name | +------+----------+ | 1 | zhangsan | | 2 | lisi | | 3 | WANG_WU | +------+----------+ select name from t_user where name like '%_%'; +----------+ | name | +----------+ | zhangsan | | lisi | | WANG_WU | +----------+ select name from t_user where name like '%\\_%'; +---------+ | name | +---------+ | WANG_WU | +---------+ 找出名字中最后一个字母是T的？ select ename from emp where ename like '%T'; +-------+ | ename | +-------+ | SCOTT | +-------+ 13、排序（升序、降序） 按照工资升序，找出员工名和薪资？ 1234567891011121314151617181920212223242526272829303132333435 select ename,sal from emp order by sal;+--------+---------+| ename | sal |+--------+---------+| SMITH | 800.00 || JAMES | 950.00 || ADAMS | 1100.00 || WARD | 1250.00 || MARTIN | 1250.00 || MILLER | 1300.00 || TURNER | 1500.00 || ALLEN | 1600.00 || CLARK | 2450.00 || BLAKE | 2850.00 || JONES | 2975.00 || FORD | 3000.00 || SCOTT | 3000.00 || KING | 5000.00 |+--------+---------+注意：默认是升序。怎么指定升序或者降序呢？asc表示升序，desc表示降序。 select ename , sal from emp order by sal; // 升序 select ename , sal from emp order by sal asc; // 升序 select ename , sal from emp order by sal desc; // 降序。按照工资的降序排列，当工资相同的时候再按照名字的升序排列。 select ename,sal from emp order by sal desc; select ename,sal from emp order by sal desc , ename asc; 注意：越靠前的字段越能起到主导作用。只有当前面的字段无法完成排序的时候，才会启用后面的字段。找出工作岗位是SALESMAN的员工，并且要求按照薪资的降序排列。 12345678910111213141516select ename,job,sal from emp where job = &#x27;SALESMAN&#x27; order by sal desc;+--------+----------+---------+| ename | job | sal |+--------+----------+---------+| ALLEN | SALESMAN | 1600.00 || TURNER | SALESMAN | 1500.00 || WARD | SALESMAN | 1250.00 || MARTIN | SALESMAN | 1250.00 |+--------+----------+---------+ select 字段 3 from 表名 1 where 条件 2 order by .... 4 order by是最后执行的。 14、分组函数？ count 计数 sum 求和 avg 平均值 max 最大值 min 最小值 记住：所有的分组函数都是对“某一组”数据进行操作的。 找出工资总和？ select sum(sal) from emp; 找出最高工资？ select max(sal) from emp; 找出最低工资？ select min(sal) from emp; 找出平均工资？ select avg(sal) from emp; 找出总人数？ select count(*) from emp; select count(ename) from emp; 分组函数一共5个。 分组函数还有另一个名字：多行处理函数。 多行处理函数的特点：输入多行，最终输出的结果是1行。 分组函数自动忽略NULL。 select count(comm) from emp; +-------------+ | count(comm) | +-------------+ | 4 | +-------------+ select sum(comm) from emp; +-----------+ | sum(comm) | +-----------+ | 2200.00 | +-----------+ select sum(comm) from emp where comm is not null; // 不需要额外添加这个过滤条件。sum函数自动忽略NULL。 找出工资高于平均工资的员工？ select avg(sal) from emp; // 平均工资 +-------------+ | avg(sal) | +-------------+ | 2073.214286 | +-------------+ select ename,sal from emp where sal &gt; avg(sal); //ERROR 1111 (HY000): Invalid use of group function 思考以上的错误信息：无效的使用了分组函数？ 原因：SQL语句当中有一个语法规则，分组函数不可直接使用在where子句当中。why???? 怎么解释？ 因为group by是在where执行之后才会执行的。 select 5 .. from 1 .. where 2 .. group by 3 .. having 4 .. order by 6 .. count(*)和count(具体的某个字段)，他们有什么区别？ count(*):不是统计某个字段中数据的个数，而是统计总记录条数。（和某个字段无关） count(comm): 表示统计comm字段中不为NULL的数据总数量。 分组函数也能组合起来用： select count(*),sum(sal),avg(sal),max(sal),min(sal) from emp; +----------+----------+-------------+----------+----------+ | count(*) | sum(sal) | avg(sal) | max(sal) | min(sal) | +----------+----------+-------------+----------+----------+ | 14 | 29025.00 | 2073.214286 | 5000.00 | 800.00 | +----------+----------+-------------+----------+----------+ 找出工资高于平均工资的员工？ 第一步：找出平均工资 select avg(sal) from emp; +-------------+ | avg(sal) | +-------------+ | 2073.214286 | +-------------+ 第二步：找出高于平均工资的员工 select ename,sal from emp where sal &gt; 2073.214286; +-------+---------+ | ename | sal | +-------+---------+ | JONES | 2975.00 | | BLAKE | 2850.00 | | CLARK | 2450.00 | | SCOTT | 3000.00 | | KING | 5000.00 | | FORD | 3000.00 | +-------+---------+ 可合并为 select ename,sal from emp where sal &gt; (select avg(sal) from emp); 15、单行处理函数 什么是单行处理函数？ 输入一行，输出一行。 计算每个员工的年薪？ select ename,(sal+comm)*12 as yearsal from emp; 重点：所有数据库都是这样规定的，只要有NULL参与的运算结果一定是NULL。 使用ifnull函数： select ename,(sal+ifnull(comm,0))*12 as yearsal from emp; ifnull() 空处理函数？ ifnull(可能为NULL的数据,被当做什么处理) ： 属于单行处理函数。 select ename,ifnull(comm,0) as comm from emp; +--------+---------+ | ename | comm | +--------+---------+ | SMITH | 0.00 | | ALLEN | 300.00 | | WARD | 500.00 | | JONES | 0.00 | | MARTIN | 1400.00 | | BLAKE | 0.00 | | CLARK | 0.00 | | SCOTT | 0.00 | | KING | 0.00 | | TURNER | 0.00 | | ADAMS | 0.00 | | JAMES | 0.00 | | FORD | 0.00 | | MILLER | 0.00 | +--------+---------+ 16、group by 和 having group by ： 按照某个字段或者某些字段进行分组。 having : having是对分组之后的数据进行再次过滤。 案例：找出每个工作岗位的最高薪资。 select max(sal),job from emp group by job; +----------+-----------+ | max(sal) | job | +----------+-----------+ | 3000.00 | ANALYST | | 1300.00 | CLERK | | 2975.00 | MANAGER | | 5000.00 | PRESIDENT | | 1600.00 | SALESMAN | +----------+-----------+ ​ 注意：分组函数一般都会和group by联合使用，这也是为什么它被称为分组函数的原因。 并且任何一个分组函数（count sum avg max min）都是在group by语句执行结束之后才会执行的。 当一条sql语句没有group by的话，整张表的数据会自成一组。 select ename,max(sal),job from emp group by job; 以上在mysql当中，查询结果是有的，但是结果没有意义，在Oracle数据库当中会报错。语法错误。 Oracle的语法规则比MySQL语法规则严谨。 记住一个规则：当一条语句中有group by的话，select后面只能跟分组函数和参与分组的字段。 每个工作岗位的平均薪资？ select job,avg(sal) from emp group by job; +-----------+-------------+ | job | avg(sal) | +-----------+-------------+ | ANALYST | 3000.000000 | | CLERK | 1037.500000 | | MANAGER | 2758.333333 | | PRESIDENT | 5000.000000 | | SALESMAN | 1400.000000 | +-----------+-------------+ 多个字段能不能联合起来一块分组？ 案例：找出每个部门不同工作岗位的最高薪资。 select deptno,job,max(sal) from emp group by deptno,job; 找出每个部门的最高薪资，要求显示薪资大于2900的数据。 第一步：找出每个部门的最高薪资 select max(sal),deptno from emp group by deptno; +----------+--------+ | max(sal) | deptno | +----------+--------+ | 5000.00 | 10 | | 3000.00 | 20 | | 2850.00 | 30 | +----------+--------+ 第二步：找出薪资大于2900 select max(sal),deptno from emp group by deptno having max(sal) &gt; 2900; // 这种方式效率低。 +----------+--------+ | max(sal) | deptno | +----------+--------+ | 5000.00 | 10 | | 3000.00 | 20 | +----------+--------+ select max(sal),deptno from emp where sal &gt; 2900 group by deptno; // 效率较高，建议能够使用where过滤的尽量使用where。 +----------+--------+ | max(sal) | deptno | +----------+--------+ | 5000.00 | 10 | | 3000.00 | 20 | +----------+--------+ 找出每个部门的平均薪资，要求显示薪资大于2000的数据。 第一步：找出每个部门的平均薪资 select deptno,avg(sal) from emp group by deptno; +--------+-------------+ | deptno | avg(sal) | +--------+-------------+ | 10 | 2916.666667 | | 20 | 2175.000000 | | 30 | 1566.666667 | +--------+-------------+ 第二步：要求显示薪资大于2000的数据 select deptno,avg(sal) from emp group by deptno having avg(sal) &gt; 2000; +--------+-------------+ | deptno | avg(sal) | +--------+-------------+ | 10 | 2916.666667 | | 20 | 2175.000000 | +--------+-------------+ where后面不能使用分组函数： select deptno,avg(sal) from emp where avg(sal) &gt; 2000 group by deptno; // 错误了。 这种情况只能使用having过滤。 17、总结一个完整的DQL语句怎么写？ select 5 .. from 1 .. where 2 .. group by 3 .. having 4 .. order by 6 .. 第二个部分 1、关于查询结果集的去重？ 12345678910mysql&gt; select distinct job from emp; // distinct关键字去除重复记录。+-----------+| job |+-----------+| CLERK || SALESMAN || MANAGER || ANALYST || PRESIDENT |+-----------+ 123456789101112131415161718mysql&gt; select ename,distinct job from emp;以上的sql语句是错误的。记住：distinct只能出现在所有字段的最前面。mysql&gt; select distinct deptno,job from emp;+--------+-----------+| deptno | job |+--------+-----------+| 20 | CLERK || 30 | SALESMAN || 20 | MANAGER || 30 | MANAGER || 10 | MANAGER || 20 | ANALYST || 10 | PRESIDENT || 30 | CLERK || 10 | CLERK |+--------+-----------+ 案例：统计岗位的数量？ 123456select count(distinct job) from emp;+---------------------+| count(distinct job) |+---------------------+| 5 |+---------------------+ 2、连接查询 2.1、什么是连接查询？ 12345678910 在实际开发中，大部分的情况下都不是从单表中查询数据，一般都是多张表联合查询取出最终的结果。 在实际开发中，一般一个业务都会对应多张表，比如：学生和班级，起码两张表。 stuno stuname classno classname----------------------------------------------------------------------------------- 1 zs 1 北京大兴区亦庄经济技术开发区第二中学高三1班 2 ls 1 北京大兴区亦庄经济技术开发区第二中学高三1班 ... 学生和班级信息存储到一张表中，结果就像上面一样，数据会存在大量的重复，导致数据的冗余。 2.2、连接查询的分类？ 根据语法出现的年代来划分的话，包括： SQL92（一些老的DBA可能还在使用这种语法。DBA：DataBase Administrator，数据库管理员） SQL99（比较新的语法） 根据表的连接方式来划分，包括： 内连接： 等值连接 非等值连接 自连接 外连接： 左外连接（左连接） 右外连接（右连接） 全连接（这个不讲，很少用！） 2.3、在表的连接查询方面有一种现象被称为：笛卡尔积现象。（笛卡尔乘积现象） 案例：找出每一个员工的部门名称，要求显示员工名和部门名。 EMP表 123456789101112131415161718+--------+--------+| ename | deptno |+--------+--------+| SMITH | 20 || ALLEN | 30 || WARD | 30 || JONES | 20 || MARTIN | 30 || BLAKE | 30 || CLARK | 10 || SCOTT | 20 || KING | 10 || TURNER | 30 || ADAMS | 20 || JAMES | 30 || FORD | 20 || MILLER | 10 |+--------+--------+ DEPT表 12345678+--------+------------+----------+| DEPTNO | DNAME | LOC |+--------+------------+----------+| 10 | ACCOUNTING | NEW YORK || 20 | RESEARCH | DALLAS || 30 | SALES | CHICAGO || 40 | OPERATIONS | BOSTON |+--------+------------+----------+ 1234567891011121314select ename,dname from emp,dept;+--------+------------+| ename | dname |+--------+------------+| SMITH | ACCOUNTING || SMITH | RESEARCH || SMITH | SALES || SMITH | OPERATIONS || ALLEN | ACCOUNTING || ALLEN | RESEARCH || ALLEN | SALES || ALLEN | OPERATIONS |............56 rows in set (0.00 sec) 笛卡尔积现象：当两张表进行连接查询的时候，没有任何条件进行限制，最终的查询结果条数是两张表记录条数的乘积。 关于表的别名： 1234select e.ename,d.dname from emp e,dept d;表的别名有什么好处？ 第一：执行效率高。 第二：可读性好。 2.4、怎么避免笛卡尔积现象？当然是加条件进行过滤。 思考：避免了笛卡尔积现象，会减少记录的匹配次数吗？ 不会，次数还是56次。只不过显示的是有效记录。 案例：找出每一个员工的部门名称，要求显示员工名和部门名。 select e.ename,d.dname from emp e , dept d where e.deptno = d.deptno; //SQL92，以后不用。 +--------+------------+ | ename | dname | +--------+------------+ | CLARK | ACCOUNTING | | KING | ACCOUNTING | | MILLER | ACCOUNTING | | SMITH | RESEARCH | | JONES | RESEARCH | | SCOTT | RESEARCH | | ADAMS | RESEARCH | | FORD | RESEARCH | | ALLEN | SALES | | WARD | SALES | | MARTIN | SALES | | BLAKE | SALES | | TURNER | SALES | | JAMES | SALES | +--------+------------+ 2.5、内连接之等值连接：最大特点是：条件是等量关系。 案例：查询每个员工的部门名称，要求显示员工名和部门名。 SQL92:（太老，不用了） select e.ename,d.dname from emp e, dept d where e.deptno = d.deptno; SQL99：（常用的） select e.ename,d.dname from emp e join dept d on e.deptno = d.deptno; // inner可以省略的，带着inner目的是可读性好一些。 select e.ename,d.dname from emp e inner join dept d on e.deptno = d.deptno; 语法： ... A join B on 连接条件 where ... SQL99语法结构更清晰一些：表的连接条件和后来的where条件分离了。 +--------+------------+ | ename | dname | +--------+------------+ | CLARK | ACCOUNTING | | KING | ACCOUNTING | | MILLER | ACCOUNTING | | SMITH | RESEARCH | | JONES | RESEARCH | | SCOTT | RESEARCH | | ADAMS | RESEARCH | | FORD | RESEARCH | | ALLEN | SALES | | WARD | SALES | | MARTIN | SALES | | BLAKE | SALES | | TURNER | SALES | | JAMES | SALES | +--------+------------+ 2.6、内连接之非等值连接：最大的特点是：连接条件中的关系是非等量关系。 案例：找出每个员工的工资等级，要求显示员工名、工资、工资等级。 12345678910111213141516171819mysql&gt; select ename,sal from emp; e+--------+---------+| ename | sal |+--------+---------+| SMITH | 800.00 || ALLEN | 1600.00 || WARD | 1250.00 || JONES | 2975.00 || MARTIN | 1250.00 || BLAKE | 2850.00 || CLARK | 2450.00 || SCOTT | 3000.00 || KING | 5000.00 || TURNER | 1500.00 || ADAMS | 1100.00 || JAMES | 950.00 || FORD | 3000.00 || MILLER | 1300.00 |+--------+---------+ 12345678910mysql&gt; select * from salgrade; s+-------+-------+-------+ | GRADE | LOSAL | HISAL |+-------+-------+-------+| 1 | 700 | 1200 || 2 | 1201 | 1400 || 3 | 1401 | 2000 || 4 | 2001 | 3000 || 5 | 3001 | 9999 |+-------+-------+-------+ 12345678910111213141516171819202122232425262728293031323334353637select e.ename,e.sal,s.gradefrom emp ejoin salgrade son e.sal between s.losal and s.hisal;// inner可以省略select e.ename,e.sal,s.gradefrom emp einner join salgrade son e.sal between s.losal and s.hisal;+--------+---------+-------+| ename | sal | grade |+--------+---------+-------+| SMITH | 800.00 | 1 || ALLEN | 1600.00 | 3 || WARD | 1250.00 | 2 || JONES | 2975.00 | 4 || MARTIN | 1250.00 | 2 || BLAKE | 2850.00 | 4 || CLARK | 2450.00 | 4 || SCOTT | 3000.00 | 4 || KING | 5000.00 | 5 || TURNER | 1500.00 | 3 || ADAMS | 1100.00 | 1 || JAMES | 950.00 | 1 || FORD | 3000.00 | 4 || MILLER | 1300.00 | 2 |+--------+---------+-------+ 2.7、自连接：最大的特点是：一张表看做两张表。自己连接自己。 案例：找出每个员工的上级领导，要求显示员工名和对应的领导名。 12345678910111213141516171819202122232425262728293031mysql&gt; select empno,ename,mgr from emp;emp a 员工表+-------+--------+------+| empno | ename | mgr |+-------+--------+------+| 7369 | SMITH | 7902 || 7499 | ALLEN | 7698 || 7521 | WARD | 7698 || 7566 | JONES | 7839 || 7654 | MARTIN | 7698 || 7698 | BLAKE | 7839 || 7782 | CLARK | 7839 || 7788 | SCOTT | 7566 || 7839 | KING | NULL || 7844 | TURNER | 7698 || 7876 | ADAMS | 7788 || 7900 | JAMES | 7698 || 7902 | FORD | 7566 || 7934 | MILLER | 7782 |+-------+--------+------+emp b 领导表+-------+--------+| empno | ename |+-------+--------+| 7566 | JONES || 7698 | BLAKE || 7782 | CLARK || 7788 | SCOTT || 7839 | KING || 7902 | FORD |+-------+--------+ 员工的领导编号 = 领导的员工编号 1234567891011121314151617181920212223242526select a.ename as &#x27;员工名&#x27;,b.ename as &#x27;领导名&#x27;from emp ainner join emp bon a.mgr = b.empno;+--------+--------+| 员工名 | 领导名 |+--------+--------+| SMITH | FORD || ALLEN | BLAKE || WARD | BLAKE || JONES | KING || MARTIN | BLAKE || BLAKE | KING || CLARK | KING || SCOTT | JONES || TURNER | BLAKE || ADAMS | SCOTT || JAMES | BLAKE || FORD | JONES || MILLER | CLARK |+--------+--------+ 2.8、外连接？ 什么是外连接，和内连接有什么区别？ 内连接： 假设A和B表进行连接，使用内连接的话，凡是A表和B表能够匹配上的记录查询出来，这就是内连接。 AB两张表没有主副之分，两张表是平等的。 外连接： 假设A和B表进行连接，使用外连接的话，AB两张表中有一张表是主表，一张表是副表，主要查询主表中 的数据，捎带着查询副表，当副表中的数据没有和主表中的数据匹配上，副表自动模拟出NULL与之匹配。 外连接的分类？ 左外连接（左连接）：表示左边的这张表是主表。 右外连接（右连接）：表示右边的这张表是主表。 左连接有右连接的写法，右连接也会有对应的左连接的写法。 案例：找出每个员工的上级领导？（所有员工必须全部查询出来。） 123456789101112131415161718192021222324252627282930emp a 员工表+-------+--------+------+| empno | ename | mgr |+-------+--------+------+| 7369 | SMITH | 7902 || 7499 | ALLEN | 7698 || 7521 | WARD | 7698 || 7566 | JONES | 7839 || 7654 | MARTIN | 7698 || 7698 | BLAKE | 7839 || 7782 | CLARK | 7839 || 7788 | SCOTT | 7566 || 7839 | KING | NULL || 7844 | TURNER | 7698 || 7876 | ADAMS | 7788 || 7900 | JAMES | 7698 || 7902 | FORD | 7566 || 7934 | MILLER | 7782 |+-------+--------+------+emp b 领导表+-------+--------+| empno | ename |+-------+--------+| 7566 | JONES || 7698 | BLAKE || 7782 | CLARK || 7788 | SCOTT || 7839 | KING || 7902 | FORD |+-------+--------+ 内连接： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667select a.ename &#x27;员工&#x27;, b.ename &#x27;领导&#x27;from emp ajoin emp bon a.mgr = b.empno;外连接：（左外连接/左连接）select a.ename &#x27;员工&#x27;, b.ename &#x27;领导&#x27;from emp aleft join emp bon a.mgr = b.empno;// outer是可以省略的。select a.ename &#x27;员工&#x27;, b.ename &#x27;领导&#x27;from emp aleft outer join emp bon a.mgr = b.empno;外连接：（右外连接/右连接）select a.ename &#x27;员工&#x27;, b.ename &#x27;领导&#x27;from emp bright join emp aon a.mgr = b.empno;// outer可以省略。select a.ename &#x27;员工&#x27;, b.ename &#x27;领导&#x27;from emp bright outer join emp aon a.mgr = b.empno;+--------+-------+| 员工 | 领导 |+--------+-------+| SMITH | FORD || ALLEN | BLAKE || WARD | BLAKE || JONES | KING || MARTIN | BLAKE || BLAKE | KING || CLARK | KING || SCOTT | JONES || KING | NULL || TURNER | BLAKE || ADAMS | SCOTT || JAMES | BLAKE || FORD | JONES || MILLER | CLARK |+--------+-------+ 外连接最重要的特点是：主表的数据无条件的全部查询出来。 案例：找出哪个部门没有员工？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596EMP表+-------+--------+-----------+------+------------+---------+---------+--------+| EMPNO | ENAME | JOB | MGR | HIREDATE | SAL | COMM | DEPTNO |+-------+--------+-----------+------+------------+---------+---------+--------+| 7369 | SMITH | CLERK | 7902 | 1980-12-17 | 800.00 | NULL | 20 || 7499 | ALLEN | SALESMAN | 7698 | 1981-02-20 | 1600.00 | 300.00 | 30 || 7521 | WARD | SALESMAN | 7698 | 1981-02-22 | 1250.00 | 500.00 | 30 || 7566 | JONES | MANAGER | 7839 | 1981-04-02 | 2975.00 | NULL | 20 || 7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 | 1250.00 | 1400.00 | 30 || 7698 | BLAKE | MANAGER | 7839 | 1981-05-01 | 2850.00 | NULL | 30 || 7782 | CLARK | MANAGER | 7839 | 1981-06-09 | 2450.00 | NULL | 10 || 7788 | SCOTT | ANALYST | 7566 | 1987-04-19 | 3000.00 | NULL | 20 || 7839 | KING | PRESIDENT | NULL | 1981-11-17 | 5000.00 | NULL | 10 || 7844 | TURNER | SALESMAN | 7698 | 1981-09-08 | 1500.00 | 0.00 | 30 || 7876 | ADAMS | CLERK | 7788 | 1987-05-23 | 1100.00 | NULL | 20 || 7900 | JAMES | CLERK | 7698 | 1981-12-03 | 950.00 | NULL | 30 || 7902 | FORD | ANALYST | 7566 | 1981-12-03 | 3000.00 | NULL | 20 || 7934 | MILLER | CLERK | 7782 | 1982-01-23 | 1300.00 | NULL | 10 |+-------+--------+-----------+------+------------+---------+---------+--------+DEPT+--------+------------+----------+| DEPTNO | DNAME | LOC |+--------+------------+----------+| 10 | ACCOUNTING | NEW YORK || 20 | RESEARCH | DALLAS || 30 | SALES | CHICAGO || 40 | OPERATIONS | BOSTON |+--------+------------+----------+select d.*from emp eright join dept don e.deptno = d.deptnowhere e.empno is null;+--------+------------+--------+| DEPTNO | DNAME | LOC |+--------+------------+--------+| 40 | OPERATIONS | BOSTON |+--------+------------+--------+2.9、三张表怎么连接查询？案例：找出每一个员工的部门名称以及工资等级。EMP e+-------+--------+---------+--------+| empno | ename | sal | deptno |+-------+--------+---------+--------+| 7369 | SMITH | 800.00 | 20 || 7499 | ALLEN | 1600.00 | 30 || 7521 | WARD | 1250.00 | 30 || 7566 | JONES | 2975.00 | 20 || 7654 | MARTIN | 1250.00 | 30 || 7698 | BLAKE | 2850.00 | 30 || 7782 | CLARK | 2450.00 | 10 || 7788 | SCOTT | 3000.00 | 20 || 7839 | KING | 5000.00 | 10 || 7844 | TURNER | 1500.00 | 30 || 7876 | ADAMS | 1100.00 | 20 || 7900 | JAMES | 950.00 | 30 || 7902 | FORD | 3000.00 | 20 || 7934 | MILLER | 1300.00 | 10 |+-------+--------+---------+--------+DEPT d+--------+------------+----------+| DEPTNO | DNAME | LOC |+--------+------------+----------+| 10 | ACCOUNTING | NEW YORK || 20 | RESEARCH | DALLAS || 30 | SALES | CHICAGO || 40 | OPERATIONS | BOSTON |+--------+------------+----------+SALGRADE s+-------+-------+-------+| GRADE | LOSAL | HISAL |+-------+-------+-------+| 1 | 700 | 1200 || 2 | 1201 | 1400 || 3 | 1401 | 2000 || 4 | 2001 | 3000 || 5 | 3001 | 9999 |+-------+-------+-------+注意，解释一下： .... A join B join C on ... 表示：A表和B表先进行表连接，连接之后A表继续和C表进行连接。 select e.ename,d.dname,s.grade from emp e join dept d on e.deptno = d.deptno join salgrade s on e.sal between s.losal and s.hisal; +--------+------------+-------+ | ename | dname | grade | +--------+------------+-------+ | SMITH | RESEARCH | 1 | | ALLEN | SALES | 3 | | WARD | SALES | 2 | | JONES | RESEARCH | 4 | | MARTIN | SALES | 2 | | BLAKE | SALES | 4 | | CLARK | ACCOUNTING | 4 | | SCOTT | RESEARCH | 4 | | KING | ACCOUNTING | 5 | | TURNER | SALES | 3 | | ADAMS | RESEARCH | 1 | | JAMES | SALES | 1 | | FORD | RESEARCH | 4 | | MILLER | ACCOUNTING | 2 | +--------+------------+-------+ 案例：找出每一个员工的部门名称、工资等级、以及上级领导。 select e.ename '员工',d.dname,s.grade,e1.ename '领导' from emp e join dept d on e.deptno = d.deptno join salgrade s on e.sal between s.losal and s.hisal left join emp e1 on e.mgr = e1.empno; +--------+------------+-------+-------+ | 员工 | dname | grade | 领导 | +--------+------------+-------+-------+ | SMITH | RESEARCH | 1 | FORD | | ALLEN | SALES | 3 | BLAKE | | WARD | SALES | 2 | BLAKE | | JONES | RESEARCH | 4 | KING | | MARTIN | SALES | 2 | BLAKE | | BLAKE | SALES | 4 | KING | | CLARK | ACCOUNTING | 4 | KING | | SCOTT | RESEARCH | 4 | JONES | | KING | ACCOUNTING | 5 | NULL | | TURNER | SALES | 3 | BLAKE | | ADAMS | RESEARCH | 1 | SCOTT | | JAMES | SALES | 1 | BLAKE | | FORD | RESEARCH | 4 | JONES | | MILLER | ACCOUNTING | 2 | CLARK | +--------+------------+-------+-------+ 3、子查询 3.1、什么是子查询？子查询都可以出现在哪里？ select语句当中嵌套select语句，被嵌套的select语句是子查询。 子查询可以出现在哪里？ 123456select ..(select).from ..(select).where ..(select). 3.2、where子句中使用子查询 案例：找出高于平均薪资的员工信息。 1234567891011121314151617181920212223select * from emp where sal &gt; avg(sal); //错误的写法，where后面不能直接使用分组函数。第一步：找出平均薪资 select avg(sal) from emp; +-------------+ | avg(sal) | +-------------+ | 2073.214286 | +-------------+第二步：where过滤 select * from emp where sal &gt; 2073.214286; +-------+-------+-----------+------+------------+---------+------+--------+ | EMPNO | ENAME | JOB | MGR | HIREDATE | SAL | COMM | DEPTNO | +-------+-------+-----------+------+------------+---------+------+--------+ | 7566 | JONES | MANAGER | 7839 | 1981-04-02 | 2975.00 | NULL | 20 | | 7698 | BLAKE | MANAGER | 7839 | 1981-05-01 | 2850.00 | NULL | 30 | | 7782 | CLARK | MANAGER | 7839 | 1981-06-09 | 2450.00 | NULL | 10 | | 7788 | SCOTT | ANALYST | 7566 | 1987-04-19 | 3000.00 | NULL | 20 | | 7839 | KING | PRESIDENT | NULL | 1981-11-17 | 5000.00 | NULL | 10 | | 7902 | FORD | ANALYST | 7566 | 1981-12-03 | 3000.00 | NULL | 20 | +-------+-------+-----------+------+------------+---------+------+--------+第一步和第二步合并： select * from emp where sal &gt; (select avg(sal) from emp); 3.3、from后面嵌套子查询 案例：找出每个部门平均薪水的等级。 1234567891011121314151617181920212223242526第一步：找出每个部门平均薪水（按照部门编号分组，求sal的平均值）select deptno,avg(sal) as avgsal from emp group by deptno;+--------+-------------+| deptno | avgsal |+--------+-------------+| 10 | 2916.666667 || 20 | 2175.000000 || 30 | 1566.666667 |+--------+-------------+第二步：将以上的查询结果当做临时表t，让t表和salgrade s表连接，条件是：t.avgsal between s.losal and s.hisalselect t.*,s.gradefrom (select deptno,avg(sal) as avgsal from emp group by deptno) tjoin salgrade son t.avgsal between s.losal and s.hisal;+--------+-------------+-------+| deptno | avgsal | grade |+--------+-------------+-------+| 30 | 1566.666667 | 3 || 10 | 2916.666667 | 4 || 20 | 2175.000000 | 4 |+--------+-------------+-------+ 案例：找出每个部门平均的薪水等级。 123456789101112131415161718192021222324252627282930313233343536373839第一步：找出每个员工的薪水等级。select e.ename,e.sal,e.deptno,s.grade from emp e join salgrade s on e.sal between s.losal and s.hisal;+--------+---------+--------+-------+| ename | sal | deptno | grade |+--------+---------+--------+-------+| SMITH | 800.00 | 20 | 1 || ALLEN | 1600.00 | 30 | 3 || WARD | 1250.00 | 30 | 2 || JONES | 2975.00 | 20 | 4 || MARTIN | 1250.00 | 30 | 2 || BLAKE | 2850.00 | 30 | 4 || CLARK | 2450.00 | 10 | 4 || SCOTT | 3000.00 | 20 | 4 || KING | 5000.00 | 10 | 5 || TURNER | 1500.00 | 30 | 3 || ADAMS | 1100.00 | 20 | 1 || JAMES | 950.00 | 30 | 1 || FORD | 3000.00 | 20 | 4 || MILLER | 1300.00 | 10 | 2 |+--------+---------+--------+-------+第二步：基于以上结果，继续按照deptno分组，求grade平均值。select e.deptno,avg(s.grade)from emp e join salgrade s on e.sal between s.losal and s.hisalgroup by e.deptno;+--------+--------------+| deptno | avg(s.grade) |+--------+--------------+| 10 | 3.6667 || 20 | 2.8000 || 30 | 2.5000 |+--------+--------------+ 3.4、在select后面嵌套子查询。 案例：找出每个员工所在的部门名称，要求显示员工名和部门名。 1234567891011121314151617181920212223242526272829303132select e.ename,d.dnamefrom emp ejoin dept don e.deptno = d.deptno;select e.ename,(select d.dname from dept d where e.deptno = d.deptno) as dname from emp e;+--------+------------+| ename | dname |+--------+------------+| SMITH | RESEARCH || ALLEN | SALES || WARD | SALES || JONES | RESEARCH || MARTIN | SALES || BLAKE | SALES || CLARK | ACCOUNTING || SCOTT | RESEARCH || KING | ACCOUNTING || TURNER | SALES || ADAMS | RESEARCH || JAMES | SALES || FORD | RESEARCH || MILLER | ACCOUNTING |+--------+------------+ 4、union （可以将查询结果集相加） 案例：找出工作岗位是SALESMAN和MANAGER的员工？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061第一种：select ename,job from emp where job = &#x27;MANAGER&#x27; or job = &#x27;SALESMAN&#x27;;第二种：select ename,job from emp where job in(&#x27;MANAGER&#x27;,&#x27;SALESMAN&#x27;);+--------+----------+| ename | job |+--------+----------+| ALLEN | SALESMAN || WARD | SALESMAN || JONES | MANAGER || MARTIN | SALESMAN || BLAKE | MANAGER || CLARK | MANAGER || TURNER | SALESMAN |+--------+----------+第三种：unionselect ename,job from emp where job = &#x27;MANAGER&#x27;unionselect ename,job from emp where job = &#x27;SALESMAN&#x27;;+--------+----------+| ename | job |+--------+----------+| JONES | MANAGER || BLAKE | MANAGER || CLARK | MANAGER || ALLEN | SALESMAN || WARD | SALESMAN || MARTIN | SALESMAN || TURNER | SALESMAN |+--------+----------+两张不相干的表中的数据拼接在一起显示？select ename from empunionselect dname from dept;+------------+| ename |+------------+| SMITH || ALLEN || WARD || JONES || MARTIN || BLAKE || CLARK || SCOTT || KING || TURNER || ADAMS || JAMES || FORD || MILLER || ACCOUNTING || RESEARCH || SALES || OPERATIONS |+------------+mysql&gt; select ename,sal from emp -&gt; union -&gt; select dname from dept;ERROR 1222 (21000): The used SELECT statements have a different number of columns 5、limit (重点中的重点，以后分页查询全靠它了。) 5.1、limit是mysql特有的，其他数据库中没有，不通用。（Oracle中有一个相同的机制，叫做rownum） 5.2、limit取结果集中的部分数据，这时它的作用。 5.3、语法机制： limit startIndex, length startIndex表示起始位置，从0开始，0表示第一条数据。 length表示取几个 案例：取出工资前5名的员工（思路：降序取前5个） select ename,sal from emp order by sal desc; 取前5个： select ename,sal from emp order by sal desc limit 0, 5; select ename,sal from emp order by sal desc limit 5; 5.4、limit是sql语句最后执行的一个环节： 1234567891011121314select 5 ...from 1 ... where 2 ... group by 3 ...having 4 ...order by 6 ...limit 7 ...; 5.5、案例：找出工资排名在第4到第9名的员工？ 1234567891011select ename,sal from emp order by sal desc limit 3,6;+--------+---------+| ename | sal |+--------+---------+| JONES | 2975.00 || BLAKE | 2850.00 || CLARK | 2450.00 || ALLEN | 1600.00 || TURNER | 1500.00 || MILLER | 1300.00 |+--------+---------+ 5.6、通用的标准分页sql？ 每页显示3条记录： 第1页：0, 3 第2页：3, 3 第3页：6, 3 第4页：9, 3 第5页：12, 3 每页显示pageSize条记录： 第pageNo页：(pageNo - 1) * pageSize, pageSize pageSize是什么？是每页显示多少条记录 pageNo是什么？显示第几页 java代码&#123; int pageNo = 2; // 页码是2 int pageSize = 10; // 每页显示10条 limit (pageNo - 1) * pageSize, pageSize &#125; 6、创建表： 建表语句的语法格式： create table 表名( 字段名1 数据类型, 字段名2 数据类型, 字段名3 数据类型, .... ); 关于MySQL当中字段的数据类型？以下只说常见的 int 整数型(java中的int) bigint 长整型(java中的long) float 浮点型(java中的float double) char 定长字符串(String) varchar 可变长字符串(StringBuffer/StringBuilder) date 日期类型 （对应Java中的java.sql.Date类型） BLOB 二进制大对象（存储图片、视频等流媒体信息） Binary Large OBject （对应java中的Object） CLOB 字符大对象（存储较大文本，比如，可以存储4G的字符串。） Character Large OBject（对应java中的Object） ...... char和varchar怎么选择？ 在实际的开发中，当某个字段中的数据长度不发生改变的时候，是定长的，例如：性别、生日等都是采用char。 当一个字段的数据长度不确定，例如：简介、姓名等都是采用varchar。 BLOB和CLOB类型的使用？ 电影表: t_movie id(int) name(varchar) playtime(date/char) haibao(BLOB) history(CLOB) ---------------------------------------------------------------------------------------- 1 蜘蛛侠 2 3 表名在数据库当中一般建议以：t_或者tbl_开始。 创建学生表： 学生信息包括： 学号、姓名、性别、班级编号、生日 学号：bigint 姓名：varchar 性别：char 班级编号：int 生日：char create table t_student( no bigint, name varchar(255), sex char(1), classno varchar(255), birth char(10) ); 7、insert语句插入数据 语法格式： insert into 表名(字段名1,字段名2,字段名3,....) values(值1,值2,值3,....) 要求：字段的数量和值的数量相同，并且数据类型要对应相同。 insert into t_student(no,name,sex,classno,birth) values(1,'zhangsan','1','gaosan1ban'); ERROR 1136 (21S01): Column count doesn't match value count at row 1 insert into t_student(no,name,sex,classno,birth) values(1,'zhangsan','1','gaosan1ban', '1950-10-12'); mysql&gt; select * from t_student; +------+----------+------+------------+------------+ | no | name | sex | classno | birth | +------+----------+------+------------+------------+ | 1 | zhangsan | 1 | gaosan1ban | 1950-10-12 | +------+----------+------+------------+------------+ insert into t_student(name,sex,classno,birth,no) values('lisi','1','gaosan1ban', '1950-10-12',2); mysql&gt; select * from t_student; +------+----------+------+------------+------------+ | no | name | sex | classno | birth | +------+----------+------+------------+------------+ | 1 | zhangsan | 1 | gaosan1ban | 1950-10-12 | | 2 | lisi | 1 | gaosan1ban | 1950-10-12 | +------+----------+------+------------+------------+ insert into t_student(name) values('wangwu'); // 除name字段之外，剩下的所有字段自动插入NULL。 mysql&gt; select * from t_student; +------+----------+------+------------+------------+ | no | name | sex | classno | birth | +------+----------+------+------------+------------+ | 1 | zhangsan | 1 | gaosan1ban | 1950-10-12 | | 2 | lisi | 1 | gaosan1ban | 1950-10-12 | | NULL | wangwu | NULL | NULL | NULL | +------+----------+------+------------+------------+ insert into t_student(no) values(3); mysql&gt; select * from t_student; +------+----------+------+------------+------------+ | no | name | sex | classno | birth | +------+----------+------+------------+------------+ | 1 | zhangsan | 1 | gaosan1ban | 1950-10-12 | | 2 | lisi | 1 | gaosan1ban | 1950-10-12 | | NULL | wangwu | NULL | NULL | NULL | | 3 | NULL | NULL | NULL | NULL | +------+----------+------+------------+------------+ drop table if exists t_student; // 当这个表存在的话删除。 create table t_student( no bigint, name varchar(255), sex char(1) default 1, classno varchar(255), birth char(10) ); insert into t_student(name) values('zhangsan'); mysql&gt; select * from t_student; +------+----------+------+---------+-------+ | no | name | sex | classno | birth | +------+----------+------+---------+-------+ | NULL | zhangsan | 1 | NULL | NULL | +------+----------+------+---------+-------+ 需要注意的地方： 当一条insert语句执行成功之后，表格当中必然会多一行记录。 即使多的这一行记录当中某些字段是NULL，后期也没有办法在执行 insert语句插入数据了，只能使用update进行更新。 // 字段可以省略不写，但是后面的value对数量和顺序都有要求。 insert into t_student values(1,'jack','0','gaosan2ban','1986-10-23'); mysql&gt; select * from t_student; +------+----------+------+------------+------------+ | no | name | sex | classno | birth | +------+----------+------+------------+------------+ | NULL | zhangsan | 1 | NULL | NULL | | 1 | jack | 0 | gaosan2ban | 1986-10-23 | +------+----------+------+------------+------------+ insert into t_student values(1,'jack','0','gaosan2ban'); ERROR 1136 (21S01): Column count doesn't match value count at row 1 // 一次插入多行数据 insert into t_student (no,name,sex,classno,birth) values (3,'rose','1','gaosi2ban','1952-12-14'),(4,'laotie','1','gaosi2ban','1955-12-14'); mysql&gt; select * from t_student; +------+----------+------+------------+------------+ | no | name | sex | classno | birth | +------+----------+------+------------+------------+ | NULL | zhangsan | 1 | NULL | NULL | | 1 | jack | 0 | gaosan2ban | 1986-10-23 | | 3 | rose | 1 | gaosi2ban | 1952-12-14 | | 4 | laotie | 1 | gaosi2ban | 1955-12-14 | +------+----------+------+------------+------------+ 8、表的复制 123语法： create table 表名 as select语句; 将查询结果当做表创建出来。 9、将查询结果插入到一张表中？ 1234567891011121314mysql&gt; insert into dept1 select * from dept;mysql&gt; select * from dept1;+--------+------------+----------+| DEPTNO | DNAME | LOC |+--------+------------+----------+| 10 | ACCOUNTING | NEW YORK || 20 | RESEARCH | DALLAS || 30 | SALES | CHICAGO || 40 | OPERATIONS | BOSTON || 10 | ACCOUNTING | NEW YORK || 20 | RESEARCH | DALLAS || 30 | SALES | CHICAGO || 40 | OPERATIONS | BOSTON |+--------+------------+----------+ 10、修改数据：update 语法格式： update 表名 set 字段名1=值1,字段名2=值2... where 条件; 注意：没有条件整张表数据全部更新。 案例：将部门10的LOC修改为SHANGHAI，将部门名称修改为RENSHIBU update dept1 set loc = 'SHANGHAI', dname = 'RENSHIBU' where deptno = 10; mysql&gt; select * from dept1; +--------+------------+----------+ | DEPTNO | DNAME | LOC | +--------+------------+----------+ | 10 | RENSHIBU | SHANGHAI | | 20 | RESEARCH | DALLAS | | 30 | SALES | CHICAGO | | 40 | OPERATIONS | BOSTON | | 10 | RENSHIBU | SHANGHAI | | 20 | RESEARCH | DALLAS | | 30 | SALES | CHICAGO | | 40 | OPERATIONS | BOSTON | +--------+------------+----------+ 更新所有记录 update dept1 set loc = 'x', dname = 'y'; mysql&gt; select * from dept1; +--------+-------+------+ | DEPTNO | DNAME | LOC | +--------+-------+------+ | 10 | y | x | | 20 | y | x | | 30 | y | x | | 40 | y | x | | 10 | y | x | | 20 | y | x | | 30 | y | x | | 40 | y | x | +--------+-------+------+ 11、删除数据？ 语法格式： delete from 表名 where 条件; 语法格式： delete from 表名 where 条件; 注意：没有条件全部删除。 删除10部门数据？ delete from dept1 where deptno = 10; 删除所有记录？ delete from dept1; 怎么删除大表中的数据？（重点） truncate table 表名; // 表被截断，不可回滚。永久丢失。 删除表？ drop table 表名; // 这个通用。 drop table if exists 表名; // oracle不支持这种写法。 12、对于表结构的修改，这里不讲了，大家使用工具完成即可，因为在实际开发中表一旦 设计好之后，对表结构的修改是很少的，修改表结构就是对之前的设计进行了否定，即使 需要修改表结构，我们也可以直接使用工具操作。修改表结构的语句不会出现在Java代码当中。 出现在java代码当中的sql包括：insert delete update select（这些都是表中的数据操作。） 增删改查有一个术语：CRUD操作 Create（增） Retrieve（检索） Update（修改） Delete（删除） 13、约束(Constraint) 13.1、什么是约束？常见的约束有哪些呢？ 在创建表的时候，可以给表的字段添加相应的约束，添加约束的目的是为了保证表中数据的 合法性、有效性、完整性。 常见的约束有哪些呢？ 非空约束(not null)：约束的字段不能为NULL 唯一约束(unique)：约束的字段不能重复 主键约束(primary key)：约束的字段既不能为NULL，也不能重复（简称PK） 外键约束(foreign key)：…（简称FK） 检查约束(check)：注意Oracle数据库有check约束，但是mysql没有，目前mysql不支持该约束。 13.2、非空约束 not null drop table if exists t_user; create table t_user( id int, username varchar(255) not null, password varchar(255) ); insert into t_user(id,password) values(1,'123'); ERROR 1364 (HY000): Field 'username' doesn't have a default value insert into t_user(id,username,password) values(1,'lisi','123'); 第三部分 1、约束 1.1、唯一性约束（unique） * 唯一约束修饰的字段具有唯一性，不能重复。但可以为NULL。 * 案例：给某一列添加unique drop table if exists t_user; create table t_user( id int, username varchar(255) unique // 列级约束 ); insert into t_user values(1,'zhangsan'); insert into t_user values(2,'zhangsan'); ERROR 1062 (23000): Duplicate entry 'zhangsan' for key 'username' insert into t_user(id) values(2); insert into t_user(id) values(3); insert into t_user(id) values(4); * 案例：给两个列或者多个列添加unique drop table if exists t_user; create table t_user( id int, usercode varchar(255), username varchar(255), unique(usercode,username) // 多个字段联合起来添加1个约束unique 【表级约束】 ); insert into t_user values(1,'111','zs'); insert into t_user values(2,'111','ls'); insert into t_user values(3,'222','zs'); select * from t_user; insert into t_user values(4,'111','zs'); ERROR 1062 (23000): Duplicate entry '111-zs' for key 'usercode' drop table if exists t_user; create table t_user( id int, usercode varchar(255) unique, username varchar(255) unique ); insert into t_user values(1,'111','zs'); insert into t_user values(2,'111','ls'); ERROR 1062 (23000): Duplicate entry '111' for key 'usercode' * 注意：not null约束只有列级约束。没有表级约束。 1.2、主键约束 * 怎么给一张表添加主键约束呢？ drop table if exists t_user; create table t_user( id int primary key, // 列级约束 username varchar(255), email varchar(255) ); insert into t_user(id,username,email) values(1,'zs','zs@123.com'); insert into t_user(id,username,email) values(2,'ls','ls@123.com'); insert into t_user(id,username,email) values(3,'ww','ww@123.com'); select * from t_user; +----+----------+------------+ | id | username | email | +----+----------+------------+ | 1 | zs | zs@123.com | | 2 | ls | ls@123.com | | 3 | ww | ww@123.com | +----+----------+------------+ insert into t_user(id,username,email) values(1,'jack','jack@123.com'); ERROR 1062 (23000): Duplicate entry '1' for key 'PRIMARY' insert into t_user(username,email) values('jack','jack@123.com'); ERROR 1364 (HY000): Field 'id' doesn't have a default value 根据以上的测试得出：id是主键，因为添加了主键约束，主键字段中的数据不能为NULL，也不能重复。 主键的特点：不能为NULL，也不能重复。 * 主键相关的术语？ 主键约束 : primary key 主键字段 : id字段添加primary key之后，id叫做主键字段 主键值 : id字段中的每一个值都是主键值。 * 主键有什么作用？ - 表的设计三范式中有要求，第一范式就要求任何一张表都应该有主键。 - 主键的作用：主键值是这行记录在这张表当中的唯一标识。（就像一个人的身份证号码一样。） * 主键的分类？ 根据主键字段的字段数量来划分： 单一主键（推荐的，常用的。） 复合主键(多个字段联合起来添加一个主键约束)（复合主键不建议使用，因为复合主键违背三范式。） 根据主键性质来划分： 自然主键：主键值最好就是一个和业务没有任何关系的自然数。（这种方式是推荐的） 业务主键：主键值和系统的业务挂钩，例如：拿着银行卡的卡号做主键，拿着身份证号码作为主键。（不推荐用） 最好不要拿着和业务挂钩的字段作为主键。因为以后的业务一旦发生改变的时候，主键值可能也需要 随着发生变化，但有的时候没有办法变化，因为变化可能会导致主键值重复。 * 一张表的主键约束只能有1个。（必须记住） * 使用表级约束方式定义主键： drop table if exists t_user; create table t_user( id int, username varchar(255), primary key(id) ); insert into t_user(id,username) values(1,'zs'); insert into t_user(id,username) values(2,'ls'); insert into t_user(id,username) values(3,'ws'); insert into t_user(id,username) values(4,'cs'); select * from t_user; insert into t_user(id,username) values(4,'cx'); ERROR 1062 (23000): Duplicate entry '4' for key 'PRIMARY' 以下内容是演示以下复合主键，不需要掌握： drop table if exists t_user; create table t_user( id int, username varchar(255), password varchar(255), primary key(id,username) ); insert ....... * mysql提供主键值自增：（非常重要。） drop table if exists t_user; create table t_user( id int primary key auto_increment, // id字段自动维护一个自增的数字，从1开始，以1递增。 username varchar(255) ); insert into t_user(username) values('a'); insert into t_user(username) values('b'); insert into t_user(username) values('c'); insert into t_user(username) values('d'); insert into t_user(username) values('e'); insert into t_user(username) values('f'); select * from t_user; 提示:Oracle当中也提供了一个自增机制，叫做：序列（sequence）对象。 1.3、外键约束 * 关于外键约束的相关术语： 外键约束: foreign key 外键字段：添加有外键约束的字段 外键值：外键字段中的每一个值。 * 业务背景： 请设计数据库表，用来维护学生和班级的信息？ 第一种方案：一张表存储所有数据 no(pk) name classno classname ------------------------------------------------------------------------------------------- 1 zs1 101 北京大兴区经济技术开发区亦庄二中高三1班 2 zs2 101 北京大兴区经济技术开发区亦庄二中高三1班 3 zs3 102 北京大兴区经济技术开发区亦庄二中高三2班 4 zs4 102 北京大兴区经济技术开发区亦庄二中高三2班 5 zs5 102 北京大兴区经济技术开发区亦庄二中高三2班 缺点：冗余。【不推荐】 第二种方案：两张表（班级表和学生表） t_class 班级表 cno(pk) cname -------------------------------------------------------- 101 北京大兴区经济技术开发区亦庄二中高三1班 102 北京大兴区经济技术开发区亦庄二中高三2班 t_student 学生表 sno(pk) sname classno(该字段添加外键约束fk) ------------------------------------------------------------ 1 zs1 101 2 zs2 101 3 zs3 102 4 zs4 102 5 zs5 102 * 将以上表的建表语句写出来： t_student中的classno字段引用t_class表中的cno字段，此时t_student表叫做子表。t_class表叫做父表。 顺序要求： 删除数据的时候，先删除子表，再删除父表。 添加数据的时候，先添加父表，在添加子表。 创建表的时候，先创建父表，再创建子表。 删除表的时候，先删除子表，在删除父表。 drop table if exists t_student; drop table if exists t_class; create table t_class( cno int, cname varchar(255), primary key(cno) ); create table t_student( sno int, sname varchar(255), classno int, primary key(sno), foreign key(classno) references t_class(cno) ); insert into t_class values(101,'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'); insert into t_class values(102,'yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy'); insert into t_student values(1,'zs1',101); insert into t_student values(2,'zs2',101); insert into t_student values(3,'zs3',102); insert into t_student values(4,'zs4',102); insert into t_student values(5,'zs5',102); insert into t_student values(6,'zs6',102); select * from t_class; select * from t_student; insert into t_student values(7,'lisi',103); ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (`bjpowernode`.INT `t_student_ibfk_1` FOREIGN KEY (`classno`) REFERENCES `t_class` (`cno`)) * 外键值可以为NULL？ 外键可以为NULL。 * 外键字段引用其他表的某个字段的时候，被引用的字段必须是主键吗？ 注意：被引用的字段不一定是主键，但至少具有unique约束。 2、存储引擎？（整个内容属于了解内容） 2.1、完整的建表语句 CREATE TABLE `t_x` ( `id` int(11) DEFAULT NULL ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 注意：在MySQL当中，凡是标识符是可以使用飘号括起来的。最好别用，不通用。 建表的时候可以指定存储引擎，也可以指定字符集。 mysql默认使用的存储引擎是InnoDB方式。 默认采用的字符集是UTF8 2.2、什么是存储引擎呢？ 存储引擎这个名字只有在mysql中存在。（Oracle中有对应的机制，但是不叫做存储引擎。Oracle中没有特殊的名字， 就是“表的存储方式”） mysql支持很多存储引擎，每一个存储引擎都对应了一种不同的存储方式。 每一个存储引擎都有自己的优缺点，需要在合适的时机选择合适的存储引擎。 2.3、查看当前mysql支持的存储引擎？ show engines \\G mysql 5.5.36版本支持的存储引擎有9个： *************************** 1. row *************************** Engine: FEDERATED Support: NO Comment: Federated MySQL storage engine Transactions: NULL XA: NULL Savepoints: NULL *************************** 2. row *************************** Engine: MRG_MYISAM Support: YES Comment: Collection of identical MyISAM tables Transactions: NO XA: NO Savepoints: NO *************************** 3. row *************************** Engine: MyISAM Support: YES Comment: MyISAM storage engine Transactions: NO XA: NO Savepoints: NO *************************** 4. row *************************** Engine: BLACKHOLE Support: YES Comment: /dev/null storage engine (anything you write to it disappears) Transactions: NO XA: NO Savepoints: NO *************************** 5. row *************************** Engine: CSV Support: YES Comment: CSV storage engine Transactions: NO XA: NO Savepoints: NO *************************** 6. row *************************** Engine: MEMORY Support: YES Comment: Hash based, stored in memory, useful for temporary tables Transactions: NO XA: NO Savepoints: NO *************************** 7. row *************************** Engine: ARCHIVE Support: YES Comment: Archive storage engine Transactions: NO XA: NO Savepoints: NO *************************** 8. row *************************** Engine: InnoDB Support: DEFAULT Comment: Supports transactions, row-level locking, and foreign keys Transactions: YES XA: YES Savepoints: YES *************************** 9. row *************************** Engine: PERFORMANCE_SCHEMA Support: YES Comment: Performance Schema Transactions: NO XA: NO Savepoints: NO 2.4、常见的存储引擎？ Engine: MyISAM Support: YES Comment: MyISAM storage engine Transactions: NO XA: NO Savepoints: NO MyISAM这种存储引擎不支持事务。 MyISAM是mysql最常用的存储引擎，但是这种引擎不是默认的。 MyISAM采用三个文件组织一张表： xxx.frm（存储格式的文件） xxx.MYD（存储表中数据的文件） xxx.MYI（存储表中索引的文件） 优点：可被压缩，节省存储空间。并且可以转换为只读表，提高检索效率。 缺点：不支持事务。 ----------------------------------------------------------------------------- Engine: InnoDB Support: DEFAULT Comment: Supports transactions, row-level locking, and foreign keys Transactions: YES XA: YES Savepoints: YES 优点：支持事务、行级锁、外键等。这种存储引擎数据的安全得到保障。 表的结构存储在xxx.frm文件中 数据存储在tablespace这样的表空间中（逻辑概念），无法被压缩，无法转换成只读。 这种InnoDB存储引擎在MySQL数据库崩溃之后提供自动恢复机制。 InnoDB支持级联删除和级联更新。 ------------------------------------------------------------------------------------- Engine: MEMORY Support: YES Comment: Hash based, stored in memory, useful for temporary tables Transactions: NO XA: NO Savepoints: NO 缺点：不支持事务。数据容易丢失。因为所有数据和索引都是存储在内存当中的。 优点：查询速度最快。 以前叫做HEPA引擎。 3、事务（Transaction） 3.1、什么是事务？ 一个事务是一个完整的业务逻辑单元，不可再分。 比如：银行账户转账，从A账户向B账户转账10000.需要执行两条update语句： update t_act set balance = balance - 10000 where actno = 'act-001'; update t_act set balance = balance + 10000 where actno = 'act-002'; 以上两条DML语句必须同时成功，或者同时失败，不允许出现一条成功，一条失败。 要想保证以上的两条DML语句同时成功或者同时失败，那么就需要使用数据库的“事务机制”。 3.2、和事务相关的语句只有：DML语句。（insert delete update） 为什么？因为它们这三个语句都是和数据库表当中的“数据”相关的。 事务的存在是为了保证数据的完整性，安全性。 3.3、假设所有的业务都能使用1条DML语句搞定，还需要事务机制吗？ 不需要事务。 但实际情况不是这样的，通常一个“事儿（事务【业务】）”需要多条DML语句共同联合完成。 3.4、事务的特性？ 事务包括四大特性：ACID A: 原子性：事务是最小的工作单元，不可再分。 C: 一致性：事务必须保证多条DML语句同时成功或者同时失败。 I：隔离性：事务A与事务B之间具有隔离。 D：持久性：持久性说的是最终数据必须持久化到硬盘文件中，事务才算成功的结束。 3.5、关于事务之间的隔离性 事务隔离性存在隔离级别，理论上隔离级别包括4个： 第一级别：读未提交（read uncommitted） 对方事务还没有提交，我们当前事务可以读取到对方未提交的数据。 读未提交存在脏读（Dirty Read）现象：表示读到了脏的数据。 第二级别：读已提交（read committed） 对方事务提交之后的数据我方可以读取到。 这种隔离级别解决了: 脏读现象没有了。 读已提交存在的问题是：不可重复读。 第三级别：可重复读（repeatable read） 这种隔离级别解决了：不可重复读问题。 这种隔离级别存在的问题是：读取到的数据是幻象。 第四级别：序列化读/串行化读（serializable） 解决了所有问题。 效率低。需要事务排队。 oracle数据库默认的隔离级别是：读已提交。 mysql数据库默认的隔离级别是：可重复读。 3.6、演示事务 * mysql事务默认情况下是自动提交的。 （什么是自动提交？只要执行任意一条DML语句则提交一次。）怎么关闭自动提交？start transaction; * 准备表： drop table if exists t_user; create table t_user( id int primary key auto_increment, username varchar(255) ); * 演示：mysql中的事务是支持自动提交的，只要执行一条DML，则提交一次。 mysql&gt; insert into t_user(username) values('zs'); Query OK, 1 row affected (0.03 sec) mysql&gt; select * from t_user; +----+----------+ | id | username | +----+----------+ | 1 | zs | +----+----------+ 1 row in set (0.00 sec) mysql&gt; rollback; Query OK, 0 rows affected (0.00 sec) mysql&gt; select * from t_user; +----+----------+ | id | username | +----+----------+ | 1 | zs | +----+----------+ 1 row in set (0.00 sec) * 演示：使用start transaction;关闭自动提交机制。 mysql&gt; start transaction; Query OK, 0 rows affected (0.00 sec) mysql&gt; insert into t_user(username) values('lisi'); Query OK, 1 row affected (0.00 sec) mysql&gt; select * from t_user; +----+----------+ | id | username | +----+----------+ | 1 | zs | | 2 | lisi | +----+----------+ 2 rows in set (0.00 sec) mysql&gt; insert into t_user(username) values('wangwu'); Query OK, 1 row affected (0.00 sec) mysql&gt; select * from t_user; +----+----------+ | id | username | +----+----------+ | 1 | zs | | 2 | lisi | | 3 | wangwu | +----+----------+ 3 rows in set (0.00 sec) mysql&gt; rollback; Query OK, 0 rows affected (0.02 sec) mysql&gt; select * from t_user; +----+----------+ | id | username | +----+----------+ | 1 | zs | +----+----------+ 1 row in set (0.00 sec) -------------------------------------------------------------------- mysql&gt; start transaction; Query OK, 0 rows affected (0.00 sec) mysql&gt; insert into t_user(username) values('wangwu'); Query OK, 1 row affected (0.00 sec) mysql&gt; insert into t_user(username) values('rose'); Query OK, 1 row affected (0.00 sec) mysql&gt; insert into t_user(username) values('jack'); Query OK, 1 row affected (0.00 sec) mysql&gt; select * from t_user; +----+----------+ | id | username | +----+----------+ | 1 | zs | | 4 | wangwu | | 5 | rose | | 6 | jack | +----+----------+ 4 rows in set (0.00 sec) mysql&gt; commit; Query OK, 0 rows affected (0.04 sec) mysql&gt; select * from t_user; +----+----------+ | id | username | +----+----------+ | 1 | zs | | 4 | wangwu | | 5 | rose | | 6 | jack | +----+----------+ 4 rows in set (0.00 sec) mysql&gt; rollback; Query OK, 0 rows affected (0.00 sec) mysql&gt; select * from t_user; +----+----------+ | id | username | +----+----------+ | 1 | zs | | 4 | wangwu | | 5 | rose | | 6 | jack | +----+----------+ 4 rows in set (0.00 sec) * 演示两个事务，假如隔离级别 演示第1级别：读未提交 set global transaction isolation level read uncommitted; 演示第2级别：读已提交 set global transaction isolation level read committed; 演示第3级别：可重复读 set global transaction isolation level repeatable read; * mysql远程登录：mysql -h192.168.151.18 -uroot -p444 4、索引 4.1、什么是索引？有什么用？ 索引就相当于一本书的目录，通过目录可以快速的找到对应的资源。 在数据库方面，查询一张表的时候有两种检索方式： 第一种方式：全表扫描 第二种方式：根据索引检索（效率很高） 索引为什么可以提高检索效率呢？ 其实最根本的原理是缩小了扫描的范围。 索引虽然可以提高检索效率，但是不能随意的添加索引，因为索引也是数据库当中 的对象，也需要数据库不断的维护。是有维护成本的。比如，表中的数据经常被修改 这样就不适合添加索引，因为数据一旦修改，索引需要重新排序，进行维护。 添加索引是给某一个字段，或者说某些字段添加索引。 select ename,sal from emp where ename = 'SMITH'; 当ename字段上没有添加索引的时候，以上sql语句会进行全表扫描，扫描ename字段中所有的值。 当ename字段上添加索引的时候，以上sql语句会根据索引扫描，快速定位。 4.2、怎么创建索引对象？怎么删除索引对象？ 创建索引对象： create index 索引名称 on 表名(字段名); 删除索引对象： drop index 索引名称 on 表名; 4.3、什么时候考虑给字段添加索引？（满足什么条件） * 数据量庞大。（根据客户的需求，根据线上的环境） * 该字段很少的DML操作。（因为字段进行修改操作，索引也需要维护） * 该字段经常出现在where子句中。（经常根据哪个字段查询） 4.4、注意：主键和具有unique约束的字段自动会添加索引。 根据主键查询效率较高。尽量根据主键检索。 4.5、查看sql语句的执行计划： mysql&gt; explain select ename,sal from emp where sal = 5000; +----+-------------+-------+------+---------------+------+---------+------+------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | +----+-------------+-------+------+---------------+------+---------+------+------+ | 1 | SIMPLE | emp | ALL | NULL | NULL | NULL | NULL | 14 | +----+-------------+-------+------+---------------+------+---------+------+------+ +-------------+ | Extra | +-------------+ | Using where | +-------------+ 给薪资sal字段添加索引： create index emp_sal_index on emp(sal); mysql&gt; explain select ename,sal from emp where sal = 5000; +----+-------------+-------+------+---------------+---------------+---------+-------+ | id | select_type | table | type | possible_keys | key | key_len | ref | +----+-------------+-------+------+---------------+---------------+---------+-------+ | 1 | SIMPLE | emp | ref | emp_sal_index | emp_sal_index | 9 | const | +----+-------------+-------+------+---------------+---------------+---------+-------+ +------+-------------+ | rows | Extra | +------+-------------+ | 1 | Using where | +------+-------------+ 4.6、索引底层采用的数据结构是：B + Tree 4.7、索引的实现原理？ 通过B Tree缩小扫描范围，底层索引进行了排序，分区，索引会携带数据在表中的“物理地址”， 最终通过索引检索到数据之后，获取到关联的物理地址，通过物理地址定位表中的数据，效率 是最高的。 select ename from emp where ename = 'SMITH'; 通过索引转换为： select ename from emp where 物理地址 = 0x3; 4.8、索引的分类？ 单一索引：给单个字段添加索引 复合索引: 给多个字段联合起来添加1个索引 主键索引：主键上会自动添加索引 唯一索引：有unique约束的字段上会自动添加索引 .... 4.9、索引什么时候失效？ select ename from emp where ename like '%A%'; 模糊查询的时候，第一个通配符使用的是%，这个时候索引是失效的。 5、视图(view) 5.1、什么是视图？ 站在不同的角度去看到数据。（同一张表的数据，通过不同的角度去看待）。 5.2、怎么创建视图？怎么删除视图？ create view myview as select empno,ename from emp; drop view myview; 注意：只有DQL语句才能以视图对象的方式创建出来。 5.3、对视图进行增删改查，会影响到原表数据。（通过视图影响原表数据的，不是直接操作的原表） 可以对视图进行CRUD操作。 5.4、面向视图操作？ mysql&gt; select * from myview; +-------+--------+ | empno | ename | +-------+--------+ | 7369 | SMITH | | 7499 | ALLEN | | 7521 | WARD | | 7566 | JONES | | 7654 | MARTIN | | 7698 | BLAKE | | 7782 | CLARK | | 7788 | SCOTT | | 7839 | KING | | 7844 | TURNER | | 7876 | ADAMS | | 7900 | JAMES | | 7902 | FORD | | 7934 | MILLER | +-------+--------+ create table emp_bak as select * from emp; create view myview1 as select empno,ename,sal from emp_bak; update myview1 set ename='hehe',sal=1 where empno = 7369; // 通过视图修改原表数据。 delete from myview1 where empno = 7369; // 通过视图删除原表数据。 5.5、视图的作用？ 视图可以隐藏表的实现细节。保密级别较高的系统，数据库只对外提供相关的视图，java程序员 只对视图对象进行CRUD。 6、DBA命令 6.1、将数据库当中的数据导出 在windows的dos命令窗口中执行：（导出整个库） mysqldump bjpowernode&gt;D:\\bjpowernode.sql -uroot -p333 在windows的dos命令窗口中执行：（导出指定数据库当中的指定表） mysqldump bjpowernode emp&gt;D:\\bjpowernode.sql -uroot –p123 6.2、导入数据 create database bjpowernode; use bjpowernode; source D:\\bjpowernode.sql 7、数据库设计三范式（重点内容，面试经常问） 7.1、什么是设计范式？ 设计表的依据。按照这个三范式设计的表不会出现数据冗余。 7.2、三范式都是哪些？ 第一范式：任何一张表都应该有主键，并且每一个字段原子性不可再分。 第二范式：建立在第一范式的基础之上，所有非主键字段完全依赖主键，不能产生部分依赖。 多对多？三张表，关系表两个外键。 t_student学生表 sno(pk) sname ------------------- 1 张三 2 李四 3 王五 t_teacher 讲师表 tno(pk) tname --------------------- 1 王老师 2 张老师 3 李老师 t_student_teacher_relation 学生讲师关系表 id(pk) sno(fk) tno(fk) ---------------------------------- 1 1 3 2 1 1 3 2 2 4 2 3 5 3 1 6 3 3 第三范式：建立在第二范式的基础之上，所有非主键字段直接依赖主键，不能产生传递依赖。 一对多？两张表，多的表加外键。 班级t_class cno(pk) cname -------------------------- 1 班级1 2 班级2 学生t_student sno(pk) sname classno(fk) --------------------------------------------- 101 张1 1 102 张2 1 103 张3 2 104 张4 2 105 张5 2 提醒：在实际的开发中，以满足客户的需求为主，有的时候会拿冗余换执行速度。 7.3、一对一怎么设计？ 一对一设计有两种方案：主键共享 t_user_login 用户登录表 id(pk) username password -------------------------------------- 1 zs 123 2 ls 456 t_user_detail 用户详细信息表 id(pk+fk) realname tel .... ------------------------------------------------ 1 张三 1111111111 2 李四 1111415621 一对一设计有两种方案：外键唯一。 t_user_login 用户登录表 id(pk) username password -------------------------------------- 1 zs 123 2 ls 456 t_user_detail 用户详细信息表 id(pk) realname tel userid(fk+unique).... ----------------------------------------------------------- 1 张三 1111111111 2 2 李四 1111415621 1","categories":[{"name":"数据库","slug":"数据库","permalink":"https://47.115.211.244/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://47.115.211.244/blog/tags/Mysql/"}]},{"title":"Spring","slug":"Spring","date":"2021-06-09T01:42:28.000Z","updated":"2021-06-14T05:25:35.037Z","comments":true,"path":"2021/06/08/Spring/","link":"2021/06/08/Spring","permalink":"https://47.115.211.244/blog/2021/06/08/Spring/","excerpt":"Spring 1. Spring 1.1 简介 Spring：春天-----&gt; 给软件行业带来了春天! 2002,首次推出了Spring框架的雏形：interface21 Spring框架即以interface21框架为基础，经过重新设计，并不断丰富其内涵，于2004年3月24日，发布了1.0正式版。 Rod Johnson spring理念：使现有的技术更容易使用，本身是一个大杂烩，整合了现有的技术框架 SSH：Struct2 + Spring + Hibernate SSM：SpringMVC + Spring + Mybatis","text":"Spring 1. Spring 1.1 简介 Spring：春天-----&gt; 给软件行业带来了春天! 2002,首次推出了Spring框架的雏形：interface21 Spring框架即以interface21框架为基础，经过重新设计，并不断丰富其内涵，于2004年3月24日，发布了1.0正式版。 Rod Johnson spring理念：使现有的技术更容易使用，本身是一个大杂烩，整合了现有的技术框架 SSH：Struct2 + Spring + Hibernate SSM：SpringMVC + Spring + Mybatis 官网：https://docs.spring.io/spring-framework/docs/current/reference/html/overview.html#overview 官方下载地址：https://repo.spring.io/libs-release-local/org/springframework/ Github：https://github.com/spring-projects/spring-framework 1234567891011&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.3.7&lt;/version&gt;&lt;/dependency&gt; 1.2 优点 Spring是一个开源的免费的框架（容器）！ Spring是一个轻量级的，非入侵式的框架！ 控制反转（IOC），面向切面编程（AOP） 支持事务的处理，对框架整合的支持 ==总结一句话：Spring就是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架！== 1.3 组成 1.4 扩展 在Spring的官网有这个介绍：现代化的java开发！说白了就是基于Spring的开发 Spring Boot 一个快速开发的脚手架 基于SpringBoot可以快速的开发单个微服务 约定大于配置！ Spring Cloud SpringCloud 是基于SpringBoot实现的 因为现在大多数公司都在使用SpringBoot进行快速开发，学习SpringBoot的前提，需要完全掌握Spring及SpringMVC！承上启下的作用！ 弊端：发展太久之后，违背了原来的理念！配置十分繁琐，人称：“配置地狱” 2.IOC理论推导 UserDao 接口 1234567891011package com.junduo.dao;/** * ClassName UserDao * Description * Create by JBuck * Date 2021/5/28 21:36 */public interface UserDao &#123; void getUser();&#125; UserDaoImpl 实现类 1234567891011121314package com.junduo.dao;/** * ClassName UserDaoImpl * Description * Create by JBuck * Date 2021/5/28 21:36 */public class UserDaoImpl implements UserDao&#123; @Override public void getUser() &#123; System.out.println(&quot;默认获取用户的数据&quot;); &#125;&#125; UserService 业务接口 1234567891011package com.junduo.service;/** * ClassName UserService * Description * Create by JBuck * Date 2021/5/28 21:37 */public interface UserService &#123; void getUser();&#125; UserServiceImpl 接口实现类 1234567891011121314151617181920212223242526package com.junduo.service;import com.junduo.dao.UserDao;import com.junduo.dao.UserDaoImpl;import com.junduo.dao.UserDaoMysqlImpl;/** * ClassName UserServiceImpl * Description * Create by JBuck * Date 2021/5/28 21:38 */public class UserServiceImpl implements UserService&#123; private UserDao userDao; // 利用set进行动态实现值的注入! public void setUserDao(UserDao userDao)&#123; this.userDao = userDao; &#125; @Override public void getUser() &#123; userDao.getUser(); &#125;&#125; Test.java 1234567891011121314151617181920212223import com.junduo.dao.UserDaoMysqlImpl;import com.junduo.dao.UserDaoOracleImpl;import com.junduo.dao.UserDaoSqlserverImpl;import com.junduo.service.UserService;import com.junduo.service.UserServiceImpl;/** * ClassName MyTest * Description * Create by JBuck * Date 2021/5/28 21:39 */public class MyTest &#123; public static void main(String[] args) &#123; // 用户实际调用的是业务层，dao层他们不需要接触！ UserService userService = new UserServiceImpl(); ((UserServiceImpl)userService).setUserDao(new UserDaoSqlserverImpl()); userService.getUser(); &#125;&#125; 在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改源代码！如果程序代码量十分大，修改一次的成本十分昂贵！ 我们使用Set接口实现,已经发生了革命性变化 123456private UserDao userDao;// 利用set进行动态实现值的注入!public void setUserDao(UserDao userDao)&#123; this.userDao = userDao;&#125; 之前程序是主动创建对象！控制权在程序员手上！ 使用了set注入后，程序不再具有主动性，而是变成了被动的接收对象！ 这种思想，从本质上解决了问题，我们程序员不用再去管理对象的创建了。系统的耦合性大大降低，可以更加专注在业务的实现上！这是IOC的原型！ 采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把二者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。 控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IOC容器，其实现方法是依赖注入 （Dependency Injection，DI） 3.HelloSpring 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;mysqlImpl&quot; class=&quot;com.junduo.dao.UserDaoMysqlImpl&quot;/&gt; &lt;bean id=&quot;oracleImpl&quot; class=&quot;com.junduo.dao.UserDaoOracleImpl&quot;/&gt; &lt;bean id=&quot;UserServiceImpl&quot; class=&quot;com.junduo.service.UserServiceImpl&quot;&gt; &lt;!-- ref：引用spring容器中创建好的对象 value: 具体的值，基本数据类型！ --&gt; &lt;property name=&quot;userDao&quot; ref=&quot;mysqlImpl&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 4.IOC创建对象的方式 1.使用无参构造创建对象，默认！ 12345678910&lt;!-- 使用Spring来创建对象，在Spring这些都称为Bean类型 变量名 = new 类型();Hello hello = new Hello();id = 变量名class = new 的对象property 相当于给对象中的属性设置一个值--&gt;&lt;bean id=&quot;hello&quot; class=&quot;com.junduo.pojo.Hello&quot;&gt; &lt;property name=&quot;str&quot; value=&quot;Spring&quot;/&gt;&lt;/bean&gt; 2.假设我们要使用有参构造对象 下标赋值 1234&lt;!--第一种，下标赋值--&gt;&lt;bean id=&quot;user&quot; class=&quot;com.junduo.pojo.User&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;俊铎&quot;/&gt;&lt;/bean&gt; 类型赋值 1234&lt;!--第二种方式，通过类型创建，不建议使用--&gt;&lt;bean id=&quot;user&quot; class=&quot;com.junduo.pojo.User&quot;&gt; &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;junduo&quot;/&gt;&lt;/bean&gt; 参数名赋值 1234&lt;!--第三种，直接通过参数名--&gt;&lt;bean id=&quot;user&quot; class=&quot;com.junduo.pojo.User&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;junduo&quot;/&gt;&lt;/bean&gt; 总结：在配置文件加载的时候，容器中管理的对象就已经初始化了！ 5.Spring 配置 5.1 别名 12&lt;!--别名，如果添加了别名，我们可以使用别名获取这个对象--&gt;&lt;alias name=&quot;user&quot; alias=&quot;user2&quot;/&gt; 5.2 Bean的配置 12345678&lt;!--id:bean的唯一标识，也就是相当于我们对象的对象名class：bean对象所对应的全限定名：包名+类型名name:也是别名,而且name更高级，可以同时取多个别名.可以用各种各样的方式进行分割 --&gt;&lt;bean id=&quot;userT&quot; class=&quot;com.junduo.pojo.UserT&quot; name=&quot;user3,u2&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;junduo&quot;/&gt;&lt;/bean&gt; 5.3 import 这个import，一般用于团队开发使用，可以将多个配置文件，导入合并为一份 假设，现在项目中有多个人开发，这三个人复制不同的类开发，不同的类需要注册在不同的bean中，我们可以利于import将所有人的beans.xml合并为一个总的! 张三 李四 王五 applicationContext.xml 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;import resource=&quot;beans.xml&quot;/&gt; &lt;import resource=&quot;beans2.xml&quot;/&gt; &lt;import resource=&quot;beans3.xml&quot;/&gt;&lt;/beans&gt; 使用的时候，可以使用总的配置即可 6.依赖注入 6.1 构造器注入 前面已经说过了 6.2 Set方式注入【重点】 依赖注入：set注入！ 依赖：bean对象的创建依赖容器 注入：bean对象中的所有属性，由容器来注入 【环境搭建】 1.复杂类型 1234567891011public class Address &#123; private String address; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; 2.真实测试对象 12345678910public class Student &#123; private String name; private Address address; private String[] books; private List&lt;String&gt; hobbies; private Map&lt;String, String&gt; card; private Set&lt;String&gt; games; private String wife; private Properties info;&#125; 3.beans.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;bean id=&quot;address&quot; class=&quot;com.junduo.pojo.Address&quot;&gt; &lt;property name=&quot;address&quot; value=&quot;汕头&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;student&quot; class=&quot;com.junduo.pojo.Student&quot;&gt; &lt;!--第一种，普通值注入，value--&gt; &lt;property name=&quot;name&quot; value=&quot;俊铎&quot;/&gt; &lt;!--第二种，Bean注入，ref--&gt; &lt;property name=&quot;address&quot; ref=&quot;address&quot;/&gt; &lt;!--数组注入,ref--&gt; &lt;property name=&quot;books&quot;&gt; &lt;array&gt; &lt;value&gt;红楼梦&lt;/value&gt; &lt;value&gt;西游记&lt;/value&gt; &lt;value&gt;水浒传&lt;/value&gt; &lt;value&gt;三国演义&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!--List--&gt; &lt;property name=&quot;hobbies&quot;&gt; &lt;list&gt; &lt;value&gt;听歌&lt;/value&gt; &lt;value&gt;看电影&lt;/value&gt; &lt;value&gt;写代码&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--Map--&gt; &lt;property name=&quot;card&quot;&gt; &lt;map&gt; &lt;entry key=&quot;身份证&quot; value=&quot;1234567&quot;/&gt; &lt;entry key=&quot;银行卡&quot; value=&quot;21123421412412&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--Set--&gt; &lt;property name=&quot;games&quot;&gt; &lt;set&gt; &lt;value&gt;LOL&lt;/value&gt; &lt;value&gt;DNF&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!--null--&gt; &lt;property name=&quot;wife&quot;&gt; &lt;null/&gt; &lt;/property&gt; &lt;!--properties--&gt; &lt;property name=&quot;info&quot;&gt; &lt;props&gt; &lt;prop key=&quot;学号&quot;&gt;3118007360&lt;/prop&gt; &lt;prop key=&quot;性别&quot;&gt;男&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 4.测试类 1234567public class MyTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); Student student = (Student) context.getBean(&quot;student&quot;); System.out.println(student); &#125;&#125; 6.3扩展方式注入 我们可以使用p命名空间和c命名空间进行注入 6.3.1 p命名空间 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--p命名空间注入，可以直接注入属性的值--&gt; &lt;bean id=&quot;user&quot; class=&quot;com.junduo.pojo.User&quot; p:name=&quot;俊铎&quot; p:age=&quot;18&quot;/&gt;&lt;/beans&gt; 6.3.2 c命名空间 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--c命名空间注入，通过构造器注入：construct-args--&gt; &lt;bean id=&quot;user2&quot; class=&quot;com.junduo.pojo.User&quot; c:age=&quot;18&quot; c:name=&quot;俊铎&quot;/&gt;&lt;/beans&gt; 测试： 123456@Testpublic void test()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;userbeans.xml&quot;); User user = context.getBean(&quot;user&quot;, User.class); System.out.println(user);&#125; 注意点：p命名空间和c命名空间不能直接使用，需要导入xml约束！ 12xmlns:p=&quot;http://www.springframework.org/schema/p&quot;xmlns:c=&quot;http://www.springframework.org/schema/c&quot; 6.4 bean的作用域 单例模式（Spring默认机制） 1&lt;bean id=&quot;user2&quot; class=&quot;com.junduo.pojo.User&quot; c:age=&quot;18&quot; c:name=&quot;俊铎&quot; scope=&quot;singleton&quot;/&gt; 原型模式：每次从容器中get的时候，都会产生一个新对象！ 1&lt;bean id=&quot;user2&quot; class=&quot;com.junduo.pojo.User&quot; c:age=&quot;18&quot; c:name=&quot;俊铎&quot; scope=&quot;prototype&quot;/&gt; 其余的request,session,application，这些只能在web开发中使用到 7.Bean的自动装配 自动装配是Spring满足bean依赖的一种方式 Spring会在上下文中自动寻找，并自动给bean装配属性 在Spring中有三种自动装配的方式 在xml中显式的配置 在java中显式的配置 隐式的自动装配bean【重要】 7.1 搭建测试环境 案例：一个人有两个宠物 7.2 ByName自动装配 123456&lt;!--byName:会自动在容器上下文查找，和自己对象set方法后面的值对应的 Bean Id--&gt;&lt;bean id=&quot;people&quot; class=&quot;com.junduo.pojo.People&quot; autowire=&quot;byName&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;俊铎&quot;/&gt;&lt;/bean&gt; 7.3 ByType自动装配 123456789&lt;bean class=&quot;com.junduo.pojo.Dog&quot;/&gt;&lt;bean class=&quot;com.junduo.pojo.Cat&quot;/&gt;&lt;!--byType:会自动在容器上下文查找，和自己对象属性类型相同的bean--&gt;&lt;bean id=&quot;people&quot; class=&quot;com.junduo.pojo.People&quot; autowire=&quot;byType&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;俊铎&quot;/&gt;&lt;/bean&gt; 小结： byName的时候，需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致 byType的时候，需要保证所有bean的calss唯一，并且这个bean需要和自动注入的属性的类型一致 7.4 使用注解实现自动装配 jdk1.5 支持的注解，Spring2.5就支持注解了 要使用注解须知： 导入约束,context约束 配置注解的支持,&lt;context:annotation-config/&gt;==重要== 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--开启注解--&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; @Autowired 直接在属性上使用即可！也可以在set方法上使用 使用Autowired我们可以不用编写Set方法了，前提是你这个自动装配的属性在IOC（Spring）容器中存在， ==并且会先根据类型进行注入，如果容器中有多个满足类型的实例，就会根据ID进行注入，并不是单纯的根据类型注入== 科普： 1@NUllable 字段标记了这个注解，说明这个字段可以为null 123public @interface Autowired &#123; boolean required() default true;&#125; 测试代码： 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--开启注解--&gt; &lt;context:annotation-config/&gt; &lt;bean id=&quot;dog&quot; class=&quot;com.junduo.pojo.Dog&quot;/&gt; &lt;bean id=&quot;cat&quot; class=&quot;com.junduo.pojo.Cat&quot;/&gt; &lt;bean id=&quot;people&quot; class=&quot;com.junduo.pojo.People&quot;/&gt;&lt;/beans&gt; 12345678910public class People &#123; // 如果显式的定义了Autowired的required属性为false，说明这个对象可以为null，否则不允许为空 @Autowired private Cat cat; @Autowired private Dog dog; @Nullable private String name;&#125; 如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解完【@Autowired】成的时候，我们可以使用@Qualifier(value=“xxx”)去配置@Autowired的使用，指定一个唯一的bean对象注入！ 12345678910public class People &#123; @Autowired @Qualifier(&quot;cat2222&quot;) private Cat cat; @Autowired @Qualifier(&quot;dog1111&quot;) private Dog dog;&#125; @Resource注解 12345678public class People&#123; @Resource(name = &quot;cat2&quot;) private Cat cat; @Resource private Dog dog;&#125; 小结： @Resource 和 @Autowired 的区别： 都是用来自动装配的，都可以放在属性字段上 @Autowired 通过bytype实现，如果多个类型相同，再通过@Qualifier进行byname寻找 @Resource默认通过byname的方式实现，如果找不到名字，则通过byType实现！如果两个都找不到的情况下就报错 8.使用注解开发 在Spring4之后，要使用注解开发，必须要保证aop的包导入了 使用注解需要导入context约束，增加注解的支持 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--指定要扫描的包，这个包下的注解就会生效--&gt; &lt;context:component-scan base-package=&quot;com.junduo&quot;/&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; bean 属性如何注入 12345678910111213@Componentpublic class User &#123; // 相当于&lt;property name=&quot;name&quot; value=&quot;junduo&quot;/&gt; @Value(&quot;junduo&quot;) public String name; // 相当于&lt;property name=&quot;name&quot; value=&quot;junduo&quot;/&gt; @Value(&quot;junduo&quot;) public void setName(String name)&#123; this.name = name; &#125;&#125; 衍生的注解 @Component：组件，放在类上说明这个类被Spring管理了 @Component 有几个衍生注解，我们在web开发中，会按照mvc三层架构分层 dao 【@Repository】 service 【@Service】 controller 【@Controller】 这四个注解的功能都是一样的，都是代表将某个类注册到Spring中，装配Bean 自动装配 @Autowired:自动装配，先类型后名字 如果含有多个相同类型，则需要通过id精确查找，使用@Qualifier(value=“xxx”) @Nullable：字段标记了这个注解，说明这个字段可以为null @Resource: 自动装配，先名字后类型 作用域 @Scope() 1234567891011121314@Component@Scope(&quot;prototype&quot;)public class User &#123; // 相当于&lt;property name=&quot;name&quot; value=&quot;junduo&quot;/&gt; @Value(&quot;junduo&quot;) public String name; // 相当于&lt;property name=&quot;name&quot; value=&quot;junduo&quot;/&gt; @Value(&quot;junduo&quot;) public void setName(String name)&#123; this.name = name; &#125;&#125; 小结 xml与注解： xml更加万能，适用于任何场合！维护简单方便 注解，不是自己类的使用不了，维护相对复杂！ xml与注解最佳实践： xml用来管理bean 注解只负责属性的注入 我们在使用的过程中，只需注意一个问题：必须让注解生效，就需要开启注解支持 123&lt;!--指定要扫描的包，这个包下的注解就会生效--&gt;&lt;context:component-scan base-package=&quot;com.junduo&quot;/&gt;&lt;context:annotation-config/&gt; 9.使用Java的方式配置Spring 我们现在要完全不使用Spring的xml配置了，全权交给Java来做！ JavaConfig是Spring的一个子项目，在Spring4之后，它成为了一个核心功能 User.java 【实体类】 1234567891011121314151617181920212223// 这个注解只起到说明的作用，就是说明这个类被Spring接管了，注册到容器中，相当于一个注释，写不写没关系// 如果在DuoConfig.java中配置了@ComponentScan(&quot;com.junduo.pojo&quot;) 就会使得该注解生效，注册这个bean类到ioc容器中@Componentpublic class User &#123; private String name; public String getName() &#123; return name; &#125; @Value(&quot;duo&quot;) //属性注入 public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; DuoConfig.java 123456789101112131415//这个也会spring容器托管，注册到容器中，因为他本来就是一个@Component// @Configuration代表这是一个配置类，就和我们之前看的beans.xml@Configuration@ComponentScan(&quot;com.junduo.pojo&quot;) //此处扫描得到的那个带有@Component的bean类，会初始化id=user的User对象到ioc容器中@Import(DuoConfig1.class)public class DuoConfig &#123; // 注册一个bean，就相当于我们之前写的一个bean标签 //这个方法的名字，就相当于bean标签中的id属性 //这个方法的返回值，就相当于bean标签的class属性 @Bean //此处的@Bean也会创建一个id为getUser的User对象到ioc容器中 public User getUser()&#123; return new User(); //就是返回要注入到bean的对象 &#125;&#125; DuoConfig1.java 123@Configurationpublic class DuoConfig1 &#123;&#125; Test 12345678public class MyTest &#123; public static void main(String[] args) &#123; // 如果完全使用了配置类方式去做，就只能通过AnnotationConfig上下文来获取容器，通过配置类的class对象加载 ApplicationContext context = new AnnotationConfigApplicationContext(DuoConfig.class); User getUser =(User) context.getBean(&quot;user&quot;); System.out.println(getUser.getName()); &#125;&#125; 这种纯Java的配置方式，在SpringBoot中随处可见！SSM中不多见 10. 代理模式 为什么要学习代理模式？因为这既是SpringAOP的底层！【SpringAOP 和 SpringMVC】 代理模式的分类 静态代理 动态代理 10.1 静态代理 角色分析： 抽象角色：一般会使用绝口或者抽象类来解决 真实角色：被代理的角色 代理角色：代理真实角色，代理真实角色后，我们一般会做一些附属操作 客户：访问代理对象的人 代码步骤： 1.接口 1234public interface Rent &#123; public void rent();&#125; 2.真实角色 1234567// 房东public class Host implements Rent&#123; @Override public void rent() &#123; System.out.println(&quot;房东要出租房子&quot;); &#125;&#125; 3.代理角色 12345678910111213141516171819202122232425262728public class Proxy implements Rent&#123; private Host host; public Proxy()&#123; &#125; public Proxy(Host host) &#123; this.host = host; &#125; @Override public void rent() &#123; seeHouse(); host.rent(); fare(); &#125; // 看房 public void seeHouse()&#123; System.out.println(&quot;中介带你们看房&quot;); &#125; // 收中介费 public void fare()&#123; System.out.println(&quot;收中介费&quot;); &#125;&#125; 4.客户端访问代理角色 1234567891011public class Client &#123; public static void main(String[] args) &#123; // 房东要租房子 Host host = new Host(); // 代理,中介帮房东租房子，但是呢？代理角色一般会有一些附属操作 Proxy proxy = new Proxy(host); // 你不用面对房东，直接找中介租房即可 proxy.rent(); &#125;&#125; 代理模式的好处： 可以使真是角色的操作更加纯粹！不用去关注一些公共的业务 公共业务就交给了代理角色！实现了业务的分工！ 公共业务发生扩展的时候，方便集中管理！ 缺点： 一个真实角色就会产生一个代理角色；代码量会翻倍~开发效率会变低 10.2 加深理解 聊聊AOP 10.3 动态代理 动态代理和静态代理角色一样 动态代理的代理类是动态生成的，不是我们直接写好的！ 动态代理分为两大类：基于接口的动态代理，基于类的动态代理 基于接口—JDK动态代理【我们在这里使用】 基于类：cglib Java字节码实现：javasist 需要了解两个类：Proxy：代理，InvocationHandler：调用处理程序 动态代理的好处： 代理模式的好处： 可以使真是角色的操作更加纯粹！不用去关注一些公共的业务 公共业务就交给了代理角色！实现了业务的分工！ 公共业务发生扩展的时候，方便集中管理！ 一个动态代理代理的是一个接口，一般就是对应的一类业务 一个动态代理类可以代理多个类，只要实现了同一个接口的都可以 真实对象接口 12345678910public interface UserService &#123; public void add(); public void delete(); public void update(); public void query();&#125; 真实对象 123456789101112131415161718192021222324// 真实对象public class UserServiceImpl implements UserService&#123; @Override public void add() &#123; System.out.println(&quot;增加了一个用户&quot;); &#125; @Override public void delete() &#123; System.out.println(&quot;删除了一个用户&quot;); &#125; @Override public void update() &#123; System.out.println(&quot;修改了一个用户&quot;); &#125; @Override public void query() &#123; System.out.println(&quot;查询了一个用户&quot;); &#125; // 1.改动原有的业务代码，在公司中是大忌&#125; 动态代理类 1234567891011121314151617181920212223242526272829303132333435363738394041package com.junduo.demo04;import com.junduo.demo03.Rent;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * ClassName ProxyInvocationHandler * Description * Create by JBuck * Date 2021/5/31 19:40 */// 等会会用这个类，自动生成代理类public class ProxyInvocationHandler implements InvocationHandler &#123; // 被代理的接口 private Object target; public void setTarget(Object target) &#123; this.target = target; &#125; //生成得到代理类 public Object getProxy()&#123; return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(),this); &#125; // 处理代理实例，并返回结果 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; log(method.getName()); Object result = method.invoke(target,args); return result; &#125; public void log(String msg)&#123; System.out.println(&quot;执行了&quot;+msg+&quot;方法&quot;); &#125;&#125; Test.java 123456789101112public class Client &#123; public static void main(String[] args) &#123; // 真实角色 UserServiceImpl userService = new UserServiceImpl(); // 代理角色，不存在 ProxyInvocationHandler pih = new ProxyInvocationHandler(); pih.setTarget(userService); //设置要代理的对象 // 动态生成代理类 UserService proxy =(UserService) pih.getProxy(); proxy.query(); &#125;&#125; 11. AOP 11.1 什么是AOP AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 11.2 AOP在Spring中的作用 ==提供声明式事务：允许用户自定义切面== 横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关，但是我们需要关注的部分，就是横切关注点。如日志，安全，缓存，事务等等… 切面（Aspect）：横切关注点 被模块化的特殊对象。即，它是一个类。 通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。 目标（Target）：被通知对象 代理（Proxy）：向目标对象应用通知之后创建的对象。 切入点（PointCut）：切面通知 执行的“地点”的定义 连接点（JointPoint）：与切入点匹配的执行点 SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice： 即AOP在不改变原有代码的情况下，去增加新的功能. 11.3 使用Spring实现AOP 【重点】使用AOP织入，需要导入一个依赖包 123456&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt; 方式一：使用Spring的API接口【主要是SpringAPI接口实现】 实验bean接口 12345678910public interface UserService &#123; public void add(); public void delete(); public void update(); public void query();&#125; 实验bean 123456789101112131415161718192021222324// 真实对象public class UserServiceImpl implements UserService&#123; @Override public void add() &#123; System.out.println(&quot;增加了一个用户&quot;); &#125; @Override public void delete() &#123; System.out.println(&quot;删除了一个用户&quot;); &#125; @Override public void update() &#123; System.out.println(&quot;修改了一个用户&quot;); &#125; @Override public void query() &#123; System.out.println(&quot;查询了一个用户&quot;); &#125; // 1.改动原有的业务代码，在公司中是大忌&#125; 实现Advice 12345678910public class Log implements MethodBeforeAdvice &#123; //method:要执行的目标对象的方法 //args：参数 //targer：目标对象 @Override public void before(Method method, Object[] args, Object target) throws Throwable &#123; System.out.println(target.getClass().getName()+&quot;的&quot;+method.getName()+&quot;被执行了&quot;); &#125;&#125; 12345678public class AfterLog implements AfterReturningAdvice &#123; // returnValue:返回值 @Override public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123; System.out.println(&quot;执行了&quot;+method.getName()+&quot;返回结果为：&quot;+returnValue); &#125;&#125; 配置xml 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--注册bean--&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.junduo.service.UserServiceImpl&quot;/&gt; &lt;bean id=&quot;log&quot; class=&quot;com.junduo.log.Log&quot;/&gt; &lt;bean id=&quot;afterLog&quot; class=&quot;com.junduo.log.AfterLog&quot;/&gt; &lt;!--方式一：使用原生Spring API接口--&gt; &lt;!--配置aop：需要导入aop的约束--&gt; &lt;aop:config&gt; &lt;!--切入点:expression：表达式。execution(要执行的位置！*****) --&gt; &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.junduo.service.UserServiceImpl.*(..))&quot;/&gt; &lt;!--执行环绕增加--&gt; &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;/aop:config&gt;&lt;/beans&gt; 测试： 12345678public class MyTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); // 动态代理代理的是接口 UserService userService =(UserService) context.getBean(&quot;userService&quot;); userService.add(); &#125;&#125; 方式二：使用自定义来实现AOP【主要是切面定义】 切面方法类（通知类） 1234567891011public class DiyPointCut &#123; public void before()&#123; System.out.println(&quot;=======方法执行前========&quot;); &#125; public void after()&#123; System.out.println(&quot;=======方法执行后========&quot;); &#125;&#125; 注册到xml 123456789101112&lt;!--方式二：自定义类--&gt;&lt;bean id=&quot;diy&quot; class=&quot;com.junduo.diy.DiyPointCut&quot;/&gt;&lt;aop:config&gt; &lt;!--自定义切面，ref要引用的类--&gt; &lt;aop:aspect ref=&quot;diy&quot;&gt; &lt;!--切入点--&gt; &lt;aop:pointcut id=&quot;point&quot; expression=&quot;execution(* com.junduo.service.UserServiceImpl.*(..))&quot;/&gt; &lt;!--通知--&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;point&quot;/&gt; &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;point&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; Test 12345678public class MyTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); // 动态代理代理的是接口 UserService userService =(UserService) context.getBean(&quot;userService&quot;); userService.add(); &#125;&#125; 方式三：使用注解实现！ 使用注解 123456789101112131415161718192021222324252627282930313233343536373839404142package com.junduo.diy;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;/** * ClassName AnnotationPointCut * Description * Create by JBuck * Date 2021/6/1 11:02 */// 使用注解方式实现AOP@Aspect //标注这个类是一个切面public class AnnotationPointCut &#123; @Before(&quot;execution(* com.junduo.service.UserServiceImpl.*(..))&quot;) public void before()&#123; System.out.println(&quot;=====方法执行前=======&quot;); &#125; @After(&quot;execution(* com.junduo.service.UserServiceImpl.*(..))&quot;) public void after()&#123; System.out.println(&quot;=====方法执行后========&quot;); &#125; // 在环绕增强中，我们可以给定一个参数，代表我们要处理切入的点 @Around(&quot;execution(* com.junduo.service.UserServiceImpl.*(..))&quot;) public void around(ProceedingJoinPoint jp) throws Throwable &#123; // 执行前 System.out.println(&quot;环绕前&quot;); // 执行方法 Object proceed = jp.proceed(); // 执行后 System.out.println(&quot;环绕后&quot;);// System.out.println(jp.getSignature()); &#125;&#125; 配置xml 1234&lt;!--方式三--&gt;&lt;bean id=&quot;annotationPointCut&quot; class=&quot;com.junduo.diy.AnnotationPointCut&quot;/&gt;&lt;!--开启注解支持 JDK(默认 proxy-target-class=&quot;false&quot;) cglib (proxy-target-class=&quot;true&quot;)--&gt;&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt; 12.整合Mybatis 步骤： 导入相关jar包 junit mybatis mysql数据库 spring相关的 aop织入 mybatis-spring【new】 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.7&lt;/version&gt; &lt;/dependency&gt; &lt;!--Spring操作数据库的话，还需要一个spring-jdbc--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.3.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.6&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 编写配置文件 测试 12.1 回忆mybatis 编写实体类 编写核心配置文件 编写接口 编写Mapper.xml 测试 12.2 Mybatis-Spring 12.1 方式一 编写数据源配置 12345678910&lt;!--DataSource:使用Spring的数据源替换Mybatis的配置 c3p0 dbcp druid我们这里使用Spring提供的JDBC--&gt;&lt;bean id=&quot;datasource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=GMT%2B8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;991229&quot;/&gt;&lt;/bean&gt; sqlSessionFactory 1234567&lt;!--sqlSessionFactory--&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;datasource&quot;/&gt; &lt;!--绑定MyBatis配置文件--&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/junduo/mapper/*.xml&quot;/&gt;&lt;/bean&gt; sqlSessionTemplate 1234&lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;!--只能使用构造器注入sqlSessionFactory，因为它没有set方法--&gt; &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt; 需要给接口加实现类 1234567891011121314public class UserMapperImpl implements UserMapper&#123; //我们的所有操作，都使用sqlSession来执行，在原来，现在都使用SqlSessionTemplate private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession)&#123; this.sqlSession = sqlSession; &#125; @Override public List&lt;User&gt; selectUser() &#123; UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.selectUser(); &#125;&#125; 将自己写的实现类，注入到Spring中 123&lt;bean id=&quot;userMapper&quot; class=&quot;com.junduo.mapper.UserMapperImpl&quot;&gt; &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot;/&gt;&lt;/bean&gt; 测试使用 12345678910public class MyTest &#123; @Test public void test() throws IOException &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserMapper userMapper = context.getBean(&quot;userMapper&quot;, UserMapper.class); for (User user : userMapper.selectUser()) &#123; System.out.println(user); &#125; &#125;&#125; 整体汇总 mybatis-config.xml 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;!--configuration核心配置文件--&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.junduo.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;!--设置--&gt;&lt;/configuration&gt; UserMapper.xml 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--namespace=绑定一个对应的Dao/Mapper接口--&gt;&lt;mapper namespace=&quot;com.junduo.mapper.UserMapper&quot;&gt; &lt;select id=&quot;selectUser&quot; resultType=&quot;User&quot;&gt; select * from mybatis.user &lt;/select&gt;&lt;/mapper&gt; springdao.xml 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--DataSource:使用Spring的数据源替换Mybatis的配置 c3p0 dbcp druid 我们这里使用Spring提供的JDBC --&gt; &lt;bean id=&quot;datasource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=GMT%2B8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;991229&quot;/&gt; &lt;/bean&gt; &lt;!--sqlSessionFactory--&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;datasource&quot;/&gt; &lt;!--绑定MyBatis配置文件--&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/junduo/mapper/*.xml&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;!--只能使用构造器注入sqlSessionFactory，因为它没有set方法--&gt; &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; applicationContext.xml 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;import resource=&quot;spring-dao.xml&quot;/&gt; &lt;bean id=&quot;userMapper&quot; class=&quot;com.junduo.mapper.UserMapperImpl&quot;&gt; &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; UserMapper.java 123public interface UserMapper &#123; public List&lt;User&gt; selectUser();&#125; UserMapperImpl.java 1234567891011121314public class UserMapperImpl implements UserMapper&#123; //我们的所有操作，都使用sqlSession来执行，在原来，现在都使用SqlSessionTemplate private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession)&#123; this.sqlSession = sqlSession; &#125; @Override public List&lt;User&gt; selectUser() &#123; UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.selectUser(); &#125;&#125; Test.java 12345678910public class MyTest &#123; @Test public void test() throws IOException &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserMapper userMapper = context.getBean(&quot;userMapper&quot;, UserMapper.class); for (User user : userMapper.selectUser()) &#123; System.out.println(user); &#125; &#125;&#125; 12.2.2 方式二 除了UserMapperImpl的bean注入操作外，其他操作都一样 方式二的UserMapperImpl不需要提供可供Spring注入的set方法，但是都需要在Spring注册bean 12345678public class UserMapperImpl2 extends SqlSessionDaoSupport implements UserMapper&#123; @Override public List&lt;User&gt; selectUser() &#123; SqlSession sqlSession = getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.selectUser(); &#125;&#125; 官方建议上面的操作可以精简为一行 1234@Overridepublic List&lt;User&gt; selectUser() &#123; return getSqlSession().getMapper(UserMapper.class).selectUser();&#125; 在Spring中注册这个类 123&lt;bean id=&quot;userMapper2&quot; class=&quot;com.junduo.mapper.UserMapperImpl2&quot;&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt; Test 12345678910public class MyTest &#123; @Test public void test() throws IOException &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserMapper userMapper = context.getBean(&quot;userMapper2&quot;, UserMapper.class); for (User user : userMapper.selectUser()) &#123; System.out.println(user); &#125; &#125;&#125; 13.声明式事务 1.回顾事务 把一组业务当成一个业务来做；要么都成功，要么都失败 事务在项目开发中，十分重要，涉及到数据的一致性问题，不能马虎！ 确保完整性和一致性 事务的ACID原则： 原则性 一致性 隔离性 多个业务可能操作同一个资源，防止数据损坏 持久性 事务一旦提交，无论系统发生什么问题，结果都不会被影响，持久化的写到存储器中 2.Spring中的事务管理 声明式事务：AOP 编程式事务：需要在代码中，进行事务的管理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--DataSource:使用Spring的数据源替换Mybatis的配置 c3p0 dbcp druid 我们这里使用Spring提供的JDBC --&gt; &lt;bean id=&quot;datasource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=GMT%2B8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;991229&quot;/&gt; &lt;/bean&gt; &lt;!--sqlSessionFactory--&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;datasource&quot;/&gt; &lt;!--绑定MyBatis配置文件--&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/junduo/mapper/*.xml&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;!--只能使用构造器注入sqlSessionFactory，因为它没有set方法--&gt; &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot;/&gt; &lt;/bean&gt; &lt;!--=--&gt; &lt;!--配置声明式事务--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;constructor-arg ref=&quot;datasource&quot;/&gt; &lt;/bean&gt; &lt;!--结合AOP实现事务的织入--&gt; &lt;!--配置事务通知--&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;!--给哪些方法配置事务--&gt; &lt;!--配置事务的传播特性：new propagation--&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;add&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;delete&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;update&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;query&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--配置事务的切入--&gt; &lt;aop:config&gt; &lt;aop:pointcut id=&quot;txPointCut&quot; expression=&quot;execution(* com.junduo.mapper.*.*(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointCut&quot;/&gt; &lt;/aop:config&gt;&lt;/beans&gt; 思考： 为什么需要事务？ 如果不配置事务，可能存在数据提交不一致的情况 如果不在Spring中去配置声明式事务，就需要在代码中手动配置事务！ 事务在项目的开发中十分重要，涉及到数据的一致性和完整性问题，不容马虎","categories":[{"name":"SSM","slug":"SSM","permalink":"https://47.115.211.244/blog/categories/SSM/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://47.115.211.244/blog/tags/Spring/"}]}],"categories":[{"name":"课内","slug":"课内","permalink":"https://47.115.211.244/blog/categories/%E8%AF%BE%E5%86%85/"},{"name":"java进阶","slug":"java进阶","permalink":"https://47.115.211.244/blog/categories/java%E8%BF%9B%E9%98%B6/"},{"name":"数据库","slug":"数据库","permalink":"https://47.115.211.244/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SSM","slug":"SSM","permalink":"https://47.115.211.244/blog/categories/SSM/"}],"tags":[{"name":"通识课程","slug":"通识课程","permalink":"https://47.115.211.244/blog/tags/%E9%80%9A%E8%AF%86%E8%AF%BE%E7%A8%8B/"},{"name":"java","slug":"java","permalink":"https://47.115.211.244/blog/tags/java/"},{"name":"JDBC","slug":"JDBC","permalink":"https://47.115.211.244/blog/tags/JDBC/"},{"name":"Mysql","slug":"Mysql","permalink":"https://47.115.211.244/blog/tags/Mysql/"},{"name":"Spring","slug":"Spring","permalink":"https://47.115.211.244/blog/tags/Spring/"}]}
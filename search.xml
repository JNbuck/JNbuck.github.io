<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Spring</title>
    <url>/2021/06/08/Spring/</url>
    <content><![CDATA[<h2 id="1.-spring">1. Spring<a title="#1.-spring" href="#1.-spring"></a></h2>
<h3 id="1.1-简介">1.1 简介<a title="#1.1-简介" href="#1.1-简介"></a></h3>
<ul>
<li>
<p>Spring：春天-----&gt; 给软件行业带来了春天!</p>
</li>
<li>
<p>2002,首次推出了Spring框架的雏形：interface21</p>
</li>
<li>
<p>Spring框架即以interface21框架为基础，经过重新设计，并不断丰富其内涵，于2004年3月24日，发布了1.0正式版。</p>
</li>
<li>
<p>Rod Johnson</p>
</li>
<li>
<p>spring理念：使现有的技术更容易使用，本身是一个大杂烩，整合了现有的技术框架</p>
</li>
<li>
<p>SSH：Struct2 + Spring + Hibernate</p>
</li>
<li>
<p>SSM：SpringMVC + Spring + Mybatis</p>
</li>
</ul>
<p>官网：<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/overview.html#overview">https://docs.spring.io/spring-framework/docs/current/reference/html/overview.html#overview</a></p>
<p>官方下载地址：<a href="https://repo.spring.io/libs-release-local/org/springframework/">https://repo.spring.io/libs-release-local/org/springframework/</a></p>
<p>Github：<a href="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="1.2-优点">1.2 优点<a title="#1.2-优点" href="#1.2-优点"></a></h3>
<ul>
<li>Spring是一个开源的免费的框架（容器）！</li>
<li>Spring是一个轻量级的，非入侵式的框架！</li>
<li>控制反转（IOC），面向切面编程（AOP）</li>
<li>支持事务的处理，对框架整合的支持</li>
</ul>
<p>==总结一句话：Spring就是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架！==</p>
<h3 id="1.3-组成">1.3 组成<a title="#1.3-组成" href="#1.3-组成"></a></h3>
<p><img src="http://quddy2o0i.hn-bkt.clouddn.com/typora/20210609174353.png" alt="image-20210528211301658" loading="lazy" class="φbq"></p>
<h3 id="1.4-扩展">1.4 扩展<a title="#1.4-扩展" href="#1.4-扩展"></a></h3>
<p>在Spring的官网有这个介绍：现代化的java开发！说白了就是基于Spring的开发</p>
<p><img src="http://quddy2o0i.hn-bkt.clouddn.com/typora/20210609174403.png" alt="image-20210528211452754" loading="lazy" class="φbq"></p>
<ul>
<li>Spring Boot
<ul>
<li>一个快速开发的脚手架</li>
<li>基于SpringBoot可以快速的开发单个微服务</li>
<li>约定大于配置！</li>
</ul>
</li>
<li>Spring Cloud
<ul>
<li>SpringCloud 是基于SpringBoot实现的</li>
</ul>
</li>
</ul>
<p>因为现在大多数公司都在使用SpringBoot进行快速开发，学习SpringBoot的前提，需要完全掌握Spring及SpringMVC！承上启下的作用！</p>
<p>弊端：发展太久之后，违背了原来的理念！配置十分繁琐，人称：“配置地狱”</p>
<h2 id="2.ioc理论推导">2.IOC理论推导<a title="#2.ioc理论推导" href="#2.ioc理论推导"></a></h2>
<ol>
<li>UserDao 接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.junduo.dao;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName UserDao</span></span><br><span class="line"><span class="comment"> * Description</span></span><br><span class="line"><span class="comment"> * Create by JBuck</span></span><br><span class="line"><span class="comment"> * Date 2021/5/28 21:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>UserDaoImpl 实现类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.junduo.dao;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName UserDaoImpl</span></span><br><span class="line"><span class="comment"> * Description</span></span><br><span class="line"><span class="comment"> * Create by JBuck</span></span><br><span class="line"><span class="comment"> * Date 2021/5/28 21:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;默认获取用户的数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>UserService 业务接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.junduo.service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName UserService</span></span><br><span class="line"><span class="comment"> * Description</span></span><br><span class="line"><span class="comment"> * Create by JBuck</span></span><br><span class="line"><span class="comment"> * Date 2021/5/28 21:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>UserServiceImpl 接口实现类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.junduo.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.junduo.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> com.junduo.dao.UserDaoImpl;</span><br><span class="line"><span class="keyword">import</span> com.junduo.dao.UserDaoMysqlImpl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName UserServiceImpl</span></span><br><span class="line"><span class="comment"> * Description</span></span><br><span class="line"><span class="comment"> * Create by JBuck</span></span><br><span class="line"><span class="comment"> * Date 2021/5/28 21:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用set进行动态实现值的注入!</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Test.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.junduo.dao.UserDaoMysqlImpl;</span><br><span class="line"><span class="keyword">import</span> com.junduo.dao.UserDaoOracleImpl;</span><br><span class="line"><span class="keyword">import</span> com.junduo.dao.UserDaoSqlserverImpl;</span><br><span class="line"><span class="keyword">import</span> com.junduo.service.UserService;</span><br><span class="line"><span class="keyword">import</span> com.junduo.service.UserServiceImpl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName MyTest</span></span><br><span class="line"><span class="comment"> * Description</span></span><br><span class="line"><span class="comment"> * Create by JBuck</span></span><br><span class="line"><span class="comment"> * Date 2021/5/28 21:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用户实际调用的是业务层，dao层他们不需要接触！</span></span><br><span class="line">        UserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line"></span><br><span class="line">        ((UserServiceImpl)userService).setUserDao(<span class="keyword">new</span> UserDaoSqlserverImpl());</span><br><span class="line">        userService.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改源代码！如果程序代码量十分大，修改一次的成本十分昂贵！</p>
<p>我们使用Set接口实现,已经发生了革命性变化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用set进行动态实现值的注入!</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>之前程序是主动创建对象！控制权在程序员手上！</li>
<li>使用了set注入后，程序不再具有主动性，而是变成了被动的接收对象！</li>
</ul>
<p>这种思想，从本质上解决了问题，我们程序员不用再去管理对象的创建了。系统的耦合性大大降低，可以更加专注在业务的实现上！这是IOC的原型！</p>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Spring Java</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL笔记</title>
    <url>/2021/06/08/MySQL%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>本教程为mysql初步笔记，可以简单粗略的将mysql学习一遍</p>
</blockquote>
<h3 id="第一个部分">第一个部分<a title="#第一个部分" href="#第一个部分"></a></h3>
<p>1、sql、DB、DBMS分别是什么，他们之间的关系？</p>
<pre><code>DB: 
	DataBase（数据库，数据库实际上在硬盘上以文件的形式存在）
DBMS: 
	DataBase Management System（数据库管理系统，常见的有：MySQL Oracle DB2 Sybase SqlServer...）

SQL: 
	结构化查询语言，是一门标准通用的语言。标准的sql适合于所有的数据库产品。
	SQL属于高级语言。只要能看懂英语单词的，写出来的sql语句，可以读懂什么意思。
	SQL语句在执行的时候，实际上内部也会先进行编译，然后再执行sql。（sql语句的编译由DBMS完成。）

DBMS负责执行sql语句，通过执行sql语句来操作DB当中的数据。
DBMS -(执行)-&gt; SQL -(操作)-&gt; DB
</code></pre>
<p>2、什么是表？</p>
<pre><code>表：table

表：table是数据库的基本组成单元，所有的数据都以表格的形式组织，目的是可读性强。

一个表包括行和列：
	行：被称为数据/记录(data)
	列：被称为字段(column)

学号(int)	姓名(varchar)	年龄(int)
------------------------------------
110			张三				20
120			李四				21

每一个字段应该包括哪些属性？
	字段名、数据类型、相关的约束。
</code></pre>
<p>3、学习MySQL主要还是学习通用的SQL语句，那么SQL语句包括增删改查，SQL语句怎么分类呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DQL（数据查询语言）: 查询语句，凡是select语句都是DQL。</span><br><span class="line">DML（数据操作语言）：insert delete update，对表当中的数据进行增删改。</span><br><span class="line">DDL（数据定义语言）：create drop alter，对表结构的增删改。</span><br><span class="line">TCL（事务控制语言）：commit提交事务，rollback回滚事务。(TCL中的T是Transaction)</span><br><span class="line">DCL（数据控制语言）: grant授权、revoke撤销权限等。</span><br></pre></td></tr></table></figure>
<p>4、导入数据（后期大家练习的时候使用这个演示的数据）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	第一步：登录mysql数据库管理系统</span><br><span class="line">		dos命令窗口：</span><br><span class="line">			mysql -uroot -p333</span><br><span class="line">	第二步：查看有哪些数据库</span><br><span class="line">	show databases; (这个不是SQL语句，属于MySQL的命令。)</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| test               |</span><br><span class="line">+-------------------+	</span><br></pre></td></tr></table></figure>
<pre><code>	第三步：创建属于我们自己的数据库
		create database bjpowernode; (这个不是SQL语句，属于MySQL的命令。)
	第四步：使用bjpowernode数据
		use bjpowernode; (这个不是SQL语句，属于MySQL的命令。)
	第五步：查看当前使用的数据库中有哪些表？
		show tables; (这个不是SQL语句，属于MySQL的命令。)
	第六步：初始化数据
		mysql&gt; source D:\course\05-MySQL\resources\bjpowernode.sql
注意：数据初始化完成之后，有三张表：
+-----------------------+
| Tables_in_bjpowernode |
+-----------------------+
| dept                  |
| emp                   |
| salgrade              |
+-----------------------+
</code></pre>
<p>5、bjpowernode.sql</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这个文件以sql结尾，这样的文件被称为“sql脚本”。什么是sql脚本呢？</span><br><span class="line">当一个文件的扩展名是.sql，并且该文件中编写了大量的sql语句，我们称这样的文件为sql脚本。</span><br><span class="line">注意：直接使用source命令可以执行sql脚本。</span><br><span class="line">sql脚本中的数据量太大的时候，无法打开，请使用source命令完成初始化。</span><br></pre></td></tr></table></figure>
<p>6、删除数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop database bjpowernode;</span><br></pre></td></tr></table></figure>
<p>7、查看表结构：</p>
<pre><code>	+-----------------------+
	| Tables_in_bjpowernode |
	+-----------------------+
	| dept                  |   (部门表)
	| emp                   |   (员工表)
	| salgrade              |   (工资等级表)
	+-----------------------+
mysql&gt; desc dept;
+--------+-------------+------+-----+---------+-------+
| Field  | Type        | Null | Key | Default | Extra |
+--------+-------------+------+-----+---------+-------+
| DEPTNO | int(2)      | NO   | PRI | NULL    |       |		部门编号
| DNAME  | varchar(14) | YES  |     | NULL    |       |		部门名称
| LOC    | varchar(13) | YES  |     | NULL    |       |		部门位置
+--------+-------------+------+-----+---------+-------+

mysql&gt; desc emp;
+----------+-------------+------+-----+---------+-------+
| Field    | Type        | Null | Key | Default | Extra |
+----------+-------------+------+-----+---------+-------+
| EMPNO    | int(4)      | NO   | PRI | NULL    |       |	员工编号
| ENAME    | varchar(10) | YES  |     | NULL    |       |	员工姓名
| JOB      | varchar(9)  | YES  |     | NULL    |       |	工作岗位
| MGR      | int(4)      | YES  |     | NULL    |       |	上级领导编号
| HIREDATE | date        | YES  |     | NULL    |       |	入职日期
| SAL      | double(7,2) | YES  |     | NULL    |       |	月薪
| COMM     | double(7,2) | YES  |     | NULL    |       |	补助/津贴
| DEPTNO   | int(2)      | YES  |     | NULL    |       |	部门编号
+----------+-------------+------+-----+---------+-------+

mysql&gt; desc salgrade;
+-------+---------+------+-----+---------+-------+
| Field | Type    | Null | Key | Default | Extra |
+-------+---------+------+-----+---------+-------+
| GRADE | int(11) | YES  |     | NULL    |       |		等级
| LOSAL | int(11) | YES  |     | NULL    |       |		最低薪资
| HISAL | int(11) | YES  |     | NULL    |       |		最高薪资
+-------+---------+------+-----+---------+-------+
</code></pre>
<p>8、表中的数据？</p>
<p>mysql&gt; select * from emp;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-------+--------+-----------+------+------------+---------+---------+--------+</span><br><span class="line">| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |</span><br><span class="line">+-------+--------+-----------+------+------------+---------+---------+--------+</span><br><span class="line">|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |</span><br><span class="line">|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |</span><br><span class="line">|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |</span><br><span class="line">|  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |</span><br><span class="line">|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |</span><br><span class="line">|  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |</span><br><span class="line">|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 |</span><br><span class="line">|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |</span><br><span class="line">|  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |</span><br><span class="line">|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |</span><br><span class="line">|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |</span><br><span class="line">|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |</span><br><span class="line">|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |</span><br><span class="line">|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |</span><br><span class="line">+-------+--------+-----------+------+------------+---------+---------+--------+</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from dept;</span><br><span class="line">+--------+------------+----------+</span><br><span class="line">| DEPTNO | DNAME      | LOC      |</span><br><span class="line">+--------+------------+----------+</span><br><span class="line">|     10 | ACCOUNTING | NEW YORK |</span><br><span class="line">|     20 | RESEARCH   | DALLAS   |</span><br><span class="line">|     30 | SALES      | CHICAGO  |</span><br><span class="line">|     40 | OPERATIONS | BOSTON   |</span><br><span class="line">+--------+------------+----------+</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from salgrade;</span><br><span class="line">+-------+-------+-------+</span><br><span class="line">| GRADE | LOSAL | HISAL |</span><br><span class="line">+-------+-------+-------+</span><br><span class="line">|     1 |   700 |  1200 |</span><br><span class="line">|     2 |  1201 |  1400 |</span><br><span class="line">|     3 |  1401 |  2000 |</span><br><span class="line">|     4 |  2001 |  3000 |</span><br><span class="line">|     5 |  3001 |  9999 |</span><br><span class="line">+-------+-------+-------+</span><br></pre></td></tr></table></figure>
<p>9、常用命令？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select database(); 查看当前使用的是哪个数据库</span><br><span class="line">+-------------+</span><br><span class="line">| database()  |</span><br><span class="line">+-------------+</span><br><span class="line">| bjpowernode |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select version(); 查看mysql的版本号。</span><br><span class="line">+-----------+</span><br><span class="line">| version() |</span><br><span class="line">+-----------+</span><br><span class="line">| 5.5.36    |</span><br><span class="line">+-----------+</span><br><span class="line">\c   命令，结束一条语句。</span><br><span class="line">exit 命令，退出mysql。</span><br></pre></td></tr></table></figure>
<p>10、查看创建表的语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show create table emp;</span><br></pre></td></tr></table></figure>
<p>11、简单的查询语句（DQL）</p>
<pre><code>语法格式：
	select 字段名1,字段名2,字段名3,.... from 表名;

提示：
	1、任何一条sql语句以“;”结尾。
	2、sql语句不区分大小写。

查询员工的年薪？（字段可以参与数学运算。）
	select ename,sal * 12 from emp;
	+--------+----------+
	| ename  | sal * 12 |
	+--------+----------+
	| SMITH  |  9600.00 |
	| ALLEN  | 19200.00 |
	| WARD   | 15000.00 |
	| JONES  | 35700.00 |
	| MARTIN | 15000.00 |
	| BLAKE  | 34200.00 |
	| CLARK  | 29400.00 |
	| SCOTT  | 36000.00 |
	| KING   | 60000.00 |
	| TURNER | 18000.00 |
	| ADAMS  | 13200.00 |
	| JAMES  | 11400.00 |
	| FORD   | 36000.00 |
	| MILLER | 15600.00 |
	+--------+----------+

给查询结果的列重命名？
	select ename,sal * 12 as yearsal from emp;

别名中有中文？
	select ename,sal * 12 as 年薪 from emp; // 错误
	select ename,sal * 12 as '年薪' from emp;
	+--------+----------+
	| ename  | 年薪        |
	+--------+----------+
	| SMITH  |  9600.00 |
	| ALLEN  | 19200.00 |
	| WARD   | 15000.00 |
	| JONES  | 35700.00 |
	| MARTIN | 15000.00 |
	| BLAKE  | 34200.00 |
	| CLARK  | 29400.00 |
	| SCOTT  | 36000.00 |
	| KING   | 60000.00 |
	| TURNER | 18000.00 |
	| ADAMS  | 13200.00 |
	| JAMES  | 11400.00 |
	| FORD   | 36000.00 |
	| MILLER | 15600.00 |
	+--------+----------+

注意：标准sql语句中要求字符串使用单引号括起来。虽然mysql支持双引号，尽量别用。

as关键字可以省略？
	mysql&gt; select empno,ename,sal * 12 yearsal from emp;
	+-------+--------+----------+
	| empno | ename  | yearsal  |
	+-------+--------+----------+
	|  7369 | SMITH  |  9600.00 |
	|  7499 | ALLEN  | 19200.00 |
	|  7521 | WARD   | 15000.00 |
	|  7566 | JONES  | 35700.00 |
	|  7654 | MARTIN | 15000.00 |
	|  7698 | BLAKE  | 34200.00 |
	|  7782 | CLARK  | 29400.00 |
	|  7788 | SCOTT  | 36000.00 |
	|  7839 | KING   | 60000.00 |
	|  7844 | TURNER | 18000.00 |
	|  7876 | ADAMS  | 13200.00 |
	|  7900 | JAMES  | 11400.00 |
	|  7902 | FORD   | 36000.00 |
	|  7934 | MILLER | 15600.00 |
	+-------+--------+----------+

查询所有字段？
	select * from emp; // 实际开发中不建议使用*，效率较低。
</code></pre>
<p>12、条件查询。</p>
<pre><code>	语法格式：
		select 
			字段,字段...
		from
			表名
		where
			条件;

执行顺序：先from，然后where，最后select

查询工资等于5000的员工姓名？
	select ename from emp where sal = 5000;
	+-------+
	| ename |
	+-------+
	| KING  |
	+-------+
查询SMITH的工资？
	select sal from emp where ename = 'SMITH'; // 字符串使用单引号括起来。
	+--------+
	| sal    |
	+--------+
	| 800.00 |
	+--------+
找出工资高于3000的员工？
	select ename,sal from emp where sal &gt; 3000;

	select ename,sal from emp where sal &gt;= 3000;

	select ename,sal from emp where sal &lt; 3000;

	select ename,sal from emp where sal &lt;= 3000;

找出工资不等于3000的？
	select ename,sal from emp where sal &lt;&gt; 3000;
	select ename,sal from emp where sal != 3000;

找出工资在1100和3000之间的员工，包括1100和3000？
	select ename,sal from emp where sal &gt;= 1100 and sal &lt;= 3000;

	select ename,sal from emp where sal between 1100 and 3000; // between...and...是闭区间 [1100 ~ 3000]

	select ename,sal from emp where sal between 3000 and 1100; // 查询不到任何数据

	between and在使用的时候必须左小右大。

	between and除了可以使用在数字方面之外，还可以使用在字符串方面。
	select ename from emp where ename between 'A' and 'C';
	+-------+
	| ename |
	+-------+
	| ALLEN |
	| BLAKE |
	| ADAMS |
	+-------+
	select ename from emp where ename between 'A' and 'D'; // 左闭右开。

	找出哪些人津贴为NULL？
		在数据库当中NULL不是一个值，代表什么也没有，为空。
		空不是一个值，不能用等号衡量。
		必须使用 is null或者is not null
		select ename,sal,comm from emp where comm is null;
		+--------+---------+------+
		| ename  | sal     | comm |
		+--------+---------+------+
		| SMITH  |  800.00 | NULL |
		| JONES  | 2975.00 | NULL |
		| BLAKE  | 2850.00 | NULL |
		| CLARK  | 2450.00 | NULL |
		| SCOTT  | 3000.00 | NULL |
		| KING   | 5000.00 | NULL |
		| ADAMS  | 1100.00 | NULL |
		| JAMES  |  950.00 | NULL |
		| FORD   | 3000.00 | NULL |
		| MILLER | 1300.00 | NULL |
		+--------+---------+------+
		select ename,sal,comm from emp where comm = null;
		Empty set (0.00 sec)

	找出哪些人津贴不为NULL？
		select ename,sal,comm from emp where comm is not null;
		+--------+---------+---------+
		| ename  | sal     | comm    |
		+--------+---------+---------+
		| ALLEN  | 1600.00 |  300.00 |
		| WARD   | 1250.00 |  500.00 |
		| MARTIN | 1250.00 | 1400.00 |
		| TURNER | 1500.00 |    0.00 |
		+--------+---------+---------+
	
	找出哪些人没有津贴？
		select ename,sal,comm from emp where comm is null or comm = 0;
		+--------+---------+------+
		| ename  | sal     | comm |
		+--------+---------+------+
		| SMITH  |  800.00 | NULL |
		| JONES  | 2975.00 | NULL |
		| BLAKE  | 2850.00 | NULL |
		| CLARK  | 2450.00 | NULL |
		| SCOTT  | 3000.00 | NULL |
		| KING   | 5000.00 | NULL |
		| TURNER | 1500.00 | 0.00 |
		| ADAMS  | 1100.00 | NULL |
		| JAMES  |  950.00 | NULL |
		| FORD   | 3000.00 | NULL |
		| MILLER | 1300.00 | NULL |
		+--------+---------+------+
	
	找出工作岗位是MANAGER和SALESMAN的员工？
		select ename,job from emp where job = 'MANAGER' or job = 'SALESMAN';
		+--------+----------+
		| ename  | job      |
		+--------+----------+
		| ALLEN  | SALESMAN |
		| WARD   | SALESMAN |
		| JONES  | MANAGER  |
		| MARTIN | SALESMAN |
		| BLAKE  | MANAGER  |
		| CLARK  | MANAGER  |
		| TURNER | SALESMAN |
		+--------+----------+
	
	and和or联合起来用：找出薪资大于1000的并且部门编号是20或30部门的员工。
		select ename,sal,deptno from emp where sal &gt; 1000 and deptno = 20 or deptno = 30; // 错误的
		select ename,sal,deptno from emp where sal &gt; 1000 and (deptno = 20 or deptno = 30); // 正确的。
		注意：当运算符的优先级不确定的时候加小括号。
	
	in等同于or：找出工作岗位是MANAGER和SALESMAN的员工？
		select ename,job from emp where job = 'SALESMAN' or job = 'MANAGER';
		select ename,job from emp where job in('SALESMAN', 'MANAGER');

		select ename,job from emp where sal in(800, 5000); // in后面的值不是区间，是具体的值。
		+-------+-----------+
		| ename | job       |
		+-------+-----------+
		| SMITH | CLERK     |
		| KING  | PRESIDENT |
		+-------+-----------+
	
	not in: 不在这几个值当中。
		select ename,job from emp where sal not in(800, 5000);
	
	模糊查询like ? 
		找出名字当中含有O的？
			（在模糊查询当中，必须掌握两个特殊的符号，一个是%，一个是_）
			%代表任意多个字符，_代表任意1个字符。
			select ename from emp where ename like '%O%';
			+-------+
			| ename |
			+-------+
			| JONES |
			| SCOTT |
			| FORD  |
			+-------+
		找出名字中第二个字母是A的？
			select ename from emp where ename like '_A%';
			+--------+
			| ename  |
			+--------+
			| WARD   |
			| MARTIN |
			| JAMES  |
			+--------+
		找出名字中有下划线的？
			mysql&gt; select * from t_user;
			+------+----------+
			| id   | name     |
			+------+----------+
			|    1 | zhangsan |
			|    2 | lisi     |
			|    3 | WANG_WU  |
			+------+----------+
			select name from t_user where name like '%_%';
			+----------+
			| name     |
			+----------+
			| zhangsan |
			| lisi     |
			| WANG_WU  |
			+----------+
			select name from t_user where name like '%\_%';
			+---------+
			| name    |
			+---------+
			| WANG_WU |
			+---------+

		找出名字中最后一个字母是T的？
			select ename from emp where ename like '%T';
			+-------+
			| ename |
			+-------+
			| SCOTT | 
			+-------+
</code></pre>
<p>13、排序（升序、降序）</p>
<p>按照工资升序，找出员工名和薪资？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	select </span><br><span class="line">		ename,sal </span><br><span class="line">	from </span><br><span class="line">		emp </span><br><span class="line">	order by</span><br><span class="line">		sal;</span><br><span class="line">+--------+---------+</span><br><span class="line">| ename  | sal     |</span><br><span class="line">+--------+---------+</span><br><span class="line">| SMITH  |  800.00 |</span><br><span class="line">| JAMES  |  950.00 |</span><br><span class="line">| ADAMS  | 1100.00 |</span><br><span class="line">| WARD   | 1250.00 |</span><br><span class="line">| MARTIN | 1250.00 |</span><br><span class="line">| MILLER | 1300.00 |</span><br><span class="line">| TURNER | 1500.00 |</span><br><span class="line">| ALLEN  | 1600.00 |</span><br><span class="line">| CLARK  | 2450.00 |</span><br><span class="line">| BLAKE  | 2850.00 |</span><br><span class="line">| JONES  | 2975.00 |</span><br><span class="line">| FORD   | 3000.00 |</span><br><span class="line">| SCOTT  | 3000.00 |</span><br><span class="line">| KING   | 5000.00 |</span><br><span class="line">+--------+---------+</span><br><span class="line">注意：默认是升序。怎么指定升序或者降序呢？asc表示升序，desc表示降序。</span><br><span class="line">	select ename , sal from emp order by sal; // 升序</span><br><span class="line">	select ename , sal from emp order by sal asc; // 升序</span><br><span class="line">	select ename , sal from emp order by sal desc; // 降序。</span><br><span class="line"></span><br><span class="line">按照工资的降序排列，当工资相同的时候再按照名字的升序排列。</span><br><span class="line">	select ename,sal from emp order by sal desc;</span><br><span class="line">	select ename,sal from emp order by sal desc , ename asc;</span><br><span class="line">	注意：越靠前的字段越能起到主导作用。只有当前面的字段无法完成排序的时候，才会启用后面的字段。</span><br><span class="line"></span><br><span class="line">找出工作岗位是SALESMAN的员工，并且要求按照薪资的降序排列。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select </span><br><span class="line">		ename,job,sal</span><br><span class="line">	from</span><br><span class="line">		emp</span><br><span class="line">	where </span><br><span class="line">		job = &#x27;SALESMAN&#x27;</span><br><span class="line">	order by</span><br><span class="line">		sal desc;</span><br><span class="line">+--------+----------+---------+</span><br><span class="line">| ename  | job      | sal     |</span><br><span class="line">+--------+----------+---------+</span><br><span class="line">| ALLEN  | SALESMAN | 1600.00 |</span><br><span class="line">| TURNER | SALESMAN | 1500.00 |</span><br><span class="line">| WARD   | SALESMAN | 1250.00 |</span><br><span class="line">| MARTIN | SALESMAN | 1250.00 |</span><br><span class="line">+--------+----------+---------+</span><br></pre></td></tr></table></figure>
<pre><code>select 
	字段						3
from
	表名						1
where
	条件						2
order by
	....						4

order by是最后执行的。
</code></pre>
<p>14、分组函数？</p>
<pre><code>	count 计数
	sum 求和
	avg 平均值
	max 最大值
	min 最小值
记住：所有的分组函数都是对“某一组”数据进行操作的。

找出工资总和？
	select sum(sal) from emp;
找出最高工资？
	select max(sal) from emp;
找出最低工资？
	select min(sal) from emp;
找出平均工资？
	select avg(sal) from emp;
找出总人数？
	select count(*) from emp;
	select count(ename) from emp;

分组函数一共5个。
分组函数还有另一个名字：多行处理函数。
多行处理函数的特点：输入多行，最终输出的结果是1行。

分组函数自动忽略NULL。
	select count(comm) from emp;
	+-------------+
	| count(comm) |
	+-------------+
	|           4 |
	+-------------+

	select sum(comm) from emp;
	+-----------+
	| sum(comm) |
	+-----------+
	|   2200.00 |
	+-----------+

	select sum(comm) from emp where comm is not null; // 不需要额外添加这个过滤条件。sum函数自动忽略NULL。

	找出工资高于平均工资的员工？
		select avg(sal) from emp; // 平均工资
		+-------------+
		| avg(sal)    |
		+-------------+
		| 2073.214286 |
		+-------------+

		select ename,sal from emp where sal &gt; avg(sal); //ERROR 1111 (HY000): Invalid use of group function
		思考以上的错误信息：无效的使用了分组函数？
			原因：SQL语句当中有一个语法规则，分组函数不可直接使用在where子句当中。why????
			怎么解释？
				因为group by是在where执行之后才会执行的。
			
			select		5
				..			
			from			1
				..
			where			2
				..
			group by		3
				..
			having		4
				..
			order by		6
				..

count(*)和count(具体的某个字段)，他们有什么区别？
	count(*):不是统计某个字段中数据的个数，而是统计总记录条数。（和某个字段无关）
	count(comm): 表示统计comm字段中不为NULL的数据总数量。

分组函数也能组合起来用：
	select count(*),sum(sal),avg(sal),max(sal),min(sal) from emp;

	+----------+----------+-------------+----------+----------+
	| count(*) | sum(sal) | avg(sal)    | max(sal) | min(sal) |
	+----------+----------+-------------+----------+----------+
	|       14 | 29025.00 | 2073.214286 |  5000.00 |   800.00 |
	+----------+----------+-------------+----------+----------+

找出工资高于平均工资的员工？
	第一步：找出平均工资
		select avg(sal) from emp;
		+-------------+
		| avg(sal)    |
		+-------------+
		| 2073.214286 |
		+-------------+
	第二步：找出高于平均工资的员工
		select ename,sal from emp where sal &gt; 2073.214286;
		+-------+---------+
		| ename | sal     |
		+-------+---------+
		| JONES | 2975.00 |
		| BLAKE | 2850.00 |
		| CLARK | 2450.00 |
		| SCOTT | 3000.00 |
		| KING  | 5000.00 |
		| FORD  | 3000.00 |
		+-------+---------+

	可合并为	select ename,sal from emp where sal &gt; (select avg(sal) from emp);
</code></pre>
<p>15、单行处理函数<br>
什么是单行处理函数？<br>
输入一行，输出一行。</p>
<pre><code>计算每个员工的年薪？
	select ename,(sal+comm)*12 as yearsal from emp;
	重点：所有数据库都是这样规定的，只要有NULL参与的运算结果一定是NULL。
	使用ifnull函数：
	select ename,(sal+ifnull(comm,0))*12 as yearsal from emp;

ifnull() 空处理函数？
	ifnull(可能为NULL的数据,被当做什么处理) ： 属于单行处理函数。
	select ename,ifnull(comm,0) as comm from emp;
	+--------+---------+
	| ename  | comm    |
	+--------+---------+
	| SMITH  |    0.00 |
	| ALLEN  |  300.00 |
	| WARD   |  500.00 |
	| JONES  |    0.00 |
	| MARTIN | 1400.00 |
	| BLAKE  |    0.00 |
	| CLARK  |    0.00 |
	| SCOTT  |    0.00 |
	| KING   |    0.00 |
	| TURNER |    0.00 |
	| ADAMS  |    0.00 |
	| JAMES  |    0.00 |
	| FORD   |    0.00 |
	| MILLER |    0.00 |
	+--------+---------+
</code></pre>
<p>16、group by 和 having</p>
<pre><code>group by ： 按照某个字段或者某些字段进行分组。
having : having是对分组之后的数据进行再次过滤。

案例：找出每个工作岗位的最高薪资。
select max(sal),job from emp group by job;

+----------+-----------+
| max(sal) | job       |
+----------+-----------+
|  3000.00 | ANALYST   |
|  1300.00 | CLERK     |
|  2975.00 | MANAGER   |
|  5000.00 | PRESIDENT |
|  1600.00 | SALESMAN  |
+----------+-----------+
</code></pre>
<p>​</p>
<pre><code>注意：分组函数一般都会和group by联合使用，这也是为什么它被称为分组函数的原因。
并且任何一个分组函数（count sum avg max min）都是在group by语句执行结束之后才会执行的。
当一条sql语句没有group by的话，整张表的数据会自成一组。

select ename,max(sal),job from emp group by job;
以上在mysql当中，查询结果是有的，但是结果没有意义，在Oracle数据库当中会报错。语法错误。
Oracle的语法规则比MySQL语法规则严谨。
记住一个规则：当一条语句中有group by的话，select后面只能跟分组函数和参与分组的字段。

每个工作岗位的平均薪资？
	select job,avg(sal) from emp group by job;
	+-----------+-------------+
	| job       | avg(sal)    |
	+-----------+-------------+
	| ANALYST   | 3000.000000 |
	| CLERK     | 1037.500000 |
	| MANAGER   | 2758.333333 |
	| PRESIDENT | 5000.000000 |
	| SALESMAN  | 1400.000000 |
	+-----------+-------------+

多个字段能不能联合起来一块分组？
案例：找出每个部门不同工作岗位的最高薪资。
	select 
		deptno,job,max(sal)
	from
		emp
	group by
		deptno,job;

找出每个部门的最高薪资，要求显示薪资大于2900的数据。

	第一步：找出每个部门的最高薪资
	select max(sal),deptno from emp group by deptno;
	+----------+--------+
	| max(sal) | deptno |
	+----------+--------+
	|  5000.00 |     10 |
	|  3000.00 |     20 |
	|  2850.00 |     30 |
	+----------+--------+

	第二步：找出薪资大于2900
	select max(sal),deptno from emp group by deptno having max(sal) &gt; 2900; // 这种方式效率低。
	+----------+--------+
	| max(sal) | deptno |
	+----------+--------+
	|  5000.00 |     10 |
	|  3000.00 |     20 |
	+----------+--------+

	select max(sal),deptno from emp where sal &gt; 2900 group by deptno;  // 效率较高，建议能够使用where过滤的尽量使用where。
	+----------+--------+
	| max(sal) | deptno |
	+----------+--------+
	|  5000.00 |     10 |
	|  3000.00 |     20 |
	+----------+--------+

找出每个部门的平均薪资，要求显示薪资大于2000的数据。

第一步：找出每个部门的平均薪资
select deptno,avg(sal) from emp group by deptno;
+--------+-------------+
| deptno | avg(sal)    |
+--------+-------------+
|     10 | 2916.666667 |
|     20 | 2175.000000 |
|     30 | 1566.666667 |
+--------+-------------+

第二步：要求显示薪资大于2000的数据
select deptno,avg(sal) from emp group by deptno having avg(sal) &gt; 2000;	
+--------+-------------+
| deptno | avg(sal)    |
+--------+-------------+
|     10 | 2916.666667 |
|     20 | 2175.000000 |
+--------+-------------+

where后面不能使用分组函数：
	select deptno,avg(sal) from emp where avg(sal) &gt; 2000 group by deptno;	// 错误了。
	这种情况只能使用having过滤。
</code></pre>
<p>17、总结一个完整的DQL语句怎么写？</p>
<pre><code>select		    5
	..
from			1	
	..
where			2
	..
group by		3
	..
having		    4
	..
order by		6
	..
</code></pre>
<h3 id="第二个部分">第二个部分<a title="#第二个部分" href="#第二个部分"></a></h3>
<p>1、关于查询结果集的去重？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select distinct job from emp; // distinct关键字去除重复记录。</span><br><span class="line">+-----------+</span><br><span class="line">| job       |</span><br><span class="line">+-----------+</span><br><span class="line">| CLERK     |</span><br><span class="line">| SALESMAN  |</span><br><span class="line">| MANAGER   |</span><br><span class="line">| ANALYST   |</span><br><span class="line">| PRESIDENT |</span><br><span class="line">+-----------+	</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select ename,distinct job from emp;</span><br><span class="line">以上的sql语句是错误的。</span><br><span class="line">记住：distinct只能出现在所有字段的最前面。</span><br><span class="line"></span><br><span class="line">mysql&gt; select distinct deptno,job from emp;</span><br><span class="line">+--------+-----------+</span><br><span class="line">| deptno | job       |</span><br><span class="line">+--------+-----------+</span><br><span class="line">|     20 | CLERK     |</span><br><span class="line">|     30 | SALESMAN  |</span><br><span class="line">|     20 | MANAGER   |</span><br><span class="line">|     30 | MANAGER   |</span><br><span class="line">|     10 | MANAGER   |</span><br><span class="line">|     20 | ANALYST   |</span><br><span class="line">|     10 | PRESIDENT |</span><br><span class="line">|     30 | CLERK     |</span><br><span class="line">|     10 | CLERK     |</span><br><span class="line">+--------+-----------+</span><br></pre></td></tr></table></figure>
<p>案例：统计岗位的数量？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(distinct job) from emp;</span><br><span class="line">+---------------------+</span><br><span class="line">| count(distinct job) |</span><br><span class="line">+---------------------+</span><br><span class="line">|                   5 |</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure>
<p>2、连接查询</p>
<p>2.1、什么是连接查询？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	在实际开发中，大部分的情况下都不是从单表中查询数据，一般都是多张表联合查询取出最终的结果。</span><br><span class="line">	在实际开发中，一般一个业务都会对应多张表，比如：学生和班级，起码两张表。</span><br><span class="line">		stuno		stuname			classno		classname</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">		1			zs				1			北京大兴区亦庄经济技术开发区第二中学高三1班</span><br><span class="line">		2			ls				1			北京大兴区亦庄经济技术开发区第二中学高三1班</span><br><span class="line">		...</span><br><span class="line">		学生和班级信息存储到一张表中，结果就像上面一样，数据会存在大量的重复，导致数据的冗余。</span><br></pre></td></tr></table></figure>
<p>2.2、连接查询的分类？<br>
根据语法出现的年代来划分的话，包括：<br>
SQL92（一些老的DBA可能还在使用这种语法。DBA：DataBase Administrator，数据库管理员）<br>
SQL99（比较新的语法）</p>
<pre><code>根据表的连接方式来划分，包括：
	内连接：
		等值连接
		非等值连接
		自连接
	外连接：
		左外连接（左连接）
		右外连接（右连接）
	全连接（这个不讲，很少用！）
</code></pre>
<p>2.3、在表的连接查询方面有一种现象被称为：笛卡尔积现象。（笛卡尔乘积现象）</p>
<p>案例：找出每一个员工的部门名称，要求显示员工名和部门名。<br>
EMP表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+--------+--------+</span><br><span class="line">| ename  | deptno |</span><br><span class="line">+--------+--------+</span><br><span class="line">| SMITH  |     20 |</span><br><span class="line">| ALLEN  |     30 |</span><br><span class="line">| WARD   |     30 |</span><br><span class="line">| JONES  |     20 |</span><br><span class="line">| MARTIN |     30 |</span><br><span class="line">| BLAKE  |     30 |</span><br><span class="line">| CLARK  |     10 |</span><br><span class="line">| SCOTT  |     20 |</span><br><span class="line">| KING   |     10 |</span><br><span class="line">| TURNER |     30 |</span><br><span class="line">| ADAMS  |     20 |</span><br><span class="line">| JAMES  |     30 |</span><br><span class="line">| FORD   |     20 |</span><br><span class="line">| MILLER |     10 |</span><br><span class="line">+--------+--------+</span><br></pre></td></tr></table></figure>
<p>DEPT表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+--------+------------+----------+</span><br><span class="line">| DEPTNO | DNAME      | LOC      |</span><br><span class="line">+--------+------------+----------+</span><br><span class="line">|     10 | ACCOUNTING | NEW YORK |</span><br><span class="line">|     20 | RESEARCH   | DALLAS   |</span><br><span class="line">|     30 | SALES      | CHICAGO  |</span><br><span class="line">|     40 | OPERATIONS | BOSTON   |</span><br><span class="line">+--------+------------+----------+</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ename,dname from emp,dept;</span><br><span class="line">+--------+------------+</span><br><span class="line">| ename  | dname      |</span><br><span class="line">+--------+------------+</span><br><span class="line">| SMITH  | ACCOUNTING |</span><br><span class="line">| SMITH  | RESEARCH   |</span><br><span class="line">| SMITH  | SALES      |</span><br><span class="line">| SMITH  | OPERATIONS |</span><br><span class="line">| ALLEN  | ACCOUNTING |</span><br><span class="line">| ALLEN  | RESEARCH   |</span><br><span class="line">| ALLEN  | SALES      |</span><br><span class="line">| ALLEN  | OPERATIONS |</span><br><span class="line">............</span><br><span class="line">56 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>笛卡尔积现象：当两张表进行连接查询的时候，没有任何条件进行限制，最终的查询结果条数是两张表记录条数的乘积。</p>
<p>关于表的别名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select e.ename,d.dname from emp e,dept d;</span><br><span class="line">表的别名有什么好处？</span><br><span class="line">	第一：执行效率高。</span><br><span class="line">	第二：可读性好。</span><br></pre></td></tr></table></figure>
<p>2.4、怎么避免笛卡尔积现象？当然是加条件进行过滤。</p>
<pre><code>思考：避免了笛卡尔积现象，会减少记录的匹配次数吗？
	不会，次数还是56次。只不过显示的是有效记录。

案例：找出每一个员工的部门名称，要求显示员工名和部门名。

select	
		e.ename,d.dname
	from
		emp e , dept d
	where
		e.deptno = d.deptno; //SQL92，以后不用。
+--------+------------+
| ename  | dname      |
+--------+------------+
| CLARK  | ACCOUNTING |
| KING   | ACCOUNTING |
| MILLER | ACCOUNTING |
| SMITH  | RESEARCH   |
| JONES  | RESEARCH   |
| SCOTT  | RESEARCH   |
| ADAMS  | RESEARCH   |
| FORD   | RESEARCH   |
| ALLEN  | SALES      |
| WARD   | SALES      |
| MARTIN | SALES      |
| BLAKE  | SALES      |
| TURNER | SALES      |
| JAMES  | SALES      |
+--------+------------+
</code></pre>
<p>2.5、内连接之等值连接：最大特点是：条件是等量关系。</p>
<p>案例：查询每个员工的部门名称，要求显示员工名和部门名。</p>
<pre><code>SQL92:（太老，不用了）
	select 
		e.ename,d.dname
	from
		emp e, dept d
	where
		e.deptno = d.deptno;

SQL99：（常用的）
	select 
		e.ename,d.dname
	from
		emp e
	join
		dept d
	on
		e.deptno = d.deptno;
// inner可以省略的，带着inner目的是可读性好一些。
select 
	e.ename,d.dname
from
	emp e
inner join
	dept d
on
	e.deptno = d.deptno;

语法：
	...
		A
	join
		B
	on
		连接条件
	where
		...

SQL99语法结构更清晰一些：表的连接条件和后来的where条件分离了。

+--------+------------+
| ename  | dname      |
+--------+------------+
| CLARK  | ACCOUNTING |
| KING   | ACCOUNTING |
| MILLER | ACCOUNTING |
| SMITH  | RESEARCH   |
| JONES  | RESEARCH   |
| SCOTT  | RESEARCH   |
| ADAMS  | RESEARCH   |
| FORD   | RESEARCH   |
| ALLEN  | SALES      |
| WARD   | SALES      |
| MARTIN | SALES      |
| BLAKE  | SALES      |
| TURNER | SALES      |
| JAMES  | SALES      |
+--------+------------+
</code></pre>
<p>2.6、内连接之非等值连接：最大的特点是：连接条件中的关系是非等量关系。</p>
<p>案例：找出每个员工的工资等级，要求显示员工名、工资、工资等级。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select ename,sal from emp; e</span><br><span class="line">+--------+---------+</span><br><span class="line">| ename  | sal     |</span><br><span class="line">+--------+---------+</span><br><span class="line">| SMITH  |  800.00 |</span><br><span class="line">| ALLEN  | 1600.00 |</span><br><span class="line">| WARD   | 1250.00 |</span><br><span class="line">| JONES  | 2975.00 |</span><br><span class="line">| MARTIN | 1250.00 |</span><br><span class="line">| BLAKE  | 2850.00 |</span><br><span class="line">| CLARK  | 2450.00 |</span><br><span class="line">| SCOTT  | 3000.00 |</span><br><span class="line">| KING   | 5000.00 |</span><br><span class="line">| TURNER | 1500.00 |</span><br><span class="line">| ADAMS  | 1100.00 |</span><br><span class="line">| JAMES  |  950.00 |</span><br><span class="line">| FORD   | 3000.00 |</span><br><span class="line">| MILLER | 1300.00 |</span><br><span class="line">+--------+---------+</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from salgrade; s</span><br><span class="line">+-------+-------+-------+ </span><br><span class="line">| GRADE | LOSAL | HISAL |</span><br><span class="line">+-------+-------+-------+</span><br><span class="line">|     1 |   700 |  1200 |</span><br><span class="line">|     2 |  1201 |  1400 |</span><br><span class="line">|     3 |  1401 |  2000 |</span><br><span class="line">|     4 |  2001 |  3000 |</span><br><span class="line">|     5 |  3001 |  9999 |</span><br><span class="line">+-------+-------+-------+</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select </span><br><span class="line">	e.ename,e.sal,s.grade</span><br><span class="line">from</span><br><span class="line">	emp e</span><br><span class="line">join</span><br><span class="line">	salgrade s</span><br><span class="line">on</span><br><span class="line">	e.sal between s.losal and s.hisal;</span><br><span class="line"></span><br><span class="line">// inner可以省略</span><br><span class="line">select </span><br><span class="line">	e.ename,e.sal,s.grade</span><br><span class="line">from</span><br><span class="line">	emp e</span><br><span class="line">inner join</span><br><span class="line">	salgrade s</span><br><span class="line">on</span><br><span class="line">	e.sal between s.losal and s.hisal;</span><br><span class="line"></span><br><span class="line">+--------+---------+-------+</span><br><span class="line">| ename  | sal     | grade |</span><br><span class="line">+--------+---------+-------+</span><br><span class="line">| SMITH  |  800.00 |     1 |</span><br><span class="line">| ALLEN  | 1600.00 |     3 |</span><br><span class="line">| WARD   | 1250.00 |     2 |</span><br><span class="line">| JONES  | 2975.00 |     4 |</span><br><span class="line">| MARTIN | 1250.00 |     2 |</span><br><span class="line">| BLAKE  | 2850.00 |     4 |</span><br><span class="line">| CLARK  | 2450.00 |     4 |</span><br><span class="line">| SCOTT  | 3000.00 |     4 |</span><br><span class="line">| KING   | 5000.00 |     5 |</span><br><span class="line">| TURNER | 1500.00 |     3 |</span><br><span class="line">| ADAMS  | 1100.00 |     1 |</span><br><span class="line">| JAMES  |  950.00 |     1 |</span><br><span class="line">| FORD   | 3000.00 |     4 |</span><br><span class="line">| MILLER | 1300.00 |     2 |</span><br><span class="line">+--------+---------+-------+</span><br></pre></td></tr></table></figure>
<p>2.7、自连接：最大的特点是：一张表看做两张表。自己连接自己。</p>
<p>案例：找出每个员工的上级领导，要求显示员工名和对应的领导名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select empno,ename,mgr from emp;</span><br><span class="line">emp a 员工表</span><br><span class="line">+-------+--------+------+</span><br><span class="line">| empno | ename  | mgr  |</span><br><span class="line">+-------+--------+------+</span><br><span class="line">|  7369 | SMITH  | 7902 |</span><br><span class="line">|  7499 | ALLEN  | 7698 |</span><br><span class="line">|  7521 | WARD   | 7698 |</span><br><span class="line">|  7566 | JONES  | 7839 |</span><br><span class="line">|  7654 | MARTIN | 7698 |</span><br><span class="line">|  7698 | BLAKE  | 7839 |</span><br><span class="line">|  7782 | CLARK  | 7839 |</span><br><span class="line">|  7788 | SCOTT  | 7566 |</span><br><span class="line">|  7839 | KING   | NULL |</span><br><span class="line">|  7844 | TURNER | 7698 |</span><br><span class="line">|  7876 | ADAMS  | 7788 |</span><br><span class="line">|  7900 | JAMES  | 7698 |</span><br><span class="line">|  7902 | FORD   | 7566 |</span><br><span class="line">|  7934 | MILLER | 7782 |</span><br><span class="line">+-------+--------+------+</span><br><span class="line">emp b 领导表</span><br><span class="line">+-------+--------+</span><br><span class="line">| empno | ename  |</span><br><span class="line">+-------+--------+</span><br><span class="line">|  7566 | JONES  |</span><br><span class="line">|  7698 | BLAKE  |</span><br><span class="line">|  7782 | CLARK  |</span><br><span class="line">|  7788 | SCOTT  |</span><br><span class="line">|  7839 | KING   |</span><br><span class="line">|  7902 | FORD   |</span><br><span class="line">+-------+--------+</span><br></pre></td></tr></table></figure>
<p>员工的领导编号 = 领导的员工编号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select </span><br><span class="line">	a.ename as &#x27;员工名&#x27;,b.ename as &#x27;领导名&#x27;</span><br><span class="line">from</span><br><span class="line">	emp a</span><br><span class="line">inner join</span><br><span class="line">	emp b</span><br><span class="line">on</span><br><span class="line">	a.mgr = b.empno;</span><br><span class="line"></span><br><span class="line">+--------+--------+</span><br><span class="line">| 员工名 | 领导名 |</span><br><span class="line">+--------+--------+</span><br><span class="line">| SMITH  | FORD   |</span><br><span class="line">| ALLEN  | BLAKE  |</span><br><span class="line">| WARD   | BLAKE  |</span><br><span class="line">| JONES  | KING   |</span><br><span class="line">| MARTIN | BLAKE  |</span><br><span class="line">| BLAKE  | KING   |</span><br><span class="line">| CLARK  | KING   |</span><br><span class="line">| SCOTT  | JONES  |</span><br><span class="line">| TURNER | BLAKE  |</span><br><span class="line">| ADAMS  | SCOTT  |</span><br><span class="line">| JAMES  | BLAKE  |</span><br><span class="line">| FORD   | JONES  |</span><br><span class="line">| MILLER | CLARK  |</span><br><span class="line">+--------+--------+</span><br></pre></td></tr></table></figure>
<p>2.8、外连接？</p>
<p>什么是外连接，和内连接有什么区别？</p>
<pre><code>内连接：
	假设A和B表进行连接，使用内连接的话，凡是A表和B表能够匹配上的记录查询出来，这就是内连接。
	AB两张表没有主副之分，两张表是平等的。

外连接：
	假设A和B表进行连接，使用外连接的话，AB两张表中有一张表是主表，一张表是副表，主要查询主表中
	的数据，捎带着查询副表，当副表中的数据没有和主表中的数据匹配上，副表自动模拟出NULL与之匹配。

外连接的分类？
	左外连接（左连接）：表示左边的这张表是主表。
	右外连接（右连接）：表示右边的这张表是主表。

	左连接有右连接的写法，右连接也会有对应的左连接的写法。
</code></pre>
<p>案例：找出每个员工的上级领导？（所有员工必须全部查询出来。）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">emp a 员工表</span><br><span class="line">+-------+--------+------+</span><br><span class="line">| empno | ename  | mgr  |</span><br><span class="line">+-------+--------+------+</span><br><span class="line">|  7369 | SMITH  | 7902 |</span><br><span class="line">|  7499 | ALLEN  | 7698 |</span><br><span class="line">|  7521 | WARD   | 7698 |</span><br><span class="line">|  7566 | JONES  | 7839 |</span><br><span class="line">|  7654 | MARTIN | 7698 |</span><br><span class="line">|  7698 | BLAKE  | 7839 |</span><br><span class="line">|  7782 | CLARK  | 7839 |</span><br><span class="line">|  7788 | SCOTT  | 7566 |</span><br><span class="line">|  7839 | KING   | NULL |</span><br><span class="line">|  7844 | TURNER | 7698 |</span><br><span class="line">|  7876 | ADAMS  | 7788 |</span><br><span class="line">|  7900 | JAMES  | 7698 |</span><br><span class="line">|  7902 | FORD   | 7566 |</span><br><span class="line">|  7934 | MILLER | 7782 |</span><br><span class="line">+-------+--------+------+</span><br><span class="line">emp b 领导表</span><br><span class="line">+-------+--------+</span><br><span class="line">| empno | ename  |</span><br><span class="line">+-------+--------+</span><br><span class="line">|  7566 | JONES  |</span><br><span class="line">|  7698 | BLAKE  |</span><br><span class="line">|  7782 | CLARK  |</span><br><span class="line">|  7788 | SCOTT  |</span><br><span class="line">|  7839 | KING   |</span><br><span class="line">|  7902 | FORD   |</span><br><span class="line">+-------+--------+</span><br></pre></td></tr></table></figure>
<p>内连接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select </span><br><span class="line">	a.ename &#x27;员工&#x27;, b.ename &#x27;领导&#x27;</span><br><span class="line">from</span><br><span class="line">	emp a</span><br><span class="line">join</span><br><span class="line">	emp b</span><br><span class="line">on</span><br><span class="line">	a.mgr = b.empno;</span><br><span class="line"></span><br><span class="line">外连接：（左外连接/左连接）</span><br><span class="line">select </span><br><span class="line">	a.ename &#x27;员工&#x27;, b.ename &#x27;领导&#x27;</span><br><span class="line">from</span><br><span class="line">	emp a</span><br><span class="line">left join</span><br><span class="line">	emp b</span><br><span class="line">on</span><br><span class="line">	a.mgr = b.empno;</span><br><span class="line"></span><br><span class="line">// outer是可以省略的。</span><br><span class="line">select </span><br><span class="line">	a.ename &#x27;员工&#x27;, b.ename &#x27;领导&#x27;</span><br><span class="line">from</span><br><span class="line">	emp a</span><br><span class="line">left outer join</span><br><span class="line">	emp b</span><br><span class="line">on</span><br><span class="line">	a.mgr = b.empno;</span><br><span class="line"></span><br><span class="line">外连接：（右外连接/右连接）</span><br><span class="line">select </span><br><span class="line">	a.ename &#x27;员工&#x27;, b.ename &#x27;领导&#x27;</span><br><span class="line">from</span><br><span class="line">	emp b</span><br><span class="line">right join</span><br><span class="line">	emp a</span><br><span class="line">on</span><br><span class="line">	a.mgr = b.empno;</span><br><span class="line"></span><br><span class="line">// outer可以省略。</span><br><span class="line">select </span><br><span class="line">	a.ename &#x27;员工&#x27;, b.ename &#x27;领导&#x27;</span><br><span class="line">from</span><br><span class="line">	emp b</span><br><span class="line">right outer join</span><br><span class="line">	emp a</span><br><span class="line">on</span><br><span class="line">	a.mgr = b.empno;</span><br><span class="line"></span><br><span class="line">+--------+-------+</span><br><span class="line">| 员工      | 领导    |</span><br><span class="line">+--------+-------+</span><br><span class="line">| SMITH  | FORD  |</span><br><span class="line">| ALLEN  | BLAKE |</span><br><span class="line">| WARD   | BLAKE |</span><br><span class="line">| JONES  | KING  |</span><br><span class="line">| MARTIN | BLAKE |</span><br><span class="line">| BLAKE  | KING  |</span><br><span class="line">| CLARK  | KING  |</span><br><span class="line">| SCOTT  | JONES |</span><br><span class="line">| KING   | NULL  |</span><br><span class="line">| TURNER | BLAKE |</span><br><span class="line">| ADAMS  | SCOTT |</span><br><span class="line">| JAMES  | BLAKE |</span><br><span class="line">| FORD   | JONES |</span><br><span class="line">| MILLER | CLARK |</span><br><span class="line">+--------+-------+</span><br></pre></td></tr></table></figure>
<p>外连接最重要的特点是：主表的数据无条件的全部查询出来。</p>
<p>案例：找出哪个部门没有员工？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EMP表</span><br><span class="line">+-------+--------+-----------+------+------------+---------+---------+--------+</span><br><span class="line">| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |</span><br><span class="line">+-------+--------+-----------+------+------------+---------+---------+--------+</span><br><span class="line">|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |</span><br><span class="line">|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |</span><br><span class="line">|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |</span><br><span class="line">|  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |</span><br><span class="line">|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |</span><br><span class="line">|  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |</span><br><span class="line">|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 |</span><br><span class="line">|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |</span><br><span class="line">|  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |</span><br><span class="line">|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |</span><br><span class="line">|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |</span><br><span class="line">|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |</span><br><span class="line">|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |</span><br><span class="line">|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |</span><br><span class="line">+-------+--------+-----------+------+------------+---------+---------+--------+</span><br><span class="line">DEPT</span><br><span class="line">+--------+------------+----------+</span><br><span class="line">| DEPTNO | DNAME      | LOC      |</span><br><span class="line">+--------+------------+----------+</span><br><span class="line">|     10 | ACCOUNTING | NEW YORK |</span><br><span class="line">|     20 | RESEARCH   | DALLAS   |</span><br><span class="line">|     30 | SALES      | CHICAGO  |</span><br><span class="line">|     40 | OPERATIONS | BOSTON   |</span><br><span class="line">+--------+------------+----------+</span><br><span class="line"></span><br><span class="line">select </span><br><span class="line">	d.*</span><br><span class="line">from</span><br><span class="line">	emp e</span><br><span class="line">right join</span><br><span class="line">	dept d</span><br><span class="line">on</span><br><span class="line">	e.deptno = d.deptno</span><br><span class="line">where</span><br><span class="line">	e.empno is null;</span><br><span class="line"></span><br><span class="line">+--------+------------+--------+</span><br><span class="line">| DEPTNO | DNAME      | LOC    |</span><br><span class="line">+--------+------------+--------+</span><br><span class="line">|     40 | OPERATIONS | BOSTON |</span><br><span class="line">+--------+------------+--------+</span><br><span class="line"></span><br><span class="line">2.9、三张表怎么连接查询？</span><br><span class="line">案例：找出每一个员工的部门名称以及工资等级。</span><br><span class="line">EMP e</span><br><span class="line">+-------+--------+---------+--------+</span><br><span class="line">| empno | ename  | sal     | deptno |</span><br><span class="line">+-------+--------+---------+--------+</span><br><span class="line">|  7369 | SMITH  |  800.00 |     20 |</span><br><span class="line">|  7499 | ALLEN  | 1600.00 |     30 |</span><br><span class="line">|  7521 | WARD   | 1250.00 |     30 |</span><br><span class="line">|  7566 | JONES  | 2975.00 |     20 |</span><br><span class="line">|  7654 | MARTIN | 1250.00 |     30 |</span><br><span class="line">|  7698 | BLAKE  | 2850.00 |     30 |</span><br><span class="line">|  7782 | CLARK  | 2450.00 |     10 |</span><br><span class="line">|  7788 | SCOTT  | 3000.00 |     20 |</span><br><span class="line">|  7839 | KING   | 5000.00 |     10 |</span><br><span class="line">|  7844 | TURNER | 1500.00 |     30 |</span><br><span class="line">|  7876 | ADAMS  | 1100.00 |     20 |</span><br><span class="line">|  7900 | JAMES  |  950.00 |     30 |</span><br><span class="line">|  7902 | FORD   | 3000.00 |     20 |</span><br><span class="line">|  7934 | MILLER | 1300.00 |     10 |</span><br><span class="line">+-------+--------+---------+--------+</span><br><span class="line">DEPT d</span><br><span class="line">+--------+------------+----------+</span><br><span class="line">| DEPTNO | DNAME      | LOC      |</span><br><span class="line">+--------+------------+----------+</span><br><span class="line">|     10 | ACCOUNTING | NEW YORK |</span><br><span class="line">|     20 | RESEARCH   | DALLAS   |</span><br><span class="line">|     30 | SALES      | CHICAGO  |</span><br><span class="line">|     40 | OPERATIONS | BOSTON   |</span><br><span class="line">+--------+------------+----------+</span><br><span class="line">SALGRADE s</span><br><span class="line">+-------+-------+-------+</span><br><span class="line">| GRADE | LOSAL | HISAL |</span><br><span class="line">+-------+-------+-------+</span><br><span class="line">|     1 |   700 |  1200 |</span><br><span class="line">|     2 |  1201 |  1400 |</span><br><span class="line">|     3 |  1401 |  2000 |</span><br><span class="line">|     4 |  2001 |  3000 |</span><br><span class="line">|     5 |  3001 |  9999 |</span><br><span class="line">+-------+-------+-------+</span><br><span class="line"></span><br><span class="line">注意，解释一下：</span><br><span class="line">	....</span><br><span class="line">		A</span><br><span class="line">	join</span><br><span class="line">		B</span><br><span class="line">	join</span><br><span class="line">		C</span><br><span class="line">	on</span><br><span class="line">		...</span><br></pre></td></tr></table></figure>
<pre><code>表示：A表和B表先进行表连接，连接之后A表继续和C表进行连接。

select 
	e.ename,d.dname,s.grade
from
	emp e
join
	dept d
on
	e.deptno = d.deptno
join
	salgrade s
on
	e.sal between s.losal and s.hisal;

+--------+------------+-------+
| ename  | dname      | grade |
+--------+------------+-------+
| SMITH  | RESEARCH   |     1 |
| ALLEN  | SALES      |     3 |
| WARD   | SALES      |     2 |
| JONES  | RESEARCH   |     4 |
| MARTIN | SALES      |     2 |
| BLAKE  | SALES      |     4 |
| CLARK  | ACCOUNTING |     4 |
| SCOTT  | RESEARCH   |     4 |
| KING   | ACCOUNTING |     5 |
| TURNER | SALES      |     3 |
| ADAMS  | RESEARCH   |     1 |
| JAMES  | SALES      |     1 |
| FORD   | RESEARCH   |     4 |
| MILLER | ACCOUNTING |     2 |
+--------+------------+-------+
</code></pre>
<p>案例：找出每一个员工的部门名称、工资等级、以及上级领导。</p>
<pre><code>	select 
		e.ename '员工',d.dname,s.grade,e1.ename '领导'
	from
		emp e
	join
		dept d
	on
		e.deptno = d.deptno
	join
		salgrade s
	on
		e.sal between s.losal and s.hisal
	left join
		emp e1
	on
		e.mgr = e1.empno;
+--------+------------+-------+-------+
| 员工      | dname      | grade | 领导    |
+--------+------------+-------+-------+
| SMITH  | RESEARCH   |     1 | FORD  |
| ALLEN  | SALES      |     3 | BLAKE |
| WARD   | SALES      |     2 | BLAKE |
| JONES  | RESEARCH   |     4 | KING  |
| MARTIN | SALES      |     2 | BLAKE |
| BLAKE  | SALES      |     4 | KING  |
| CLARK  | ACCOUNTING |     4 | KING  |
| SCOTT  | RESEARCH   |     4 | JONES |
| KING   | ACCOUNTING |     5 | NULL  |
| TURNER | SALES      |     3 | BLAKE |
| ADAMS  | RESEARCH   |     1 | SCOTT |
| JAMES  | SALES      |     1 | BLAKE |
| FORD   | RESEARCH   |     4 | JONES |
| MILLER | ACCOUNTING |     2 | CLARK |
+--------+------------+-------+-------+
</code></pre>
<p>3、子查询</p>
<p>3.1、什么是子查询？子查询都可以出现在哪里？<br>
select语句当中嵌套select语句，被嵌套的select语句是子查询。<br>
子查询可以出现在哪里？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select</span><br><span class="line">	..(select).</span><br><span class="line">from</span><br><span class="line">	..(select).</span><br><span class="line">where</span><br><span class="line">	..(select).</span><br></pre></td></tr></table></figure>
<p>3.2、where子句中使用子查询</p>
<p>案例：找出高于平均薪资的员工信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from emp where sal &gt; avg(sal); //错误的写法，where后面不能直接使用分组函数。</span><br><span class="line"></span><br><span class="line">第一步：找出平均薪资</span><br><span class="line">	select avg(sal) from emp;</span><br><span class="line">	+-------------+</span><br><span class="line">	| avg(sal)    |</span><br><span class="line">	+-------------+</span><br><span class="line">	| 2073.214286 |</span><br><span class="line">	+-------------+</span><br><span class="line">第二步：where过滤</span><br><span class="line">	select * from emp where sal &gt; 2073.214286;</span><br><span class="line">	+-------+-------+-----------+------+------------+---------+------+--------+</span><br><span class="line">	| EMPNO | ENAME | JOB       | MGR  | HIREDATE   | SAL     | COMM | DEPTNO |</span><br><span class="line">	+-------+-------+-----------+------+------------+---------+------+--------+</span><br><span class="line">	|  7566 | JONES | MANAGER   | 7839 | 1981-04-02 | 2975.00 | NULL |     20 |</span><br><span class="line">	|  7698 | BLAKE | MANAGER   | 7839 | 1981-05-01 | 2850.00 | NULL |     30 |</span><br><span class="line">	|  7782 | CLARK | MANAGER   | 7839 | 1981-06-09 | 2450.00 | NULL |     10 |</span><br><span class="line">	|  7788 | SCOTT | ANALYST   | 7566 | 1987-04-19 | 3000.00 | NULL |     20 |</span><br><span class="line">	|  7839 | KING  | PRESIDENT | NULL | 1981-11-17 | 5000.00 | NULL |     10 |</span><br><span class="line">	|  7902 | FORD  | ANALYST   | 7566 | 1981-12-03 | 3000.00 | NULL |     20 |</span><br><span class="line">	+-------+-------+-----------+------+------------+---------+------+--------+</span><br><span class="line">第一步和第二步合并：</span><br><span class="line">	select * from emp where sal &gt; (select avg(sal) from emp);</span><br></pre></td></tr></table></figure>
<p>3.3、from后面嵌套子查询</p>
<p>案例：找出每个部门平均薪水的等级。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一步：找出每个部门平均薪水（按照部门编号分组，求sal的平均值）</span><br><span class="line">select deptno,avg(sal) as avgsal from emp group by deptno;</span><br><span class="line">+--------+-------------+</span><br><span class="line">| deptno | avgsal      |</span><br><span class="line">+--------+-------------+</span><br><span class="line">|     10 | 2916.666667 |</span><br><span class="line">|     20 | 2175.000000 |</span><br><span class="line">|     30 | 1566.666667 |</span><br><span class="line">+--------+-------------+</span><br><span class="line">第二步：将以上的查询结果当做临时表t，让t表和salgrade s表连接，条件是：t.avgsal between s.losal and s.hisal</span><br><span class="line">select </span><br><span class="line">	t.*,s.grade</span><br><span class="line">from</span><br><span class="line">	(select deptno,avg(sal) as avgsal from emp group by deptno) t</span><br><span class="line">join</span><br><span class="line">	salgrade s</span><br><span class="line">on</span><br><span class="line">	t.avgsal between s.losal and s.hisal;</span><br><span class="line"></span><br><span class="line">+--------+-------------+-------+</span><br><span class="line">| deptno | avgsal      | grade |</span><br><span class="line">+--------+-------------+-------+</span><br><span class="line">|     30 | 1566.666667 |     3 |</span><br><span class="line">|     10 | 2916.666667 |     4 |</span><br><span class="line">|     20 | 2175.000000 |     4 |</span><br><span class="line">+--------+-------------+-------+</span><br></pre></td></tr></table></figure>
<p>案例：找出每个部门平均的薪水等级。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一步：找出每个员工的薪水等级。</span><br><span class="line">select e.ename,e.sal,e.deptno,s.grade from emp e join salgrade s on e.sal between s.losal and s.hisal;</span><br><span class="line">+--------+---------+--------+-------+</span><br><span class="line">| ename  | sal     | deptno | grade |</span><br><span class="line">+--------+---------+--------+-------+</span><br><span class="line">| SMITH  |  800.00 |     20 |     1 |</span><br><span class="line">| ALLEN  | 1600.00 |     30 |     3 |</span><br><span class="line">| WARD   | 1250.00 |     30 |     2 |</span><br><span class="line">| JONES  | 2975.00 |     20 |     4 |</span><br><span class="line">| MARTIN | 1250.00 |     30 |     2 |</span><br><span class="line">| BLAKE  | 2850.00 |     30 |     4 |</span><br><span class="line">| CLARK  | 2450.00 |     10 |     4 |</span><br><span class="line">| SCOTT  | 3000.00 |     20 |     4 |</span><br><span class="line">| KING   | 5000.00 |     10 |     5 |</span><br><span class="line">| TURNER | 1500.00 |     30 |     3 |</span><br><span class="line">| ADAMS  | 1100.00 |     20 |     1 |</span><br><span class="line">| JAMES  |  950.00 |     30 |     1 |</span><br><span class="line">| FORD   | 3000.00 |     20 |     4 |</span><br><span class="line">| MILLER | 1300.00 |     10 |     2 |</span><br><span class="line">+--------+---------+--------+-------+</span><br><span class="line">第二步：基于以上结果，继续按照deptno分组，求grade平均值。</span><br><span class="line">select </span><br><span class="line">	e.deptno,avg(s.grade)</span><br><span class="line">from </span><br><span class="line">	emp e </span><br><span class="line">join </span><br><span class="line">	salgrade s </span><br><span class="line">on </span><br><span class="line">	e.sal between s.losal and s.hisal</span><br><span class="line">group by</span><br><span class="line">	e.deptno;</span><br><span class="line"></span><br><span class="line">+--------+--------------+</span><br><span class="line">| deptno | avg(s.grade) |</span><br><span class="line">+--------+--------------+</span><br><span class="line">|     10 |       3.6667 |</span><br><span class="line">|     20 |       2.8000 |</span><br><span class="line">|     30 |       2.5000 |</span><br><span class="line">+--------+--------------+</span><br></pre></td></tr></table></figure>
<p>3.4、在select后面嵌套子查询。<br>
案例：找出每个员工所在的部门名称，要求显示员工名和部门名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select </span><br><span class="line">	e.ename,d.dname</span><br><span class="line">from</span><br><span class="line">	emp e</span><br><span class="line">join</span><br><span class="line">	dept d</span><br><span class="line">on</span><br><span class="line">	e.deptno = d.deptno;</span><br><span class="line"></span><br><span class="line">select </span><br><span class="line">	e.ename,(select d.dname from dept d where e.deptno = d.deptno) as dname </span><br><span class="line">from </span><br><span class="line">	emp e;</span><br><span class="line"></span><br><span class="line">+--------+------------+</span><br><span class="line">| ename  | dname      |</span><br><span class="line">+--------+------------+</span><br><span class="line">| SMITH  | RESEARCH   |</span><br><span class="line">| ALLEN  | SALES      |</span><br><span class="line">| WARD   | SALES      |</span><br><span class="line">| JONES  | RESEARCH   |</span><br><span class="line">| MARTIN | SALES      |</span><br><span class="line">| BLAKE  | SALES      |</span><br><span class="line">| CLARK  | ACCOUNTING |</span><br><span class="line">| SCOTT  | RESEARCH   |</span><br><span class="line">| KING   | ACCOUNTING |</span><br><span class="line">| TURNER | SALES      |</span><br><span class="line">| ADAMS  | RESEARCH   |</span><br><span class="line">| JAMES  | SALES      |</span><br><span class="line">| FORD   | RESEARCH   |</span><br><span class="line">| MILLER | ACCOUNTING |</span><br><span class="line">+--------+------------+</span><br></pre></td></tr></table></figure>
<p>4、union （可以将查询结果集相加）</p>
<p>案例：找出工作岗位是SALESMAN和MANAGER的员工？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一种：select ename,job from emp where job = &#x27;MANAGER&#x27; or job = &#x27;SALESMAN&#x27;;</span><br><span class="line">第二种：select ename,job from emp where job in(&#x27;MANAGER&#x27;,&#x27;SALESMAN&#x27;);</span><br><span class="line">+--------+----------+</span><br><span class="line">| ename  | job      |</span><br><span class="line">+--------+----------+</span><br><span class="line">| ALLEN  | SALESMAN |</span><br><span class="line">| WARD   | SALESMAN |</span><br><span class="line">| JONES  | MANAGER  |</span><br><span class="line">| MARTIN | SALESMAN |</span><br><span class="line">| BLAKE  | MANAGER  |</span><br><span class="line">| CLARK  | MANAGER  |</span><br><span class="line">| TURNER | SALESMAN |</span><br><span class="line">+--------+----------+</span><br><span class="line">第三种：union</span><br><span class="line">select ename,job from emp where job = &#x27;MANAGER&#x27;</span><br><span class="line">union</span><br><span class="line">select ename,job from emp where job = &#x27;SALESMAN&#x27;;</span><br><span class="line">+--------+----------+</span><br><span class="line">| ename  | job      |</span><br><span class="line">+--------+----------+</span><br><span class="line">| JONES  | MANAGER  |</span><br><span class="line">| BLAKE  | MANAGER  |</span><br><span class="line">| CLARK  | MANAGER  |</span><br><span class="line">| ALLEN  | SALESMAN |</span><br><span class="line">| WARD   | SALESMAN |</span><br><span class="line">| MARTIN | SALESMAN |</span><br><span class="line">| TURNER | SALESMAN |</span><br><span class="line">+--------+----------+</span><br><span class="line"></span><br><span class="line">两张不相干的表中的数据拼接在一起显示？</span><br><span class="line">select ename from emp</span><br><span class="line">union</span><br><span class="line">select dname from dept;</span><br><span class="line"></span><br><span class="line">+------------+</span><br><span class="line">| ename      |</span><br><span class="line">+------------+</span><br><span class="line">| SMITH      |</span><br><span class="line">| ALLEN      |</span><br><span class="line">| WARD       |</span><br><span class="line">| JONES      |</span><br><span class="line">| MARTIN     |</span><br><span class="line">| BLAKE      |</span><br><span class="line">| CLARK      |</span><br><span class="line">| SCOTT      |</span><br><span class="line">| KING       |</span><br><span class="line">| TURNER     |</span><br><span class="line">| ADAMS      |</span><br><span class="line">| JAMES      |</span><br><span class="line">| FORD       |</span><br><span class="line">| MILLER     |</span><br><span class="line">| ACCOUNTING |</span><br><span class="line">| RESEARCH   |</span><br><span class="line">| SALES      |</span><br><span class="line">| OPERATIONS |</span><br><span class="line">+------------+</span><br><span class="line"></span><br><span class="line">mysql&gt; select ename,sal from emp</span><br><span class="line">    -&gt; union</span><br><span class="line">    -&gt; select dname from dept;</span><br><span class="line">ERROR 1222 (21000): The used SELECT statements have a different number of columns</span><br></pre></td></tr></table></figure>
<p>5、limit (重点中的重点，以后分页查询全靠它了。)</p>
<p>5.1、limit是mysql特有的，其他数据库中没有，不通用。（Oracle中有一个相同的机制，叫做rownum）</p>
<p>5.2、limit取结果集中的部分数据，这时它的作用。</p>
<p>5.3、语法机制：</p>
<pre><code>limit startIndex, length
	startIndex表示起始位置，从0开始，0表示第一条数据。
	length表示取几个
案例：取出工资前5名的员工（思路：降序取前5个）
	select ename,sal from emp order by sal desc;
	取前5个：
		select ename,sal from emp order by sal desc limit 0, 5;
		select ename,sal from emp order by sal desc limit 5;
</code></pre>
<p>5.4、limit是sql语句最后执行的一个环节：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select			5</span><br><span class="line">	...</span><br><span class="line">from			1</span><br><span class="line">	...		</span><br><span class="line">where			2</span><br><span class="line">	...	</span><br><span class="line">group by		3</span><br><span class="line">	...</span><br><span class="line">having			4</span><br><span class="line">	...</span><br><span class="line">order by		6	</span><br><span class="line">	...</span><br><span class="line">limit			7</span><br><span class="line">	...;</span><br></pre></td></tr></table></figure>
<p>5.5、案例：找出工资排名在第4到第9名的员工？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ename,sal from emp order by sal desc limit 3,6;</span><br><span class="line">+--------+---------+</span><br><span class="line">| ename  | sal     |</span><br><span class="line">+--------+---------+</span><br><span class="line">| JONES  | 2975.00 |</span><br><span class="line">| BLAKE  | 2850.00 |</span><br><span class="line">| CLARK  | 2450.00 |</span><br><span class="line">| ALLEN  | 1600.00 |</span><br><span class="line">| TURNER | 1500.00 |</span><br><span class="line">| MILLER | 1300.00 |</span><br><span class="line">+--------+---------+</span><br></pre></td></tr></table></figure>
<p>5.6、通用的标准分页sql？</p>
<pre><code>每页显示3条记录：
第1页：0, 3
第2页：3, 3
第3页：6, 3
第4页：9, 3
第5页：12, 3

每页显示pageSize条记录：
第pageNo页：(pageNo - 1) * pageSize, pageSize

pageSize是什么？是每页显示多少条记录
pageNo是什么？显示第几页

java代码&#123;
	int pageNo = 2; // 页码是2
	int pageSize = 10; // 每页显示10条
limit (pageNo - 1) * pageSize, pageSize
&#125;
</code></pre>
<p>6、创建表：</p>
<pre><code>建表语句的语法格式：
	create table 表名(
		字段名1 数据类型,
		字段名2 数据类型,
		字段名3 数据类型,
		....
	);

关于MySQL当中字段的数据类型？以下只说常见的
	int		整数型(java中的int)
	bigint	长整型(java中的long)
	float		浮点型(java中的float double)
	char		定长字符串(String)
	varchar	可变长字符串(StringBuffer/StringBuilder)
	date		日期类型 （对应Java中的java.sql.Date类型）
	BLOB		二进制大对象（存储图片、视频等流媒体信息） Binary Large OBject （对应java中的Object）
	CLOB		字符大对象（存储较大文本，比如，可以存储4G的字符串。） Character Large OBject（对应java中的Object）
	......

char和varchar怎么选择？
	在实际的开发中，当某个字段中的数据长度不发生改变的时候，是定长的，例如：性别、生日等都是采用char。
	当一个字段的数据长度不确定，例如：简介、姓名等都是采用varchar。

BLOB和CLOB类型的使用？
	电影表: t_movie
	id(int)	name(varchar)		playtime(date/char)		haibao(BLOB)		history(CLOB)
	----------------------------------------------------------------------------------------
	1			蜘蛛侠	
	2
	3

表名在数据库当中一般建议以：t_或者tbl_开始。

创建学生表：
	学生信息包括：
		学号、姓名、性别、班级编号、生日
		学号：bigint
		姓名：varchar
		性别：char
		班级编号：int
		生日：char
	
	create table t_student(
		no bigint,
		name varchar(255),
		sex char(1),
		classno varchar(255),
		birth char(10)
	);
</code></pre>
<p>7、insert语句插入数据</p>
<pre><code>语法格式：
	insert into 表名(字段名1,字段名2,字段名3,....) values(值1,值2,值3,....)
	要求：字段的数量和值的数量相同，并且数据类型要对应相同。
insert into t_student(no,name,sex,classno,birth) values(1,'zhangsan','1','gaosan1ban');
ERROR 1136 (21S01): Column count doesn't match value count at row 1

insert into t_student(no,name,sex,classno,birth) values(1,'zhangsan','1','gaosan1ban', '1950-10-12');

mysql&gt; select * from t_student;
+------+----------+------+------------+------------+
| no   | name     | sex  | classno    | birth      |
+------+----------+------+------------+------------+
|    1 | zhangsan | 1    | gaosan1ban | 1950-10-12 |
+------+----------+------+------------+------------+

insert into t_student(name,sex,classno,birth,no) values('lisi','1','gaosan1ban', '1950-10-12',2);

mysql&gt; select * from t_student;
+------+----------+------+------------+------------+
| no   | name     | sex  | classno    | birth      |
+------+----------+------+------------+------------+
|    1 | zhangsan | 1    | gaosan1ban | 1950-10-12 |
|    2 | lisi     | 1    | gaosan1ban | 1950-10-12 |
+------+----------+------+------------+------------+

insert into t_student(name) values('wangwu'); // 除name字段之外，剩下的所有字段自动插入NULL。
mysql&gt; select * from t_student;
+------+----------+------+------------+------------+
| no   | name     | sex  | classno    | birth      |
+------+----------+------+------------+------------+
|    1 | zhangsan | 1    | gaosan1ban | 1950-10-12 |
|    2 | lisi     | 1    | gaosan1ban | 1950-10-12 |
| NULL | wangwu   | NULL | NULL       | NULL       |
+------+----------+------+------------+------------+

insert into t_student(no) values(3); 
mysql&gt; select * from t_student;
+------+----------+------+------------+------------+
| no   | name     | sex  | classno    | birth      |
+------+----------+------+------------+------------+
|    1 | zhangsan | 1    | gaosan1ban | 1950-10-12 |
|    2 | lisi     | 1    | gaosan1ban | 1950-10-12 |
| NULL | wangwu   | NULL | NULL       | NULL       |
|    3 | NULL     | NULL | NULL       | NULL       |
+------+----------+------+------------+------------+

drop table if exists t_student; // 当这个表存在的话删除。
create table t_student(
	no bigint,
	name varchar(255),
	sex char(1) default 1,
	classno varchar(255),
	birth char(10)
);

insert into t_student(name) values('zhangsan');
mysql&gt; select * from t_student;
+------+----------+------+---------+-------+
| no   | name     | sex  | classno | birth |
+------+----------+------+---------+-------+
| NULL | zhangsan | 1    | NULL    | NULL  |
+------+----------+------+---------+-------+

需要注意的地方：
	当一条insert语句执行成功之后，表格当中必然会多一行记录。
	即使多的这一行记录当中某些字段是NULL，后期也没有办法在执行
	insert语句插入数据了，只能使用update进行更新。

// 字段可以省略不写，但是后面的value对数量和顺序都有要求。
insert into t_student values(1,'jack','0','gaosan2ban','1986-10-23');
mysql&gt; select * from t_student;
+------+----------+------+------------+------------+
| no   | name     | sex  | classno    | birth      |
+------+----------+------+------------+------------+
| NULL | zhangsan | 1    | NULL       | NULL       |
|    1 | jack     | 0    | gaosan2ban | 1986-10-23 |
+------+----------+------+------------+------------+

insert into t_student values(1,'jack','0','gaosan2ban');
ERROR 1136 (21S01): Column count doesn't match value count at row 1

// 一次插入多行数据
insert into t_student
	(no,name,sex,classno,birth) 
values
	(3,'rose','1','gaosi2ban','1952-12-14'),(4,'laotie','1','gaosi2ban','1955-12-14');

mysql&gt; select * from t_student;
+------+----------+------+------------+------------+
| no   | name     | sex  | classno    | birth      |
+------+----------+------+------------+------------+
| NULL | zhangsan | 1    | NULL       | NULL       |
|    1 | jack     | 0    | gaosan2ban | 1986-10-23 |
|    3 | rose     | 1    | gaosi2ban  | 1952-12-14 |
|    4 | laotie   | 1    | gaosi2ban  | 1955-12-14 |
+------+----------+------+------------+------------+
</code></pre>
<p>8、表的复制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">	create table 表名 as select语句;</span><br><span class="line">	将查询结果当做表创建出来。</span><br></pre></td></tr></table></figure>
<p>9、将查询结果插入到一张表中？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; insert into dept1 select * from dept;</span><br><span class="line">mysql&gt; select * from dept1;</span><br><span class="line">+--------+------------+----------+</span><br><span class="line">| DEPTNO | DNAME      | LOC      |</span><br><span class="line">+--------+------------+----------+</span><br><span class="line">|     10 | ACCOUNTING | NEW YORK |</span><br><span class="line">|     20 | RESEARCH   | DALLAS   |</span><br><span class="line">|     30 | SALES      | CHICAGO  |</span><br><span class="line">|     40 | OPERATIONS | BOSTON   |</span><br><span class="line">|     10 | ACCOUNTING | NEW YORK |</span><br><span class="line">|     20 | RESEARCH   | DALLAS   |</span><br><span class="line">|     30 | SALES      | CHICAGO  |</span><br><span class="line">|     40 | OPERATIONS | BOSTON   |</span><br><span class="line">+--------+------------+----------+</span><br></pre></td></tr></table></figure>
<p>10、修改数据：update</p>
<pre><code>语法格式：
	update 表名 set 字段名1=值1,字段名2=值2... where 条件;

注意：没有条件整张表数据全部更新。

案例：将部门10的LOC修改为SHANGHAI，将部门名称修改为RENSHIBU
update dept1 set loc = 'SHANGHAI', dname = 'RENSHIBU' where deptno = 10;
mysql&gt; select * from dept1;
+--------+------------+----------+
| DEPTNO | DNAME      | LOC      |
+--------+------------+----------+
|     10 | RENSHIBU   | SHANGHAI |
|     20 | RESEARCH   | DALLAS   |
|     30 | SALES      | CHICAGO  |
|     40 | OPERATIONS | BOSTON   |
|     10 | RENSHIBU   | SHANGHAI |
|     20 | RESEARCH   | DALLAS   |
|     30 | SALES      | CHICAGO  |
|     40 | OPERATIONS | BOSTON   |
+--------+------------+----------+

更新所有记录
	update dept1 set loc = 'x', dname = 'y';
	mysql&gt; select * from dept1;
	+--------+-------+------+
	| DEPTNO | DNAME | LOC  |
	+--------+-------+------+
	|     10 | y     | x    |
	|     20 | y     | x    |
	|     30 | y     | x    |
	|     40 | y     | x    |
	|     10 | y     | x    |
	|     20 | y     | x    |
	|     30 | y     | x    |
	|     40 | y     | x    |
	+--------+-------+------+
</code></pre>
<p>11、删除数据？<br>
语法格式：<br>
delete from 表名 where 条件;</p>
<pre><code>语法格式：
		delete from 表名 where 条件;
注意：没有条件全部删除。

删除10部门数据？
	delete from dept1 where deptno = 10;

删除所有记录？
	delete from dept1;

怎么删除大表中的数据？（重点）
	truncate table 表名; // 表被截断，不可回滚。永久丢失。
删除表？
	drop table 表名; // 这个通用。
	drop table if exists 表名; // oracle不支持这种写法。
</code></pre>
<p>12、对于表结构的修改，这里不讲了，大家使用工具完成即可，因为在实际开发中表一旦<br>
设计好之后，对表结构的修改是很少的，修改表结构就是对之前的设计进行了否定，即使<br>
需要修改表结构，我们也可以直接使用工具操作。修改表结构的语句不会出现在Java代码当中。<br>
出现在java代码当中的sql包括：insert delete update select（这些都是表中的数据操作。）</p>
<p>增删改查有一个术语：CRUD操作<br>
Create（增） Retrieve（检索） Update（修改） Delete（删除）</p>
<p>13、约束(Constraint)</p>
<p>13.1、什么是约束？常见的约束有哪些呢？<br>
在创建表的时候，可以给表的字段添加相应的约束，添加约束的目的是为了保证表中数据的<br>
合法性、有效性、完整性。<br>
常见的约束有哪些呢？<br>
非空约束(not null)：约束的字段不能为NULL<br>
唯一约束(unique)：约束的字段不能重复<br>
主键约束(primary key)：约束的字段既不能为NULL，也不能重复（简称PK）<br>
外键约束(foreign key)：…（简称FK）<br>
检查约束(check)：注意Oracle数据库有check约束，但是mysql没有，目前mysql不支持该约束。</p>
<p>13.2、非空约束 not null</p>
<pre><code>drop table if exists t_user;
create table t_user(
	id int,
	username varchar(255) not null,
	password varchar(255)
);
insert into t_user(id,password) values(1,'123');
ERROR 1364 (HY000): Field 'username' doesn't have a default value
insert into t_user(id,username,password) values(1,'lisi','123');
</code></pre>
<h3 id="第三部分">第三部分<a title="#第三部分" href="#第三部分"></a></h3>
<p>1、约束</p>
<p>1.1、唯一性约束（unique）</p>
<pre><code>* 唯一约束修饰的字段具有唯一性，不能重复。但可以为NULL。
* 案例：给某一列添加unique
	drop table if exists t_user;
	create table t_user(
		id int,
		username varchar(255) unique  // 列级约束
	);
	insert into t_user values(1,'zhangsan');
	insert into t_user values(2,'zhangsan');
	ERROR 1062 (23000): Duplicate entry 'zhangsan' for key 'username'

	insert into t_user(id) values(2);
	insert into t_user(id) values(3);
	insert into t_user(id) values(4);
* 案例：给两个列或者多个列添加unique
	drop table if exists t_user;
	create table t_user(
		id int, 
		usercode varchar(255),
		username varchar(255),
		unique(usercode,username) // 多个字段联合起来添加1个约束unique 【表级约束】
	);

	insert into t_user values(1,'111','zs');
	insert into t_user values(2,'111','ls');
	insert into t_user values(3,'222','zs');
	select * from t_user;
	insert into t_user values(4,'111','zs');
	ERROR 1062 (23000): Duplicate entry '111-zs' for key 'usercode'

	drop table if exists t_user;
	create table t_user(
		id int, 
		usercode varchar(255) unique,
		username varchar(255) unique
	);
	insert into t_user values(1,'111','zs');
	insert into t_user values(2,'111','ls');
	ERROR 1062 (23000): Duplicate entry '111' for key 'usercode'
* 注意：not null约束只有列级约束。没有表级约束。
</code></pre>
<p>1.2、主键约束</p>
<pre><code>* 怎么给一张表添加主键约束呢？
	drop table if exists t_user;
	create table t_user(
		id int primary key,  // 列级约束
		username varchar(255),
		email varchar(255)
	);
	insert into t_user(id,username,email) values(1,'zs','zs@123.com');
	insert into t_user(id,username,email) values(2,'ls','ls@123.com');
	insert into t_user(id,username,email) values(3,'ww','ww@123.com');
	select * from t_user;
	+----+----------+------------+
	| id | username | email      |
	+----+----------+------------+
	|  1 | zs       | zs@123.com |
	|  2 | ls       | ls@123.com |
	|  3 | ww       | ww@123.com |
	+----+----------+------------+

	insert into t_user(id,username,email) values(1,'jack','jack@123.com');
	ERROR 1062 (23000): Duplicate entry '1' for key 'PRIMARY'

	insert into t_user(username,email) values('jack','jack@123.com');
	ERROR 1364 (HY000): Field 'id' doesn't have a default value
	
	根据以上的测试得出：id是主键，因为添加了主键约束，主键字段中的数据不能为NULL，也不能重复。
	主键的特点：不能为NULL，也不能重复。

* 主键相关的术语？
	主键约束 : primary key
	主键字段 : id字段添加primary key之后，id叫做主键字段
	主键值 : id字段中的每一个值都是主键值。

* 主键有什么作用？
	- 表的设计三范式中有要求，第一范式就要求任何一张表都应该有主键。
	- 主键的作用：主键值是这行记录在这张表当中的唯一标识。（就像一个人的身份证号码一样。）

* 主键的分类？
	根据主键字段的字段数量来划分：
		单一主键（推荐的，常用的。）
		复合主键(多个字段联合起来添加一个主键约束)（复合主键不建议使用，因为复合主键违背三范式。）
	根据主键性质来划分：
		自然主键：主键值最好就是一个和业务没有任何关系的自然数。（这种方式是推荐的）
		业务主键：主键值和系统的业务挂钩，例如：拿着银行卡的卡号做主键，拿着身份证号码作为主键。（不推荐用）
					  最好不要拿着和业务挂钩的字段作为主键。因为以后的业务一旦发生改变的时候，主键值可能也需要
					  随着发生变化，但有的时候没有办法变化，因为变化可能会导致主键值重复。

* 一张表的主键约束只能有1个。（必须记住）

* 使用表级约束方式定义主键：
	drop table if exists t_user;
	create table t_user(
		id int,
		username varchar(255),
		primary key(id)
	);
	insert into t_user(id,username) values(1,'zs');
	insert into t_user(id,username) values(2,'ls');
	insert into t_user(id,username) values(3,'ws');
	insert into t_user(id,username) values(4,'cs');
	select * from t_user;

	insert into t_user(id,username) values(4,'cx');
	ERROR 1062 (23000): Duplicate entry '4' for key 'PRIMARY'

	以下内容是演示以下复合主键，不需要掌握：
		drop table if exists t_user;
		create table t_user(
			id int,
			username varchar(255),
			password varchar(255),
			primary key(id,username)
		);
		insert .......

* mysql提供主键值自增：（非常重要。）
	drop table if exists t_user;
	create table t_user(
		id int primary key auto_increment, // id字段自动维护一个自增的数字，从1开始，以1递增。
		username varchar(255)
	);
	insert into t_user(username) values('a');
	insert into t_user(username) values('b');
	insert into t_user(username) values('c');
	insert into t_user(username) values('d');
	insert into t_user(username) values('e');
	insert into t_user(username) values('f');
	select * from t_user;

	提示:Oracle当中也提供了一个自增机制，叫做：序列（sequence）对象。
</code></pre>
<p>1.3、外键约束</p>
<pre><code>* 关于外键约束的相关术语：
	外键约束: foreign key
	外键字段：添加有外键约束的字段
	外键值：外键字段中的每一个值。

* 业务背景：
	请设计数据库表，用来维护学生和班级的信息？
		第一种方案：一张表存储所有数据
		no(pk)			name			classno			classname
		-------------------------------------------------------------------------------------------
		1					zs1				101				北京大兴区经济技术开发区亦庄二中高三1班
		2					zs2				101				北京大兴区经济技术开发区亦庄二中高三1班
		3					zs3				102				北京大兴区经济技术开发区亦庄二中高三2班
		4					zs4				102				北京大兴区经济技术开发区亦庄二中高三2班
		5					zs5				102				北京大兴区经济技术开发区亦庄二中高三2班
		缺点：冗余。【不推荐】

		第二种方案：两张表（班级表和学生表）
		t_class 班级表
		cno(pk)		cname
		--------------------------------------------------------
		101		北京大兴区经济技术开发区亦庄二中高三1班
		102		北京大兴区经济技术开发区亦庄二中高三2班

		t_student 学生表
		sno(pk)		sname				classno(该字段添加外键约束fk)
		------------------------------------------------------------
		1				zs1				101
		2				zs2				101
		3				zs3				102
		4				zs4				102
		5				zs5				102
	
* 将以上表的建表语句写出来：

	t_student中的classno字段引用t_class表中的cno字段，此时t_student表叫做子表。t_class表叫做父表。

	顺序要求：
		删除数据的时候，先删除子表，再删除父表。
		添加数据的时候，先添加父表，在添加子表。
		创建表的时候，先创建父表，再创建子表。
		删除表的时候，先删除子表，在删除父表。
	
	drop table if exists t_student;
	drop table if exists t_class;

	create table t_class(
		cno int,
		cname varchar(255),
		primary key(cno)
	);

	create table t_student(
		sno int,
		sname varchar(255),
		classno int,
		primary key(sno),
		foreign key(classno) references t_class(cno)
	);

	insert into t_class values(101,'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx');
	insert into t_class values(102,'yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy');

	insert into t_student values(1,'zs1',101);
	insert into t_student values(2,'zs2',101);
	insert into t_student values(3,'zs3',102);
	insert into t_student values(4,'zs4',102);
	insert into t_student values(5,'zs5',102);
	insert into t_student values(6,'zs6',102);
	select * from t_class;
	select * from t_student;

	insert into t_student values(7,'lisi',103);
	ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (`bjpowernode`.INT `t_student_ibfk_1` FOREIGN KEY (`classno`) REFERENCES `t_class` (`cno`))

* 外键值可以为NULL？
	外键可以为NULL。

* 外键字段引用其他表的某个字段的时候，被引用的字段必须是主键吗？
	注意：被引用的字段不一定是主键，但至少具有unique约束。
</code></pre>
<p>2、存储引擎？（整个内容属于了解内容）</p>
<pre><code>2.1、完整的建表语句
	CREATE TABLE `t_x` (
	  `id` int(11) DEFAULT NULL
	) ENGINE=InnoDB DEFAULT CHARSET=utf8;

	注意：在MySQL当中，凡是标识符是可以使用飘号括起来的。最好别用，不通用。

	建表的时候可以指定存储引擎，也可以指定字符集。

	mysql默认使用的存储引擎是InnoDB方式。
	默认采用的字符集是UTF8

2.2、什么是存储引擎呢？
	存储引擎这个名字只有在mysql中存在。（Oracle中有对应的机制，但是不叫做存储引擎。Oracle中没有特殊的名字，
	就是“表的存储方式”）

	mysql支持很多存储引擎，每一个存储引擎都对应了一种不同的存储方式。
	每一个存储引擎都有自己的优缺点，需要在合适的时机选择合适的存储引擎。

2.3、查看当前mysql支持的存储引擎？
	show engines \G

	mysql 5.5.36版本支持的存储引擎有9个：
		*************************** 1. row ***************************
				Engine: FEDERATED
			  Support: NO
			  Comment: Federated MySQL storage engine
		Transactions: NULL
					 XA: NULL
		  Savepoints: NULL
		*************************** 2. row ***************************
				Engine: MRG_MYISAM
			  Support: YES
			  Comment: Collection of identical MyISAM tables
		Transactions: NO
					 XA: NO
		  Savepoints: NO
		*************************** 3. row ***************************
				Engine: MyISAM
			  Support: YES
			  Comment: MyISAM storage engine
		Transactions: NO
					 XA: NO
		  Savepoints: NO
		*************************** 4. row ***************************
				Engine: BLACKHOLE
			  Support: YES
			  Comment: /dev/null storage engine (anything you write to it disappears)
		Transactions: NO
					 XA: NO
		  Savepoints: NO
		*************************** 5. row ***************************
				Engine: CSV
			  Support: YES
			  Comment: CSV storage engine
		Transactions: NO
					 XA: NO
		  Savepoints: NO
		*************************** 6. row ***************************
				Engine: MEMORY
			  Support: YES
			  Comment: Hash based, stored in memory, useful for temporary tables
		Transactions: NO
					 XA: NO
		  Savepoints: NO
		*************************** 7. row ***************************
				Engine: ARCHIVE
			  Support: YES
			  Comment: Archive storage engine
		Transactions: NO
					 XA: NO
		  Savepoints: NO
		*************************** 8. row ***************************
				Engine: InnoDB
			  Support: DEFAULT
			  Comment: Supports transactions, row-level locking, and foreign keys
		Transactions: YES
					 XA: YES
		  Savepoints: YES
		*************************** 9. row ***************************
				Engine: PERFORMANCE_SCHEMA
			  Support: YES
			  Comment: Performance Schema
		Transactions: NO
					 XA: NO
		  Savepoints: NO

2.4、常见的存储引擎？

		Engine: MyISAM
			  Support: YES
			  Comment: MyISAM storage engine
		Transactions: NO
					 XA: NO
		  Savepoints: NO
		
		MyISAM这种存储引擎不支持事务。
		MyISAM是mysql最常用的存储引擎，但是这种引擎不是默认的。
		MyISAM采用三个文件组织一张表：
			xxx.frm（存储格式的文件）
			xxx.MYD（存储表中数据的文件）
			xxx.MYI（存储表中索引的文件）
		优点：可被压缩，节省存储空间。并且可以转换为只读表，提高检索效率。
		缺点：不支持事务。

	-----------------------------------------------------------------------------

			  Engine: InnoDB
			  Support: DEFAULT
			  Comment: Supports transactions, row-level locking, and foreign keys
		Transactions: YES
					 XA: YES
		  Savepoints: YES
			
		优点：支持事务、行级锁、外键等。这种存储引擎数据的安全得到保障。
		
		表的结构存储在xxx.frm文件中
		数据存储在tablespace这样的表空间中（逻辑概念），无法被压缩，无法转换成只读。
		这种InnoDB存储引擎在MySQL数据库崩溃之后提供自动恢复机制。
		InnoDB支持级联删除和级联更新。
	
	-------------------------------------------------------------------------------------

				Engine: MEMORY
			  Support: YES
			  Comment: Hash based, stored in memory, useful for temporary tables
		Transactions: NO
					 XA: NO
		  Savepoints: NO
		
		缺点：不支持事务。数据容易丢失。因为所有数据和索引都是存储在内存当中的。
		优点：查询速度最快。
		以前叫做HEPA引擎。
</code></pre>
<p>3、事务（Transaction）</p>
<pre><code>3.1、什么是事务？

	一个事务是一个完整的业务逻辑单元，不可再分。

	比如：银行账户转账，从A账户向B账户转账10000.需要执行两条update语句：
		update t_act set balance = balance - 10000 where actno = 'act-001';
		update t_act set balance = balance + 10000 where actno = 'act-002';
	
	以上两条DML语句必须同时成功，或者同时失败，不允许出现一条成功，一条失败。

	要想保证以上的两条DML语句同时成功或者同时失败，那么就需要使用数据库的“事务机制”。

3.2、和事务相关的语句只有：DML语句。（insert delete update）
	为什么？因为它们这三个语句都是和数据库表当中的“数据”相关的。
	事务的存在是为了保证数据的完整性，安全性。

3.3、假设所有的业务都能使用1条DML语句搞定，还需要事务机制吗？
	不需要事务。
	但实际情况不是这样的，通常一个“事儿（事务【业务】）”需要多条DML语句共同联合完成。

3.4、事务的特性？
	事务包括四大特性：ACID
	A: 原子性：事务是最小的工作单元，不可再分。
	C: 一致性：事务必须保证多条DML语句同时成功或者同时失败。
	I：隔离性：事务A与事务B之间具有隔离。
	D：持久性：持久性说的是最终数据必须持久化到硬盘文件中，事务才算成功的结束。

3.5、关于事务之间的隔离性
	事务隔离性存在隔离级别，理论上隔离级别包括4个：
		第一级别：读未提交（read uncommitted）
			对方事务还没有提交，我们当前事务可以读取到对方未提交的数据。
			读未提交存在脏读（Dirty Read）现象：表示读到了脏的数据。
		第二级别：读已提交（read committed）
			对方事务提交之后的数据我方可以读取到。
			这种隔离级别解决了: 脏读现象没有了。
			读已提交存在的问题是：不可重复读。
		第三级别：可重复读（repeatable read）
			这种隔离级别解决了：不可重复读问题。
			这种隔离级别存在的问题是：读取到的数据是幻象。
		第四级别：序列化读/串行化读（serializable） 
			解决了所有问题。
			效率低。需要事务排队。
		
		oracle数据库默认的隔离级别是：读已提交。
		mysql数据库默认的隔离级别是：可重复读。

3.6、演示事务
	* mysql事务默认情况下是自动提交的。
		（什么是自动提交？只要执行任意一条DML语句则提交一次。）怎么关闭自动提交？start transaction;
	
	* 准备表：
		drop table if exists t_user;
		create table t_user(
			id int primary key auto_increment,
			username varchar(255)
		);
	
	* 演示：mysql中的事务是支持自动提交的，只要执行一条DML，则提交一次。
		mysql&gt; insert into t_user(username) values('zs');
		Query OK, 1 row affected (0.03 sec)

		mysql&gt; select * from t_user;
		+----+----------+
		| id | username |
		+----+----------+
		|  1 | zs       |
		+----+----------+
		1 row in set (0.00 sec)

		mysql&gt; rollback;
		Query OK, 0 rows affected (0.00 sec)

		mysql&gt; select * from t_user;
		+----+----------+
		| id | username |
		+----+----------+
		|  1 | zs       |
		+----+----------+
		1 row in set (0.00 sec)
	
	* 演示：使用start transaction;关闭自动提交机制。
		mysql&gt; start transaction;
		Query OK, 0 rows affected (0.00 sec)

		mysql&gt; insert into t_user(username) values('lisi');
		Query OK, 1 row affected (0.00 sec)

		mysql&gt; select * from t_user;
		+----+----------+
		| id | username |
		+----+----------+
		|  1 | zs       |
		|  2 | lisi     |
		+----+----------+
		2 rows in set (0.00 sec)

		mysql&gt; insert into t_user(username) values('wangwu');
		Query OK, 1 row affected (0.00 sec)

		mysql&gt; select * from t_user;
		+----+----------+
		| id | username |
		+----+----------+
		|  1 | zs       |
		|  2 | lisi     |
		|  3 | wangwu   |
		+----+----------+
		3 rows in set (0.00 sec)

		mysql&gt; rollback;
		Query OK, 0 rows affected (0.02 sec)

		mysql&gt; select * from t_user;
		+----+----------+
		| id | username |
		+----+----------+
		|  1 | zs       |
		+----+----------+
		1 row in set (0.00 sec)
		--------------------------------------------------------------------
		mysql&gt; start transaction;
		Query OK, 0 rows affected (0.00 sec)

		mysql&gt; insert into t_user(username) values('wangwu');
		Query OK, 1 row affected (0.00 sec)

		mysql&gt; insert into t_user(username) values('rose');
		Query OK, 1 row affected (0.00 sec)

		mysql&gt; insert into t_user(username) values('jack');
		Query OK, 1 row affected (0.00 sec)

		mysql&gt; select * from t_user;
		+----+----------+
		| id | username |
		+----+----------+
		|  1 | zs       |
		|  4 | wangwu   |
		|  5 | rose     |
		|  6 | jack     |
		+----+----------+
		4 rows in set (0.00 sec)

		mysql&gt; commit;
		Query OK, 0 rows affected (0.04 sec)

		mysql&gt; select * from t_user;
		+----+----------+
		| id | username |
		+----+----------+
		|  1 | zs       |
		|  4 | wangwu   |
		|  5 | rose     |
		|  6 | jack     |
		+----+----------+
		4 rows in set (0.00 sec)

		mysql&gt; rollback;
		Query OK, 0 rows affected (0.00 sec)

		mysql&gt; select * from t_user;
		+----+----------+
		| id | username |
		+----+----------+
		|  1 | zs       |
		|  4 | wangwu   |
		|  5 | rose     |
		|  6 | jack     |
		+----+----------+
		4 rows in set (0.00 sec)

	* 演示两个事务，假如隔离级别
		演示第1级别：读未提交
			set global transaction isolation level read uncommitted;
		演示第2级别：读已提交
			set global transaction isolation level read committed;
		演示第3级别：可重复读
			set global transaction isolation level repeatable read;
		
	* mysql远程登录：mysql -h192.168.151.18 -uroot -p444
</code></pre>
<p>4、索引</p>
<pre><code>4.1、什么是索引？有什么用？
	索引就相当于一本书的目录，通过目录可以快速的找到对应的资源。
	在数据库方面，查询一张表的时候有两种检索方式：
		第一种方式：全表扫描
		第二种方式：根据索引检索（效率很高）

	索引为什么可以提高检索效率呢？
		其实最根本的原理是缩小了扫描的范围。
	
	索引虽然可以提高检索效率，但是不能随意的添加索引，因为索引也是数据库当中
	的对象，也需要数据库不断的维护。是有维护成本的。比如，表中的数据经常被修改
	这样就不适合添加索引，因为数据一旦修改，索引需要重新排序，进行维护。

	添加索引是给某一个字段，或者说某些字段添加索引。

	select ename,sal from emp where ename = 'SMITH';
	当ename字段上没有添加索引的时候，以上sql语句会进行全表扫描，扫描ename字段中所有的值。
	当ename字段上添加索引的时候，以上sql语句会根据索引扫描，快速定位。

4.2、怎么创建索引对象？怎么删除索引对象？
	创建索引对象：
		create index 索引名称 on 表名(字段名);
	删除索引对象：
		drop index 索引名称 on 表名;

4.3、什么时候考虑给字段添加索引？（满足什么条件）
	* 数据量庞大。（根据客户的需求，根据线上的环境）
	* 该字段很少的DML操作。（因为字段进行修改操作，索引也需要维护）
	* 该字段经常出现在where子句中。（经常根据哪个字段查询）

4.4、注意：主键和具有unique约束的字段自动会添加索引。
	根据主键查询效率较高。尽量根据主键检索。

4.5、查看sql语句的执行计划：
mysql&gt; explain select ename,sal from emp where sal = 5000;
+----+-------------+-------+------+---------------+------+---------+------+------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows |
+----+-------------+-------+------+---------------+------+---------+------+------+
|  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | NULL |   14 |
+----+-------------+-------+------+---------------+------+---------+------+------+
+-------------+
| Extra       |
+-------------+
| Using where |
+-------------+
给薪资sal字段添加索引：
create index emp_sal_index on emp(sal);	
mysql&gt; explain select ename,sal from emp where sal = 5000;
+----+-------------+-------+------+---------------+---------------+---------+-------+
| id | select_type | table | type | possible_keys | key           | key_len | ref   |
+----+-------------+-------+------+---------------+---------------+---------+-------+
|  1 | SIMPLE      | emp   | ref  | emp_sal_index | emp_sal_index | 9       | const |
+----+-------------+-------+------+---------------+---------------+---------+-------+
+------+-------------+
| rows | Extra       |
+------+-------------+
|    1 | Using where |
+------+-------------+
4.6、索引底层采用的数据结构是：B + Tree

4.7、索引的实现原理？
	通过B Tree缩小扫描范围，底层索引进行了排序，分区，索引会携带数据在表中的“物理地址”，
	最终通过索引检索到数据之后，获取到关联的物理地址，通过物理地址定位表中的数据，效率
	是最高的。
		select ename from emp where ename = 'SMITH';
		通过索引转换为：
		select ename from emp where 物理地址 = 0x3;

4.8、索引的分类？
	单一索引：给单个字段添加索引
	复合索引: 给多个字段联合起来添加1个索引
	主键索引：主键上会自动添加索引
	唯一索引：有unique约束的字段上会自动添加索引
	....

4.9、索引什么时候失效？
	select ename from emp where ename like '%A%';
	模糊查询的时候，第一个通配符使用的是%，这个时候索引是失效的。
</code></pre>
<p>5、视图(view)</p>
<pre><code>5.1、什么是视图？
	站在不同的角度去看到数据。（同一张表的数据，通过不同的角度去看待）。

5.2、怎么创建视图？怎么删除视图？
	create view myview as select empno,ename from emp;
	drop view myview;

	注意：只有DQL语句才能以视图对象的方式创建出来。

5.3、对视图进行增删改查，会影响到原表数据。（通过视图影响原表数据的，不是直接操作的原表）
可以对视图进行CRUD操作。

5.4、面向视图操作？
	mysql&gt; select * from myview;
	+-------+--------+
	| empno | ename  |
	+-------+--------+
	|  7369 | SMITH  |
	|  7499 | ALLEN  |
	|  7521 | WARD   |
	|  7566 | JONES  |
	|  7654 | MARTIN |
	|  7698 | BLAKE  |
	|  7782 | CLARK  |
	|  7788 | SCOTT  |
	|  7839 | KING   |
	|  7844 | TURNER |
	|  7876 | ADAMS  |
	|  7900 | JAMES  |
	|  7902 | FORD   |
	|  7934 | MILLER |
	+-------+--------+

	create table emp_bak as select * from emp;
	create view myview1 as select empno,ename,sal from emp_bak;
	update myview1 set ename='hehe',sal=1 where empno = 7369; // 通过视图修改原表数据。
	delete from myview1 where empno = 7369; // 通过视图删除原表数据。

5.5、视图的作用？
	视图可以隐藏表的实现细节。保密级别较高的系统，数据库只对外提供相关的视图，java程序员
	只对视图对象进行CRUD。
</code></pre>
<p>6、DBA命令</p>
<pre><code>6.1、将数据库当中的数据导出
	在windows的dos命令窗口中执行：（导出整个库）
		mysqldump bjpowernode&gt;D:\bjpowernode.sql -uroot -p333
	
	在windows的dos命令窗口中执行：（导出指定数据库当中的指定表）
		mysqldump bjpowernode emp&gt;D:\bjpowernode.sql -uroot –p123

6.2、导入数据
	create database bjpowernode;
	use bjpowernode;
	source D:\bjpowernode.sql
</code></pre>
<p>7、数据库设计三范式（重点内容，面试经常问）</p>
<pre><code>7.1、什么是设计范式？
	设计表的依据。按照这个三范式设计的表不会出现数据冗余。

7.2、三范式都是哪些？

	第一范式：任何一张表都应该有主键，并且每一个字段原子性不可再分。

	第二范式：建立在第一范式的基础之上，所有非主键字段完全依赖主键，不能产生部分依赖。
		多对多？三张表，关系表两个外键。
		t_student学生表
		sno(pk)		sname
		-------------------
		1				张三
		2				李四
		3				王五

		t_teacher 讲师表
		tno(pk)		tname
		---------------------
		1				王老师
		2				张老师
		3				李老师

		t_student_teacher_relation 学生讲师关系表
		id(pk)		sno(fk)		tno(fk)
		----------------------------------
		1				1				3
		2				1				1
		3				2				2
		4				2				3
		5				3				1
		6				3				3
	
	第三范式：建立在第二范式的基础之上，所有非主键字段直接依赖主键，不能产生传递依赖。
		一对多？两张表，多的表加外键。
		班级t_class
		cno(pk)			cname
		--------------------------
		1					班级1
		2					班级2

		学生t_student
		sno(pk)			sname				classno(fk)
		---------------------------------------------
		101				张1				1
		102				张2				1
		103				张3				2
		104				张4				2
		105				张5				2
	
	提醒：在实际的开发中，以满足客户的需求为主，有的时候会拿冗余换执行速度。

7.3、一对一怎么设计？

	一对一设计有两种方案：主键共享
		t_user_login  用户登录表
		id(pk)		username			password
		--------------------------------------
		1				zs					123
		2				ls					456

		t_user_detail 用户详细信息表
		id(pk+fk)	realname			tel			....
		------------------------------------------------
		1				张三				1111111111
		2				李四				1111415621

	一对一设计有两种方案：外键唯一。
		t_user_login  用户登录表
		id(pk)		username			password
		--------------------------------------
		1				zs					123
		2				ls					456

		t_user_detail 用户详细信息表
		id(pk)	   realname			tel				userid(fk+unique)....
		-----------------------------------------------------------
		1				张三				1111111111		2
		2				李四				1111415621		1
</code></pre>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Java Mysql</tag>
      </tags>
  </entry>
</search>
